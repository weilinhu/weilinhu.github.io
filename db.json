{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/uploads/tuzi.jpg","path":"uploads/tuzi.jpg","modified":1,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"6cd5b03563329ef5869f3e0191843fc1ed1c922e","modified":1520156396225},{"_id":"source/_posts/Android线程.md","hash":"dbfc483a6bd355314825b9fb3e8f5b83b8e4da1e","modified":1480231939000},{"_id":"source/_posts/Android-View的绘制.md","hash":"b60f5d1c2f7b721a51edf8d1e8ab1e008ff6042b","modified":1480231939000},{"_id":"source/_posts/Bitmap缩放技巧总结.md","hash":"f237bda17e454a390b248a4cc39da7403bacf319","modified":1480231939000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1488377987000},{"_id":"source/_posts/UML类图学习.md","hash":"c10313c936953328484cb89635dae0dffc240ba8","modified":1520160338608},{"_id":"source/_posts/Drawable、Bitmap、String、InputStream、Bitmap、byte数组互转.md","hash":"789379d859e47cd0507b43b7164d20927ac08b01","modified":1480231939000},{"_id":"source/_posts/Handler消息传递机制.md","hash":"48fd024eb88c74ad1e26780f80e8be6fb30c1815","modified":1480231939000},{"_id":"source/_posts/Surfaceview.md","hash":"86d3a2bf94780f58bf91eb8723c62407b7921545","modified":1480231939000},{"_id":"source/_posts/View事件处理.md","hash":"f2d9c838047b4e9dbf5a6572742c79f685d4af78","modified":1480231939000},{"_id":"source/_posts/自定义View的疑问.md","hash":"94efa1d693e579ed71d157562a2978e1d2ab09e1","modified":1480231939000},{"_id":"source/tags/index.md","hash":"161891a3315cdf750346bfbd07f720dd4d11ec64","modified":1480231939000},{"_id":"source/dsf/index.md","hash":"669350de72727f150dc7d117f229fb5593daa904","modified":1480231939000},{"_id":"source/uploads/tuzi.jpg","hash":"12bb45a9ecd7aea706dec43fcafba4378993a2e4","modified":1480231939000},{"_id":"public/dsf/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1520160546557},{"_id":"public/Surfaceview/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1520160546558},{"_id":"public/View事件处理/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1520160546558},{"_id":"public/Android线程/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1520160546559},{"_id":"public/Handler消息传递机制/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1520160546559},{"_id":"public/Android-View的绘制/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1520160546559},{"_id":"public/Drawable、Bitmap、String、InputStream、Bitmap、byte数组互转/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1520160546559},{"_id":"public/自定义View的疑问/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1520160546560},{"_id":"public/archives/2016/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1520160546560},{"_id":"public/tags/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1520160546560},{"_id":"public/archives/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1520160546560},{"_id":"public/archives/2016/05/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1520160546560},{"_id":"public/Bitmap缩放技巧总结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1520160546560},{"_id":"public/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1520160546560},{"_id":"public/categories/性能优化/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1520160546560},{"_id":"public/categories/View/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1520160546561},{"_id":"public/categories/Utils/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1520160546562},{"_id":"public/categories/Andoroid通信/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1520160546562},{"_id":"public/tags/线程/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1520160546562},{"_id":"public/tags/View/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1520160546562},{"_id":"public/tags/Bitmap/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1520160546562},{"_id":"public/tags/Drawable/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1520160546562},{"_id":"public/tags/Handler/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1520160546562},{"_id":"public/archives/2016/11/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1520160546565},{"_id":"public/uploads/tuzi.jpg","hash":"12bb45a9ecd7aea706dec43fcafba4378993a2e4","modified":1520160546566}],"Category":[{"name":"性能优化","_id":"cjecoc8hk0003fuv14we9ud9i"},{"name":"View","_id":"cjecoc8hp0008fuv1dx8wjiup"},{"name":"Utils","_id":"cjecoc8i6000jfuv1gdvik09l"},{"name":"Andoroid通信","_id":"cjecoc8if000rfuv1j4b06ajd"}],"Data":[],"Page":[{"title":"tags","date":"2016-05-30T12:18:25.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2016-05-30 20:18:25\ntype: \"tags\"\n---\n","updated":"2016-11-27T07:32:19.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjecoc8ik0010fuv1pprz2w3t","content":"","excerpt":"","more":""},{"title":"dsf","date":"2016-05-29T08:41:52.000Z","_content":"","source":"dsf/index.md","raw":"---\ntitle: dsf\ndate: 2016-05-29 16:41:52\n---\n","updated":"2016-11-27T07:32:19.000Z","path":"dsf/index.html","comments":1,"layout":"page","_id":"cjecoc8ik0011fuv1frzk2l7d","content":"","excerpt":"","more":""}],"Post":[{"title":"Android线程","toc":true,"date":"2016-05-30T14:27:26.000Z","_content":"- 进程优先级（Process Priority）\n  \n    - Foreground Process\n    ```\n    Foreground一般意味着用户双眼可见，可见却不一定是active。    在Android的世界里，一个Activity处于前台之时，如果能采集用    户的input事件，就可以判定为active，如果中途弹出一个Dialog    ，Dialog变成新的active实体，直接面对用户的操作。被部分遮    挡的activity尽管依然可见，但状态却变为inactive。\n    \n    ```\n    - Background Process\n    \n    ```\n    所谓的Background可以理解为不可见（invisible）。对于不可见的任务，Android也有重要性的区分。重要的后台任务定义为Service，如果一个进程包含Service（称为Service Process），那么在“重要性”上就会被系统区别对待，其优先级自然会高于不包含Service的进程（称为Background Process），最后还剩一类空进程（Empty Process）。Empty Process初看有些费解，一个Process如果什么都不做，还有什么存在的必要。其实Empty Process并不Empty，还存在不少的内存占用。\n    \n    ```\n<!-- more-->\n- 线程调度（Thread Scheduling）\n  \n```\nAndroid将线程分为多个group，其中两类group尤其重要。一类是default group，UI线程属于这一类。另一类是background group，工作线程应该归属到这一类。background group当中所有的线程加起来总共也只能分配到5～10%的time slice，剩下的全部分配给default group，这样设计显然能保证UI线程绘制UI的流畅性。\n\nAndroid开发者需要显式的将工作线程归于background group。\n\nnew Thread(new Runnable() {\n  @Override\n  public void run() {\n    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n  }\n}).start();\n\n虽说Android系统在任务调度上是以线程为基础单位，设置单个thread的优先级也可以改变其所属的control groups，从而影响CPU time slice的分配。但进程的属性变化也会影响到线程的调度，当一个App进入后台的时候，该App所属的整个进程都将进入background group，以确保处于foreground，用户可见的新进程能获取到尽可能多的CPU资源。用adb可以查看不同进程的当前调度策略。\n\n$ adb shell ps -P\n\n当你的App重新被用户切换到前台的时候，进程当中所属的线程又会回归的原来的group。在这些用户频繁切换的过程当中，thread的优先级并不会发生变化，但系统在time slice的分配上却在不停的调整。\n\n移动端App新启线程一般都是为了保证UI的流畅性，增加App用户操作的响应度。但是否需要将任务放入工作线程需要先了解任务的瓶颈在哪，是i/o，gpu还是cpu？UI出现卡顿并不一定是UI线程出现了费时的计算，有可能是其它原因，比如layout层级太深。\n\n```\n- 用什么姿势开线程？\n\n    - new Thread()\n    - AsyncTask\n    - HandlerThread\n    - ThreadPoolExecutor\n    - IntentService\n```\n这是Android系统里开线程最简单的方式，也只能应用于最简单的场景，简单的好处却伴随不少的隐患。\n\nnew Thread(new Runnable() {\n            @Override\n            public void run() {\n \n            }\n        }).start();\n\n这种方式仅仅是起动了一个新的线程，没有任务的概念，不能做状态的管理。start之后，run当中的代码就一定会执行到底，无法中途取消。\n\nRunnable作为匿名内部类还持有了外部类的引用，在线程退出之前，该引用会一直存在，阻碍外部类对象被GC回收，在一段时间内造成内存泄漏。\n\n没有线程切换的接口，要传递处理结果到UI线程的话，需要写额外的线程切换代码。\n\n如果从UI线程启动，则该线程优先级默认为Default，归于default cgroup，会平等的和UI线程争夺CPU资源。这一点尤其需要注意，在对UI性能要求高的场景下要记得\n\nProcess.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n\n虽说处于background group的线程总共只能争取到5～10%的CPU资源，但这对绝大部分的后台任务处理都绰绰有余了，1ms和10ms对用户来说，都是快到无法感知，所以我们一般都偏向于在background group当中执行工作线程任务。\n\n```\n  \n  \n```\n一个典型的AsyncTask实现如下：\n\npublic class MyAsyncTask extends AsyncTask {\n \n        @Override\n        protected Object doInBackground(Object[] params) {\n            return null;\n        }\n \n        @Override\n        protected void onPreExecute() {\n            super.onPreExecute();\n        }\n \n        @Override\n        protected void onPostExecute(Object o) {\n            super.onPostExecute(o);\n        }\n    }\n\n和使用Thread()不同的是，多了几处API回调来严格规范工作线程与UI线程之间的交互。我们大部分的业务场景几乎都符合这种规范，比如去磁盘读取图片，缩放处理需要在工作线程执行，最后绘制到ImageView控件需要切换到UI线程。\n\nAsyncTask的几处回调都给了我们机会去中断任务，在任务状态的管理上较之Thread()方式更为灵活。值得注意的是AsyncTask的cancel()方法并不会终止任务的执行，开发者需要自己去检查cancel的状态值来决定是否中止任务。\n\nAsyncTask也有隐式的持有外部类对象引用的问题，需要特别注意防止出现意外的内存泄漏。\n\nAsyncTask由于在不同的系统版本上串行与并行的执行行为不一致，被不少开发者所诟病，这确实是硬伤，绝大部分的多线程场景都需要明确任务是串行还是并行。\n\n线程优先级为background，对UI线程的执行影响极小。\n\n```\n\n```\n\n在需要对多任务做更精细控制，线程切换更频繁的场景之下，Thread()和AsyncTask都会显得力不从心。HandlerThread却能胜任这些需求甚至更多。\n\nHandlerThread将Handler，Thread，Looper，MessageQueue几个概念相结合。Handler是线程对外的接口，所有新的message或者runnable都通过handler post到工作线程。Looper在MessageQueue取到新的任务就切换到工作线程去执行。不同的post方法可以让我们对任务做精细的控制，什么时候执行，执行的顺序都可以控制。HandlerThread最大的优势在于引入MessageQueue概念，可以进行多任务队列管理。\n\nHandlerThread背后只有一个线程，所以任务是串行执行的。串行相对于并行来说更安全，各任务之间不会存在多线程安全问题。\n\nHandlerThread所产生的线程会一直存活，Looper会在该线程中持续的检查MessageQueue。这一点和Thread()，AsyncTask都不同，thread实例的重用可以避免线程相关的对象的频繁重建和销毁。\n\nHandlerThread较之Thread()，AsyncTask需要写更多的代码，但在实用性，灵活度，安全性上都有更好的表现。\n\n```\n\n```\nThread(),AsyncTask适合处理单个任务的场景，HandlerThread适合串行处理多任务的场景。当需要并行的处理多任务之时，ThreadPoolExecutor是更好的选择。\n\npublic static Executor THREAD_POOL_EXECUTOR\n= new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,\nTimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);\n\n线程池可以避免线程的频繁创建和销毁，显然性能更好，但线程池并发的特性往往也是疑难杂症的源头，是代码降级和失控的开始。多线程并行导致的bug往往是偶现的，不方便调试，一旦出现就会耗掉大量的开发精力。\n\nThreadPool较之HandlerThread在处理多任务上有更高的灵活性，但也带来了更大的复杂度和不确定性。\n\n```\n\n```\nIntentService又是另一种开工作线程的方式，从名字就可以看出这个工作线程会带有service的属性。和AsyncTask不同，没有和UI线程的交互，也不像HandlerThread的工作线程会一直存活。IntentService背后其实也有一个HandlerThread来串行的处理Message Queue，从IntentService的onCreate方法可以看出：\n\n@Override\n    public void onCreate() {\n        // TODO: It would be nice to have an option to hold a partial wakelock\n        // during processing, and to have a static startService(Context, Intent)\n        // method that would launch the service & hand off a wakelock.\n \n        super.onCreate();\n        HandlerThread thread = new HandlerThread(\"IntentService[\" + mName + \"]\");\n        thread.start();\n \n        mServiceLooper = thread.getLooper();\n        mServiceHandler = new ServiceHandler(mServiceLooper);\n    }\n\n只不过在所有的Message处理完毕之后，工作线程会自动结束。所以可以把IntentService看做是Service和HandlerThread的结合体，适合需要在工作线程处理UI无关任务的场景。\n\n```\n\n","source":"_posts/Android线程.md","raw":"---\ntitle: Android线程\ntoc: true\ndate: 2016-05-30 22:27:26\ntags: 线程\ncategories: 性能优化\n---\n- 进程优先级（Process Priority）\n  \n    - Foreground Process\n    ```\n    Foreground一般意味着用户双眼可见，可见却不一定是active。    在Android的世界里，一个Activity处于前台之时，如果能采集用    户的input事件，就可以判定为active，如果中途弹出一个Dialog    ，Dialog变成新的active实体，直接面对用户的操作。被部分遮    挡的activity尽管依然可见，但状态却变为inactive。\n    \n    ```\n    - Background Process\n    \n    ```\n    所谓的Background可以理解为不可见（invisible）。对于不可见的任务，Android也有重要性的区分。重要的后台任务定义为Service，如果一个进程包含Service（称为Service Process），那么在“重要性”上就会被系统区别对待，其优先级自然会高于不包含Service的进程（称为Background Process），最后还剩一类空进程（Empty Process）。Empty Process初看有些费解，一个Process如果什么都不做，还有什么存在的必要。其实Empty Process并不Empty，还存在不少的内存占用。\n    \n    ```\n<!-- more-->\n- 线程调度（Thread Scheduling）\n  \n```\nAndroid将线程分为多个group，其中两类group尤其重要。一类是default group，UI线程属于这一类。另一类是background group，工作线程应该归属到这一类。background group当中所有的线程加起来总共也只能分配到5～10%的time slice，剩下的全部分配给default group，这样设计显然能保证UI线程绘制UI的流畅性。\n\nAndroid开发者需要显式的将工作线程归于background group。\n\nnew Thread(new Runnable() {\n  @Override\n  public void run() {\n    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n  }\n}).start();\n\n虽说Android系统在任务调度上是以线程为基础单位，设置单个thread的优先级也可以改变其所属的control groups，从而影响CPU time slice的分配。但进程的属性变化也会影响到线程的调度，当一个App进入后台的时候，该App所属的整个进程都将进入background group，以确保处于foreground，用户可见的新进程能获取到尽可能多的CPU资源。用adb可以查看不同进程的当前调度策略。\n\n$ adb shell ps -P\n\n当你的App重新被用户切换到前台的时候，进程当中所属的线程又会回归的原来的group。在这些用户频繁切换的过程当中，thread的优先级并不会发生变化，但系统在time slice的分配上却在不停的调整。\n\n移动端App新启线程一般都是为了保证UI的流畅性，增加App用户操作的响应度。但是否需要将任务放入工作线程需要先了解任务的瓶颈在哪，是i/o，gpu还是cpu？UI出现卡顿并不一定是UI线程出现了费时的计算，有可能是其它原因，比如layout层级太深。\n\n```\n- 用什么姿势开线程？\n\n    - new Thread()\n    - AsyncTask\n    - HandlerThread\n    - ThreadPoolExecutor\n    - IntentService\n```\n这是Android系统里开线程最简单的方式，也只能应用于最简单的场景，简单的好处却伴随不少的隐患。\n\nnew Thread(new Runnable() {\n            @Override\n            public void run() {\n \n            }\n        }).start();\n\n这种方式仅仅是起动了一个新的线程，没有任务的概念，不能做状态的管理。start之后，run当中的代码就一定会执行到底，无法中途取消。\n\nRunnable作为匿名内部类还持有了外部类的引用，在线程退出之前，该引用会一直存在，阻碍外部类对象被GC回收，在一段时间内造成内存泄漏。\n\n没有线程切换的接口，要传递处理结果到UI线程的话，需要写额外的线程切换代码。\n\n如果从UI线程启动，则该线程优先级默认为Default，归于default cgroup，会平等的和UI线程争夺CPU资源。这一点尤其需要注意，在对UI性能要求高的场景下要记得\n\nProcess.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n\n虽说处于background group的线程总共只能争取到5～10%的CPU资源，但这对绝大部分的后台任务处理都绰绰有余了，1ms和10ms对用户来说，都是快到无法感知，所以我们一般都偏向于在background group当中执行工作线程任务。\n\n```\n  \n  \n```\n一个典型的AsyncTask实现如下：\n\npublic class MyAsyncTask extends AsyncTask {\n \n        @Override\n        protected Object doInBackground(Object[] params) {\n            return null;\n        }\n \n        @Override\n        protected void onPreExecute() {\n            super.onPreExecute();\n        }\n \n        @Override\n        protected void onPostExecute(Object o) {\n            super.onPostExecute(o);\n        }\n    }\n\n和使用Thread()不同的是，多了几处API回调来严格规范工作线程与UI线程之间的交互。我们大部分的业务场景几乎都符合这种规范，比如去磁盘读取图片，缩放处理需要在工作线程执行，最后绘制到ImageView控件需要切换到UI线程。\n\nAsyncTask的几处回调都给了我们机会去中断任务，在任务状态的管理上较之Thread()方式更为灵活。值得注意的是AsyncTask的cancel()方法并不会终止任务的执行，开发者需要自己去检查cancel的状态值来决定是否中止任务。\n\nAsyncTask也有隐式的持有外部类对象引用的问题，需要特别注意防止出现意外的内存泄漏。\n\nAsyncTask由于在不同的系统版本上串行与并行的执行行为不一致，被不少开发者所诟病，这确实是硬伤，绝大部分的多线程场景都需要明确任务是串行还是并行。\n\n线程优先级为background，对UI线程的执行影响极小。\n\n```\n\n```\n\n在需要对多任务做更精细控制，线程切换更频繁的场景之下，Thread()和AsyncTask都会显得力不从心。HandlerThread却能胜任这些需求甚至更多。\n\nHandlerThread将Handler，Thread，Looper，MessageQueue几个概念相结合。Handler是线程对外的接口，所有新的message或者runnable都通过handler post到工作线程。Looper在MessageQueue取到新的任务就切换到工作线程去执行。不同的post方法可以让我们对任务做精细的控制，什么时候执行，执行的顺序都可以控制。HandlerThread最大的优势在于引入MessageQueue概念，可以进行多任务队列管理。\n\nHandlerThread背后只有一个线程，所以任务是串行执行的。串行相对于并行来说更安全，各任务之间不会存在多线程安全问题。\n\nHandlerThread所产生的线程会一直存活，Looper会在该线程中持续的检查MessageQueue。这一点和Thread()，AsyncTask都不同，thread实例的重用可以避免线程相关的对象的频繁重建和销毁。\n\nHandlerThread较之Thread()，AsyncTask需要写更多的代码，但在实用性，灵活度，安全性上都有更好的表现。\n\n```\n\n```\nThread(),AsyncTask适合处理单个任务的场景，HandlerThread适合串行处理多任务的场景。当需要并行的处理多任务之时，ThreadPoolExecutor是更好的选择。\n\npublic static Executor THREAD_POOL_EXECUTOR\n= new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,\nTimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);\n\n线程池可以避免线程的频繁创建和销毁，显然性能更好，但线程池并发的特性往往也是疑难杂症的源头，是代码降级和失控的开始。多线程并行导致的bug往往是偶现的，不方便调试，一旦出现就会耗掉大量的开发精力。\n\nThreadPool较之HandlerThread在处理多任务上有更高的灵活性，但也带来了更大的复杂度和不确定性。\n\n```\n\n```\nIntentService又是另一种开工作线程的方式，从名字就可以看出这个工作线程会带有service的属性。和AsyncTask不同，没有和UI线程的交互，也不像HandlerThread的工作线程会一直存活。IntentService背后其实也有一个HandlerThread来串行的处理Message Queue，从IntentService的onCreate方法可以看出：\n\n@Override\n    public void onCreate() {\n        // TODO: It would be nice to have an option to hold a partial wakelock\n        // during processing, and to have a static startService(Context, Intent)\n        // method that would launch the service & hand off a wakelock.\n \n        super.onCreate();\n        HandlerThread thread = new HandlerThread(\"IntentService[\" + mName + \"]\");\n        thread.start();\n \n        mServiceLooper = thread.getLooper();\n        mServiceHandler = new ServiceHandler(mServiceLooper);\n    }\n\n只不过在所有的Message处理完毕之后，工作线程会自动结束。所以可以把IntentService看做是Service和HandlerThread的结合体，适合需要在工作线程处理UI无关任务的场景。\n\n```\n\n","slug":"Android线程","published":1,"updated":"2016-11-27T07:32:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjecoc8h90000fuv1i474ntb9","content":"<ul>\n<li><p>进程优先级（Process Priority）</p>\n<ul>\n<li><p>Foreground Process</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Foreground一般意味着用户双眼可见，可见却不一定是active。    在Android的世界里，一个Activity处于前台之时，如果能采集用    户的input事件，就可以判定为active，如果中途弹出一个Dialog    ，Dialog变成新的active实体，直接面对用户的操作。被部分遮    挡的activity尽管依然可见，但状态却变为inactive。</div></pre></td></tr></table></figure>\n</li>\n<li><p>Background Process</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">所谓的Background可以理解为不可见（invisible）。对于不可见的任务，Android也有重要性的区分。重要的后台任务定义为Service，如果一个进程包含Service（称为Service Process），那么在“重要性”上就会被系统区别对待，其优先级自然会高于不包含Service的进程（称为Background Process），最后还剩一类空进程（Empty Process）。Empty Process初看有些费解，一个Process如果什么都不做，还有什么存在的必要。其实Empty Process并不Empty，还存在不少的内存占用。</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<a id=\"more\"></a>\n<ul>\n<li>线程调度（Thread Scheduling）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">Android将线程分为多个group，其中两类group尤其重要。一类是default group，UI线程属于这一类。另一类是background group，工作线程应该归属到这一类。background group当中所有的线程加起来总共也只能分配到5～10%的time slice，剩下的全部分配给default group，这样设计显然能保证UI线程绘制UI的流畅性。</div><div class=\"line\"></div><div class=\"line\">Android开发者需要显式的将工作线程归于background group。</div><div class=\"line\"></div><div class=\"line\">new Thread(new Runnable() &#123;</div><div class=\"line\">  @Override</div><div class=\"line\">  public void run() &#123;</div><div class=\"line\">    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;).start();</div><div class=\"line\"></div><div class=\"line\">虽说Android系统在任务调度上是以线程为基础单位，设置单个thread的优先级也可以改变其所属的control groups，从而影响CPU time slice的分配。但进程的属性变化也会影响到线程的调度，当一个App进入后台的时候，该App所属的整个进程都将进入background group，以确保处于foreground，用户可见的新进程能获取到尽可能多的CPU资源。用adb可以查看不同进程的当前调度策略。</div><div class=\"line\"></div><div class=\"line\">$ adb shell ps -P</div><div class=\"line\"></div><div class=\"line\">当你的App重新被用户切换到前台的时候，进程当中所属的线程又会回归的原来的group。在这些用户频繁切换的过程当中，thread的优先级并不会发生变化，但系统在time slice的分配上却在不停的调整。</div><div class=\"line\"></div><div class=\"line\">移动端App新启线程一般都是为了保证UI的流畅性，增加App用户操作的响应度。但是否需要将任务放入工作线程需要先了解任务的瓶颈在哪，是i/o，gpu还是cpu？UI出现卡顿并不一定是UI线程出现了费时的计算，有可能是其它原因，比如layout层级太深。</div></pre></td></tr></table></figure>\n<ul>\n<li><p>用什么姿势开线程？</p>\n<ul>\n<li>new Thread()</li>\n<li>AsyncTask</li>\n<li>HandlerThread</li>\n<li>ThreadPoolExecutor</li>\n<li>IntentService<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">这是Android系统里开线程最简单的方式，也只能应用于最简单的场景，简单的好处却伴随不少的隐患。</div><div class=\"line\"></div><div class=\"line\">new Thread(new Runnable() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public void run() &#123;</div><div class=\"line\"> </div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;).start();</div><div class=\"line\"></div><div class=\"line\">这种方式仅仅是起动了一个新的线程，没有任务的概念，不能做状态的管理。start之后，run当中的代码就一定会执行到底，无法中途取消。</div><div class=\"line\"></div><div class=\"line\">Runnable作为匿名内部类还持有了外部类的引用，在线程退出之前，该引用会一直存在，阻碍外部类对象被GC回收，在一段时间内造成内存泄漏。</div><div class=\"line\"></div><div class=\"line\">没有线程切换的接口，要传递处理结果到UI线程的话，需要写额外的线程切换代码。</div><div class=\"line\"></div><div class=\"line\">如果从UI线程启动，则该线程优先级默认为Default，归于default cgroup，会平等的和UI线程争夺CPU资源。这一点尤其需要注意，在对UI性能要求高的场景下要记得</div><div class=\"line\"></div><div class=\"line\">Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class=\"line\"></div><div class=\"line\">虽说处于background group的线程总共只能争取到5～10%的CPU资源，但这对绝大部分的后台任务处理都绰绰有余了，1ms和10ms对用户来说，都是快到无法感知，所以我们一般都偏向于在background group当中执行工作线程任务。</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">一个典型的AsyncTask实现如下：</div><div class=\"line\"></div><div class=\"line\">public class MyAsyncTask extends AsyncTask &#123;</div><div class=\"line\"> </div><div class=\"line\">        @Override</div><div class=\"line\">        protected Object doInBackground(Object[] params) &#123;</div><div class=\"line\">            return null;</div><div class=\"line\">        &#125;</div><div class=\"line\"> </div><div class=\"line\">        @Override</div><div class=\"line\">        protected void onPreExecute() &#123;</div><div class=\"line\">            super.onPreExecute();</div><div class=\"line\">        &#125;</div><div class=\"line\"> </div><div class=\"line\">        @Override</div><div class=\"line\">        protected void onPostExecute(Object o) &#123;</div><div class=\"line\">            super.onPostExecute(o);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">和使用Thread()不同的是，多了几处API回调来严格规范工作线程与UI线程之间的交互。我们大部分的业务场景几乎都符合这种规范，比如去磁盘读取图片，缩放处理需要在工作线程执行，最后绘制到ImageView控件需要切换到UI线程。</div><div class=\"line\"></div><div class=\"line\">AsyncTask的几处回调都给了我们机会去中断任务，在任务状态的管理上较之Thread()方式更为灵活。值得注意的是AsyncTask的cancel()方法并不会终止任务的执行，开发者需要自己去检查cancel的状态值来决定是否中止任务。</div><div class=\"line\"></div><div class=\"line\">AsyncTask也有隐式的持有外部类对象引用的问题，需要特别注意防止出现意外的内存泄漏。</div><div class=\"line\"></div><div class=\"line\">AsyncTask由于在不同的系统版本上串行与并行的执行行为不一致，被不少开发者所诟病，这确实是硬伤，绝大部分的多线程场景都需要明确任务是串行还是并行。</div><div class=\"line\"></div><div class=\"line\">线程优先级为background，对UI线程的执行影响极小。</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">在需要对多任务做更精细控制，线程切换更频繁的场景之下，Thread()和AsyncTask都会显得力不从心。HandlerThread却能胜任这些需求甚至更多。</div><div class=\"line\"></div><div class=\"line\">HandlerThread将Handler，Thread，Looper，MessageQueue几个概念相结合。Handler是线程对外的接口，所有新的message或者runnable都通过handler post到工作线程。Looper在MessageQueue取到新的任务就切换到工作线程去执行。不同的post方法可以让我们对任务做精细的控制，什么时候执行，执行的顺序都可以控制。HandlerThread最大的优势在于引入MessageQueue概念，可以进行多任务队列管理。</div><div class=\"line\"></div><div class=\"line\">HandlerThread背后只有一个线程，所以任务是串行执行的。串行相对于并行来说更安全，各任务之间不会存在多线程安全问题。</div><div class=\"line\"></div><div class=\"line\">HandlerThread所产生的线程会一直存活，Looper会在该线程中持续的检查MessageQueue。这一点和Thread()，AsyncTask都不同，thread实例的重用可以避免线程相关的对象的频繁重建和销毁。</div><div class=\"line\"></div><div class=\"line\">HandlerThread较之Thread()，AsyncTask需要写更多的代码，但在实用性，灵活度，安全性上都有更好的表现。</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">Thread(),AsyncTask适合处理单个任务的场景，HandlerThread适合串行处理多任务的场景。当需要并行的处理多任务之时，ThreadPoolExecutor是更好的选择。</div><div class=\"line\"></div><div class=\"line\">public static Executor THREAD_POOL_EXECUTOR</div><div class=\"line\">= new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,</div><div class=\"line\">TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);</div><div class=\"line\"></div><div class=\"line\">线程池可以避免线程的频繁创建和销毁，显然性能更好，但线程池并发的特性往往也是疑难杂症的源头，是代码降级和失控的开始。多线程并行导致的bug往往是偶现的，不方便调试，一旦出现就会耗掉大量的开发精力。</div><div class=\"line\"></div><div class=\"line\">ThreadPool较之HandlerThread在处理多任务上有更高的灵活性，但也带来了更大的复杂度和不确定性。</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">IntentService又是另一种开工作线程的方式，从名字就可以看出这个工作线程会带有service的属性。和AsyncTask不同，没有和UI线程的交互，也不像HandlerThread的工作线程会一直存活。IntentService背后其实也有一个HandlerThread来串行的处理Message Queue，从IntentService的onCreate方法可以看出：</div><div class=\"line\"></div><div class=\"line\">@Override</div><div class=\"line\">    public void onCreate() &#123;</div><div class=\"line\">        // TODO: It would be nice to have an option to hold a partial wakelock</div><div class=\"line\">        // during processing, and to have a static startService(Context, Intent)</div><div class=\"line\">        // method that would launch the service &amp; hand off a wakelock.</div><div class=\"line\"> </div><div class=\"line\">        super.onCreate();</div><div class=\"line\">        HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;);</div><div class=\"line\">        thread.start();</div><div class=\"line\"> </div><div class=\"line\">        mServiceLooper = thread.getLooper();</div><div class=\"line\">        mServiceHandler = new ServiceHandler(mServiceLooper);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">只不过在所有的Message处理完毕之后，工作线程会自动结束。所以可以把IntentService看做是Service和HandlerThread的结合体，适合需要在工作线程处理UI无关任务的场景。</div></pre></td></tr></table></figure>\n","excerpt":"<ul>\n<li><p>进程优先级（Process Priority）</p>\n<ul>\n<li><p>Foreground Process</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Foreground一般意味着用户双眼可见，可见却不一定是active。    在Android的世界里，一个Activity处于前台之时，如果能采集用    户的input事件，就可以判定为active，如果中途弹出一个Dialog    ，Dialog变成新的active实体，直接面对用户的操作。被部分遮    挡的activity尽管依然可见，但状态却变为inactive。</div></pre></td></tr></table></figure>\n</li>\n<li><p>Background Process</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">所谓的Background可以理解为不可见（invisible）。对于不可见的任务，Android也有重要性的区分。重要的后台任务定义为Service，如果一个进程包含Service（称为Service Process），那么在“重要性”上就会被系统区别对待，其优先级自然会高于不包含Service的进程（称为Background Process），最后还剩一类空进程（Empty Process）。Empty Process初看有些费解，一个Process如果什么都不做，还有什么存在的必要。其实Empty Process并不Empty，还存在不少的内存占用。</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>","more":"<ul>\n<li>线程调度（Thread Scheduling）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">Android将线程分为多个group，其中两类group尤其重要。一类是default group，UI线程属于这一类。另一类是background group，工作线程应该归属到这一类。background group当中所有的线程加起来总共也只能分配到5～10%的time slice，剩下的全部分配给default group，这样设计显然能保证UI线程绘制UI的流畅性。</div><div class=\"line\"></div><div class=\"line\">Android开发者需要显式的将工作线程归于background group。</div><div class=\"line\"></div><div class=\"line\">new Thread(new Runnable() &#123;</div><div class=\"line\">  @Override</div><div class=\"line\">  public void run() &#123;</div><div class=\"line\">    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;).start();</div><div class=\"line\"></div><div class=\"line\">虽说Android系统在任务调度上是以线程为基础单位，设置单个thread的优先级也可以改变其所属的control groups，从而影响CPU time slice的分配。但进程的属性变化也会影响到线程的调度，当一个App进入后台的时候，该App所属的整个进程都将进入background group，以确保处于foreground，用户可见的新进程能获取到尽可能多的CPU资源。用adb可以查看不同进程的当前调度策略。</div><div class=\"line\"></div><div class=\"line\">$ adb shell ps -P</div><div class=\"line\"></div><div class=\"line\">当你的App重新被用户切换到前台的时候，进程当中所属的线程又会回归的原来的group。在这些用户频繁切换的过程当中，thread的优先级并不会发生变化，但系统在time slice的分配上却在不停的调整。</div><div class=\"line\"></div><div class=\"line\">移动端App新启线程一般都是为了保证UI的流畅性，增加App用户操作的响应度。但是否需要将任务放入工作线程需要先了解任务的瓶颈在哪，是i/o，gpu还是cpu？UI出现卡顿并不一定是UI线程出现了费时的计算，有可能是其它原因，比如layout层级太深。</div></pre></td></tr></table></figure>\n<ul>\n<li><p>用什么姿势开线程？</p>\n<ul>\n<li>new Thread()</li>\n<li>AsyncTask</li>\n<li>HandlerThread</li>\n<li>ThreadPoolExecutor</li>\n<li>IntentService<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">这是Android系统里开线程最简单的方式，也只能应用于最简单的场景，简单的好处却伴随不少的隐患。</div><div class=\"line\"></div><div class=\"line\">new Thread(new Runnable() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public void run() &#123;</div><div class=\"line\"> </div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;).start();</div><div class=\"line\"></div><div class=\"line\">这种方式仅仅是起动了一个新的线程，没有任务的概念，不能做状态的管理。start之后，run当中的代码就一定会执行到底，无法中途取消。</div><div class=\"line\"></div><div class=\"line\">Runnable作为匿名内部类还持有了外部类的引用，在线程退出之前，该引用会一直存在，阻碍外部类对象被GC回收，在一段时间内造成内存泄漏。</div><div class=\"line\"></div><div class=\"line\">没有线程切换的接口，要传递处理结果到UI线程的话，需要写额外的线程切换代码。</div><div class=\"line\"></div><div class=\"line\">如果从UI线程启动，则该线程优先级默认为Default，归于default cgroup，会平等的和UI线程争夺CPU资源。这一点尤其需要注意，在对UI性能要求高的场景下要记得</div><div class=\"line\"></div><div class=\"line\">Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class=\"line\"></div><div class=\"line\">虽说处于background group的线程总共只能争取到5～10%的CPU资源，但这对绝大部分的后台任务处理都绰绰有余了，1ms和10ms对用户来说，都是快到无法感知，所以我们一般都偏向于在background group当中执行工作线程任务。</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">一个典型的AsyncTask实现如下：</div><div class=\"line\"></div><div class=\"line\">public class MyAsyncTask extends AsyncTask &#123;</div><div class=\"line\"> </div><div class=\"line\">        @Override</div><div class=\"line\">        protected Object doInBackground(Object[] params) &#123;</div><div class=\"line\">            return null;</div><div class=\"line\">        &#125;</div><div class=\"line\"> </div><div class=\"line\">        @Override</div><div class=\"line\">        protected void onPreExecute() &#123;</div><div class=\"line\">            super.onPreExecute();</div><div class=\"line\">        &#125;</div><div class=\"line\"> </div><div class=\"line\">        @Override</div><div class=\"line\">        protected void onPostExecute(Object o) &#123;</div><div class=\"line\">            super.onPostExecute(o);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">和使用Thread()不同的是，多了几处API回调来严格规范工作线程与UI线程之间的交互。我们大部分的业务场景几乎都符合这种规范，比如去磁盘读取图片，缩放处理需要在工作线程执行，最后绘制到ImageView控件需要切换到UI线程。</div><div class=\"line\"></div><div class=\"line\">AsyncTask的几处回调都给了我们机会去中断任务，在任务状态的管理上较之Thread()方式更为灵活。值得注意的是AsyncTask的cancel()方法并不会终止任务的执行，开发者需要自己去检查cancel的状态值来决定是否中止任务。</div><div class=\"line\"></div><div class=\"line\">AsyncTask也有隐式的持有外部类对象引用的问题，需要特别注意防止出现意外的内存泄漏。</div><div class=\"line\"></div><div class=\"line\">AsyncTask由于在不同的系统版本上串行与并行的执行行为不一致，被不少开发者所诟病，这确实是硬伤，绝大部分的多线程场景都需要明确任务是串行还是并行。</div><div class=\"line\"></div><div class=\"line\">线程优先级为background，对UI线程的执行影响极小。</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">在需要对多任务做更精细控制，线程切换更频繁的场景之下，Thread()和AsyncTask都会显得力不从心。HandlerThread却能胜任这些需求甚至更多。</div><div class=\"line\"></div><div class=\"line\">HandlerThread将Handler，Thread，Looper，MessageQueue几个概念相结合。Handler是线程对外的接口，所有新的message或者runnable都通过handler post到工作线程。Looper在MessageQueue取到新的任务就切换到工作线程去执行。不同的post方法可以让我们对任务做精细的控制，什么时候执行，执行的顺序都可以控制。HandlerThread最大的优势在于引入MessageQueue概念，可以进行多任务队列管理。</div><div class=\"line\"></div><div class=\"line\">HandlerThread背后只有一个线程，所以任务是串行执行的。串行相对于并行来说更安全，各任务之间不会存在多线程安全问题。</div><div class=\"line\"></div><div class=\"line\">HandlerThread所产生的线程会一直存活，Looper会在该线程中持续的检查MessageQueue。这一点和Thread()，AsyncTask都不同，thread实例的重用可以避免线程相关的对象的频繁重建和销毁。</div><div class=\"line\"></div><div class=\"line\">HandlerThread较之Thread()，AsyncTask需要写更多的代码，但在实用性，灵活度，安全性上都有更好的表现。</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">Thread(),AsyncTask适合处理单个任务的场景，HandlerThread适合串行处理多任务的场景。当需要并行的处理多任务之时，ThreadPoolExecutor是更好的选择。</div><div class=\"line\"></div><div class=\"line\">public static Executor THREAD_POOL_EXECUTOR</div><div class=\"line\">= new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,</div><div class=\"line\">TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);</div><div class=\"line\"></div><div class=\"line\">线程池可以避免线程的频繁创建和销毁，显然性能更好，但线程池并发的特性往往也是疑难杂症的源头，是代码降级和失控的开始。多线程并行导致的bug往往是偶现的，不方便调试，一旦出现就会耗掉大量的开发精力。</div><div class=\"line\"></div><div class=\"line\">ThreadPool较之HandlerThread在处理多任务上有更高的灵活性，但也带来了更大的复杂度和不确定性。</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">IntentService又是另一种开工作线程的方式，从名字就可以看出这个工作线程会带有service的属性。和AsyncTask不同，没有和UI线程的交互，也不像HandlerThread的工作线程会一直存活。IntentService背后其实也有一个HandlerThread来串行的处理Message Queue，从IntentService的onCreate方法可以看出：</div><div class=\"line\"></div><div class=\"line\">@Override</div><div class=\"line\">    public void onCreate() &#123;</div><div class=\"line\">        // TODO: It would be nice to have an option to hold a partial wakelock</div><div class=\"line\">        // during processing, and to have a static startService(Context, Intent)</div><div class=\"line\">        // method that would launch the service &amp; hand off a wakelock.</div><div class=\"line\"> </div><div class=\"line\">        super.onCreate();</div><div class=\"line\">        HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;);</div><div class=\"line\">        thread.start();</div><div class=\"line\"> </div><div class=\"line\">        mServiceLooper = thread.getLooper();</div><div class=\"line\">        mServiceHandler = new ServiceHandler(mServiceLooper);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">只不过在所有的Message处理完毕之后，工作线程会自动结束。所以可以把IntentService看做是Service和HandlerThread的结合体，适合需要在工作线程处理UI无关任务的场景。</div></pre></td></tr></table></figure>"},{"title":"Android View的绘制","date":"2016-05-30T12:20:47.000Z","toc":true,"_content":"- .View的绘制流程分几步，从哪开始？哪个过程结束以后能看到view？\n\n ```\n 从ViewRoot的performTraversals开始，经过measure，layout,draw 三个流程。draw流程结束以后就可以在屏幕上看到view了。\n \n ```\n \n - view的测量宽高和实际宽高有区别吗？\n \n ```\n 基本上百分之99的情况下都是可以认为没有区别的。有两种情况，有区别。第一种 就是有的时候会因为某些原因 view会多次测量，那第一次测量的宽高 肯定和最后实际的宽高 是不一定相等的，但是在这种情况下最后一次测量的宽高和实际宽高是一致的。此外，实际宽高是在layout流程里确定的，我们可以在layout流程里 将实际宽高写死 写成硬编码，这样测量的宽高和实际宽高就肯定不一样了，虽然这么做没有意义 而且也不好。\n \n ```\n<!-- more-->\n - view的measureSpec 由谁决定?顶级view呢？\n \n```\n由view自己的layoutparams和父容器  一起决定自己的measureSpec。一旦确定了spec，onMeasure中就可以确定view的宽高了。\n\n顶级view就稍微特殊一点，对于decorView的测量在ViewRootImpl的源码里。\n\n/desire的这2个参数就代表屏幕的宽高，\n  childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);\n  childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);\n  performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);\n\n  //decorView的measureSpec就是在这里确定的，其实比普通view的measurespec要简单的多\n  //代码就不分析了 一目了然的东西\n  private static int getRootMeasureSpec(int windowSize, int rootDimension) {\n        int measureSpec;\n        switch (rootDimension) {\n\n        case ViewGroup.LayoutParams.MATCH_PARENT:\n            // Window can't resize. Force root view to be windowSize.\n            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);\n            break;\n        case ViewGroup.LayoutParams.WRAP_CONTENT:\n            // Window can resize. Set max size for root view.\n            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);\n            break;\n        default:\n            // Window wants to be an exact size. Force root view to be that size.\n            measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);\n            break;\n        }\n        return measureSpec;\n}\n\n```\n\n- 对于普通view来说，他的measure过程中，与父view有关吗？如果有关，这个父view也就是viewgroup扮演了什么角色？\n\n```\n//对于普通view的measure来说 是由这个view的 父view ，也就是viewgroup来触发的。\n//也就是下面这个measureChildWithMargins方法\n\nprotected void measureChildWithMargins(View child,\n            int parentWidthMeasureSpec, int widthUsed,\n            int parentHeightMeasureSpec, int heightUsed) {\n         //第一步 先取得子view的 layoutParams 参数值   \n        final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();\n\n        //然后开始计算子view的spec的值，注意这里看到 计算的时候除了要用子view的 layoutparams参数以外\n        //还用到了父view 也就是viewgroup自己的spec的值\n        final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,\n                mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin\n                        + widthUsed, lp.width);\n        final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,\n                mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin\n                        + heightUsed, lp.height);\n\n        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);\n}\n\n//这个算view的spec的方法 看上去一大串 但是真的逻辑非常简单 就是根据父亲viewgroup\n//的meaurespec 同时还有view自己的params来确定 view自己的measureSpec。\n//注意这里的参数是padding,这个值的含义是 父容器已占用的控件的大小 所以view的Specsize\n//的值 你们可以看到 是要减去这个padding的值的。总大小-已经用的 =可用的。 很好理解。\n\n//然后就是下面的switch逻辑 要自己梳理清楚。其实也不难，主要是下面几条原则\n//如果view采用固定宽高，也就是写死的数值那种。那就不管父亲的spec的值了，view的spec 就肯定是exactly 并且大小遵循layout参数里设置的大小。\n\n//如果view的宽高是match_parent ，那么就要看父容器viewgroup的 spec的值了，如果父view的spec是exactly模式，\n//那view也肯定是exactly,并且大小就是父容器剩下的空间。如果父容器是at_most模式，那view也是at_most 并且不会超过剩余空间大小\n\n//如果view的宽高是wrap_content, 那就不管父容器的spec了，view的spec一定是at_most 并且不会超过父view 剩余空间的大小。\n\npublic static int getChildMeasureSpec(int spec, int padding, int childDimension) {\n        int specMode = MeasureSpec.getMode(spec);\n        int specSize = MeasureSpec.getSize(spec);\n\n        int size = Math.max(0, specSize - padding);\n\n        int resultSize = 0;\n        int resultMode = 0;\n\n        switch (specMode) {\n        // Parent has imposed an exact size on us\n        case MeasureSpec.EXACTLY:\n            if (childDimension >= 0) {\n                resultSize = childDimension;\n                resultMode = MeasureSpec.EXACTLY;\n            } else if (childDimension == LayoutParams.MATCH_PARENT) {\n                // Child wants to be our size. So be it.\n                resultSize = size;\n                resultMode = MeasureSpec.EXACTLY;\n            } else if (childDimension == LayoutParams.WRAP_CONTENT) {\n                // Child wants to determine its own size. It can't be\n                // bigger than us.\n                resultSize = size;\n                resultMode = MeasureSpec.AT_MOST;\n            }\n            break;\n\n        // Parent has imposed a maximum size on us\n        case MeasureSpec.AT_MOST:\n            if (childDimension >= 0) {\n                // Child wants a specific size... so be it\n                resultSize = childDimension;\n                resultMode = MeasureSpec.EXACTLY;\n            } else if (childDimension == LayoutParams.MATCH_PARENT) {\n                // Child wants to be our size, but our size is not fixed.\n                // Constrain child to not be bigger than us.\n                resultSize = size;\n                resultMode = MeasureSpec.AT_MOST;\n            } else if (childDimension == LayoutParams.WRAP_CONTENT) {\n                // Child wants to determine its own size. It can't be\n                // bigger than us.\n                resultSize = size;\n                resultMode = MeasureSpec.AT_MOST;\n            }\n            break;\n\n        // Parent asked to see how big we want to be\n        case MeasureSpec.UNSPECIFIED:\n            if (childDimension >= 0) {\n                // Child wants a specific size... let him have it\n                resultSize = childDimension;\n                resultMode = MeasureSpec.EXACTLY;\n            } else if (childDimension == LayoutParams.MATCH_PARENT) {\n                // Child wants to be our size... find out how big it should\n                // be\n                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;\n                resultMode = MeasureSpec.UNSPECIFIED;\n            } else if (childDimension == LayoutParams.WRAP_CONTENT) {\n                // Child wants to determine its own size.... find out how\n                // big it should be\n                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;\n                resultMode = MeasureSpec.UNSPECIFIED;\n            }\n            break;\n        }\n        return MeasureSpec.makeMeasureSpec(resultSize, resultMode);\n    }\n    \n```\n\n- .view的meaure和onMeasure有什么关系？\n\n```\n//view的measure是final 方法 我们子类无法修改的。\n public final void measure(int widthMeasureSpec, int heightMeasureSpec) {\n        boolean optical = isLayoutModeOptical(this);\n        if (optical != isLayoutModeOptical(mParent)) {\n            Insets insets = getOpticalInsets();\n            int oWidth  = insets.left + insets.right;\n            int oHeight = insets.top  + insets.bottom;\n            widthMeasureSpec  = MeasureSpec.adjust(widthMeasureSpec,  optical ? -oWidth  : oWidth);\n            heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight);\n        }\n\n        // Suppress sign extension for the low bytes\n        long key = (long) widthMeasureSpec << 32 | (long) heightMeasureSpec & 0xffffffffL;\n        if (mMeasureCache == null) mMeasureCache = new LongSparseLongArray(2);\n\n        if ((mPrivateFlags & PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ||\n                widthMeasureSpec != mOldWidthMeasureSpec ||\n                heightMeasureSpec != mOldHeightMeasureSpec) {\n\n            // first clears the measured dimension flag\n            mPrivateFlags &= ~PFLAG_MEASURED_DIMENSION_SET;\n\n            resolveRtlPropertiesIfNeeded();\n\n            int cacheIndex = (mPrivateFlags & PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ? -1 :\n                    mMeasureCache.indexOfKey(key);\n            if (cacheIndex < 0 || sIgnoreMeasureCache) {\n                // measure ourselves, this should set the measured dimension flag back\n                onMeasure(widthMeasureSpec, heightMeasureSpec);\n                mPrivateFlags3 &= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;\n            } else {\n                long value = mMeasureCache.valueAt(cacheIndex);\n                // Casting a long to int drops the high 32 bits, no mask needed\n                setMeasuredDimensionRaw((int) (value >> 32), (int) value);\n                mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;\n            }\n\n            // flag not set, setMeasuredDimension() was not invoked, we raise\n            // an exception to warn the developer\n            if ((mPrivateFlags & PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) {\n                throw new IllegalStateException(\"View with id \" + getId() + \": \"\n                        + getClass().getName() + \"#onMeasure() did not set the\"\n                        + \" measured dimension by calling\"\n                        + \" setMeasuredDimension()\");\n            }\n\n            mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;\n        }\n\n        mOldWidthMeasureSpec = widthMeasureSpec;\n        mOldHeightMeasureSpec = heightMeasureSpec;\n\n        mMeasureCache.put(key, ((long) mMeasuredWidth) << 32 |\n                (long) mMeasuredHeight & 0xffffffffL); // suppress sign extension\n    }\n\n//不过可以看到的是在measure方法里调用了onMeasure方法\n//所以就能知道 我们在自定义view的时候一定是重写这个方法！\n protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),\n                getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));\n    }\n \n ```\n - 简要分析view的measure流程？\n \n```\nviewgroup 算出子view的spec以后 会调用子view的measure方法，而子view的measure方法 我们问题5也看过了实际上是调用的onMeasure方法。\n\n所以我们只要分析好onMeasure方法即可，注意onMeasure方法的参数 正是他的父view算出来的那2个spec的值(这里view的measure方法会把这个spec里的specSize值做略微的修改 这个部分 不做分析 因为measure方法修改specSize的部分很简单)。\n\n//可以看出来这个就是setMeasuredDimension方法的调用 这个方法看名字就知道就是确定view的测量宽高的\n//所以我们分析的重点就是看这个getDefaultSize 方法 是怎么确定view的测量宽高的\n protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),\n                getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));\n    }\n\n\n//这个方法特别简单 基本可以认为就是近似的返回spec中的specSize，除非你的specMode是UNSPECIFIED\n//UNSPECIFIED 这个一般都是系统内部测量才用的到，这种时候返回size 也就是getSuggestedMinimumWidth的返回值\n public static int getDefaultSize(int size, int measureSpec) {\n        int result = size;\n        int specMode = MeasureSpec.getMode(measureSpec);\n        int specSize = MeasureSpec.getSize(measureSpec);\n\n        switch (specMode) {\n        case MeasureSpec.UNSPECIFIED:\n            result = size;\n            break;\n        case MeasureSpec.AT_MOST:\n        case MeasureSpec.EXACTLY:\n            result = specSize;\n            break;\n        }\n        return result;\n}\n\n//跟view的背景相关 这里不多做分析了\nprotected int getSuggestedMinimumWidth() {\n        return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());\n    }\n \n ```\n - .自定义view中 如果onMeasure方法 没有对wrap_content 做处理 会发生什么？为什么？怎么解决？\n \n```\n 如果没有对wrap_content做处理 ，那即使你在xml里设置为wrap_content.其效果也和match_parent相同。看问题4的分析。我们可以知道view自己的layout为wrap，那mode就是at_most（不管父亲view是什么specmode）.\n\n这种模式下宽高就是等于specSize(getDefaultSize函数分析可知)，而这里的specSize显然就是parentSize的大小。也就是父容器剩余的大小。那不就和我们直接设置成match_parent是一样的效果了么？\n\n解决方式就是在onMeasure里 针对wrap 来做特殊处理 比如指定一个默认的宽高，当发现是wrap_content 就设置这个默认宽高即可。\n\n```\n- 为什么在activity的生命周期里无法获得测量宽高？有什么方法可以解决这个问题吗？\n\n```\n因为measure的过程和activity的生命周期  没有任何关系。你无法确定在哪个生命周期执行完毕以后 view的measure过程一定走完。可以尝试如下几种方法 获取view的测量宽高。\n\n//重写activity的这个方法\npublic void onWindowFocusChanged(boolean hasFocus) {\n        super.onWindowFocusChanged(hasFocus);\n        if (hasFocus) {\n            int width = tv.getMeasuredWidth();\n            int height = tv.getMeasuredHeight();\n            Log.v(\"burning\", \"width==\" + width);\n            Log.v(\"burning\", \"height==\" + height);\n\n        }\n    }\n\n或者重写这个方法\n\n@Override\n    protected void onStart() {\n        super.onStart();\n        tv.post(new Runnable() {\n            @Override\n            public void run() {\n                int width = tv.getMeasuredWidth();\n                int height = tv.getMeasuredHeight();\n            }\n        });\n    }\n\n再或者：\n\n@Override\n    protected void onStart() {\n        super.onStart();\n        ViewTreeObserver observer = tv.getViewTreeObserver();\n        observer.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {\n            @Override\n            public void onGlobalLayout() {\n                int width = tv.getMeasuredWidth();\n                int height = tv.getMeasuredHeight();\n                tv.getViewTreeObserver().removeOnGlobalLayoutListener(this);\n            }\n        });\n    }\n\n```\n- layout和onLayout方法有什么区别？\n\n```\nlayout是确定本身view的位置 而onLayout是确定所有子元素的位置。layout里面 就是通过serFrame方法设设定本身view的 四个顶点的位置。这4个位置以确定 自己view的位置就固定了。\n\n然后就调用onLayout来确定子元素的位置。view和viewgroup的onlayout方法都没有写。都留给我们自己给子元素布局\n\n```\n\n- draw方法 大概有几个步骤？\n\n``` \n一共是4个步骤， 绘制背景---------绘制自己--------绘制chrildren----绘制装饰。\n\n```\n- setWillNotDraw方法有什么用？\n\n```\n这个方法在view里。\n\n/**\n     * If this view doesn't do any drawing on its own, set this flag to\n     * allow further optimizations. By default, this flag is not set on\n     * View, but could be set on some View subclasses such as ViewGroup.\n     *\n     * Typically, if you override {@link #onDraw(android.graphics.Canvas)}\n     * you should clear this flag.\n     *\n     * @param willNotDraw whether or not this View draw on its own\n     */\n    public void setWillNotDraw(boolean willNotDraw) {\n        setFlags(willNotDraw ? WILL_NOT_DRAW : 0, DRAW_MASK);\n    }\n\n用于设置标志位的 也就是说 如果你的自定义view 不需要draw的话，就可以设置这个方法为true。这样系统知道你这个view 不需要draw 可以优化执行速度。viewgroup 一般都默认设置这个为true，因为viewgroup多数都是只负责布局，不负责draw的。而view 这个标志位 默认一般都是关闭的。\n\n```\n\n- 自定义view 有哪些需要注意的点？\n\n```\n 主要是要处理wrap_content 和padding。否则xml 那边设置这2个属性就根本没用了。还有不要在view中使用handler 因为人家已经提供了post方法。如果是继承自viewGroup,那在onMeasure和onLayout里面 也要考虑padding和layout的影响。也就是说specSize 要算一下 。最后就是如果view的动画或者线程需要停止，可以考虑在onDetachedFromWindow里面来做。\n\n针对上述的几点，给出几个简单的自定义view 供大家理解。\n\n给出一个圆形的view 范例：\n\npackage com.example.administrator.motioneventtest;\n\nimport android.content.Context;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.Paint;\nimport android.util.AttributeSet;\nimport android.view.View;\n\n/**\n * Created by Administrator on 2016/2/4.\n */\npublic class CircleView extends View {\n\n    private int mColor = Color.RED;\n    private Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);\n\n    private void init() {\n        mPaint.setColor(mColor);\n    }\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n        int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);\n        int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);\n        int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);\n        int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec);\n\n        //处理为wrap_content时的情况\n        if (widthSpecMode == MeasureSpec.AT_MOST && heightSpecMode == MeasureSpec.AT_MOST) {\n            setMeasuredDimension(200, 200);\n        } else if (widthSpecMode == MeasureSpec.AT_MOST) {\n            setMeasuredDimension(200, heightSpecSize);\n        } else if (heightSpecMode == MeasureSpec.AT_MOST) {\n            setMeasuredDimension(widthSpecSize, 200);\n        }\n\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        //处理padding的情况\n        final int paddingLeft = getPaddingLeft();\n        final int paddingRight = getPaddingRight();\n        final int paddingTop = getPaddingTop();\n        final int paddingBottom = getPaddingBottom();\n\n\n        int width = getWidth() - paddingLeft - paddingRight;\n        int height = getHeight() - paddingTop - paddingBottom;\n        int radius = Math.min(width, height) / 2;\n        canvas.drawCircle(paddingLeft + width / 2, paddingTop + height / 2, radius, mPaint);\n    }\n\n    public CircleView(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        init();\n    }\n\n    public CircleView(Context context) {\n        super(context);\n        init();\n\n    }\n\n    public CircleView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init();\n    }\n}\n\n```\n```\n\n\t1. Measure 过程决定了 View 的测量宽/高，measure 过程结束后可以通过 getMeasuredWidth 和 getMeasuredHeight 方法获取 View 测量后的宽/高（正常情况下它都等于 View 最后的宽高，但是也有特殊情况）\n\t2. Layout 决定了四个顶点的坐标和实际 View 的宽和高，完成以后可以通过 getTop,getBottom,getLeft,getRight 拿到四个顶点的坐标，通过 getWidth,getHeight得到最终实际的宽高。\n\t3. Draw 决定 View 的显示，只有 draw 执行完毕以后，View 的内容才最终显示到屏幕上。\n\n```\n\n\n","source":"_posts/Android-View的绘制.md","raw":"---\ntitle: Android View的绘制\ndate: 2016-05-30 20:20:47\ntags: View\ncategories: View\ntoc: true \n---\n- .View的绘制流程分几步，从哪开始？哪个过程结束以后能看到view？\n\n ```\n 从ViewRoot的performTraversals开始，经过measure，layout,draw 三个流程。draw流程结束以后就可以在屏幕上看到view了。\n \n ```\n \n - view的测量宽高和实际宽高有区别吗？\n \n ```\n 基本上百分之99的情况下都是可以认为没有区别的。有两种情况，有区别。第一种 就是有的时候会因为某些原因 view会多次测量，那第一次测量的宽高 肯定和最后实际的宽高 是不一定相等的，但是在这种情况下最后一次测量的宽高和实际宽高是一致的。此外，实际宽高是在layout流程里确定的，我们可以在layout流程里 将实际宽高写死 写成硬编码，这样测量的宽高和实际宽高就肯定不一样了，虽然这么做没有意义 而且也不好。\n \n ```\n<!-- more-->\n - view的measureSpec 由谁决定?顶级view呢？\n \n```\n由view自己的layoutparams和父容器  一起决定自己的measureSpec。一旦确定了spec，onMeasure中就可以确定view的宽高了。\n\n顶级view就稍微特殊一点，对于decorView的测量在ViewRootImpl的源码里。\n\n/desire的这2个参数就代表屏幕的宽高，\n  childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);\n  childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);\n  performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);\n\n  //decorView的measureSpec就是在这里确定的，其实比普通view的measurespec要简单的多\n  //代码就不分析了 一目了然的东西\n  private static int getRootMeasureSpec(int windowSize, int rootDimension) {\n        int measureSpec;\n        switch (rootDimension) {\n\n        case ViewGroup.LayoutParams.MATCH_PARENT:\n            // Window can't resize. Force root view to be windowSize.\n            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);\n            break;\n        case ViewGroup.LayoutParams.WRAP_CONTENT:\n            // Window can resize. Set max size for root view.\n            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);\n            break;\n        default:\n            // Window wants to be an exact size. Force root view to be that size.\n            measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);\n            break;\n        }\n        return measureSpec;\n}\n\n```\n\n- 对于普通view来说，他的measure过程中，与父view有关吗？如果有关，这个父view也就是viewgroup扮演了什么角色？\n\n```\n//对于普通view的measure来说 是由这个view的 父view ，也就是viewgroup来触发的。\n//也就是下面这个measureChildWithMargins方法\n\nprotected void measureChildWithMargins(View child,\n            int parentWidthMeasureSpec, int widthUsed,\n            int parentHeightMeasureSpec, int heightUsed) {\n         //第一步 先取得子view的 layoutParams 参数值   \n        final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();\n\n        //然后开始计算子view的spec的值，注意这里看到 计算的时候除了要用子view的 layoutparams参数以外\n        //还用到了父view 也就是viewgroup自己的spec的值\n        final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,\n                mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin\n                        + widthUsed, lp.width);\n        final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,\n                mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin\n                        + heightUsed, lp.height);\n\n        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);\n}\n\n//这个算view的spec的方法 看上去一大串 但是真的逻辑非常简单 就是根据父亲viewgroup\n//的meaurespec 同时还有view自己的params来确定 view自己的measureSpec。\n//注意这里的参数是padding,这个值的含义是 父容器已占用的控件的大小 所以view的Specsize\n//的值 你们可以看到 是要减去这个padding的值的。总大小-已经用的 =可用的。 很好理解。\n\n//然后就是下面的switch逻辑 要自己梳理清楚。其实也不难，主要是下面几条原则\n//如果view采用固定宽高，也就是写死的数值那种。那就不管父亲的spec的值了，view的spec 就肯定是exactly 并且大小遵循layout参数里设置的大小。\n\n//如果view的宽高是match_parent ，那么就要看父容器viewgroup的 spec的值了，如果父view的spec是exactly模式，\n//那view也肯定是exactly,并且大小就是父容器剩下的空间。如果父容器是at_most模式，那view也是at_most 并且不会超过剩余空间大小\n\n//如果view的宽高是wrap_content, 那就不管父容器的spec了，view的spec一定是at_most 并且不会超过父view 剩余空间的大小。\n\npublic static int getChildMeasureSpec(int spec, int padding, int childDimension) {\n        int specMode = MeasureSpec.getMode(spec);\n        int specSize = MeasureSpec.getSize(spec);\n\n        int size = Math.max(0, specSize - padding);\n\n        int resultSize = 0;\n        int resultMode = 0;\n\n        switch (specMode) {\n        // Parent has imposed an exact size on us\n        case MeasureSpec.EXACTLY:\n            if (childDimension >= 0) {\n                resultSize = childDimension;\n                resultMode = MeasureSpec.EXACTLY;\n            } else if (childDimension == LayoutParams.MATCH_PARENT) {\n                // Child wants to be our size. So be it.\n                resultSize = size;\n                resultMode = MeasureSpec.EXACTLY;\n            } else if (childDimension == LayoutParams.WRAP_CONTENT) {\n                // Child wants to determine its own size. It can't be\n                // bigger than us.\n                resultSize = size;\n                resultMode = MeasureSpec.AT_MOST;\n            }\n            break;\n\n        // Parent has imposed a maximum size on us\n        case MeasureSpec.AT_MOST:\n            if (childDimension >= 0) {\n                // Child wants a specific size... so be it\n                resultSize = childDimension;\n                resultMode = MeasureSpec.EXACTLY;\n            } else if (childDimension == LayoutParams.MATCH_PARENT) {\n                // Child wants to be our size, but our size is not fixed.\n                // Constrain child to not be bigger than us.\n                resultSize = size;\n                resultMode = MeasureSpec.AT_MOST;\n            } else if (childDimension == LayoutParams.WRAP_CONTENT) {\n                // Child wants to determine its own size. It can't be\n                // bigger than us.\n                resultSize = size;\n                resultMode = MeasureSpec.AT_MOST;\n            }\n            break;\n\n        // Parent asked to see how big we want to be\n        case MeasureSpec.UNSPECIFIED:\n            if (childDimension >= 0) {\n                // Child wants a specific size... let him have it\n                resultSize = childDimension;\n                resultMode = MeasureSpec.EXACTLY;\n            } else if (childDimension == LayoutParams.MATCH_PARENT) {\n                // Child wants to be our size... find out how big it should\n                // be\n                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;\n                resultMode = MeasureSpec.UNSPECIFIED;\n            } else if (childDimension == LayoutParams.WRAP_CONTENT) {\n                // Child wants to determine its own size.... find out how\n                // big it should be\n                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;\n                resultMode = MeasureSpec.UNSPECIFIED;\n            }\n            break;\n        }\n        return MeasureSpec.makeMeasureSpec(resultSize, resultMode);\n    }\n    \n```\n\n- .view的meaure和onMeasure有什么关系？\n\n```\n//view的measure是final 方法 我们子类无法修改的。\n public final void measure(int widthMeasureSpec, int heightMeasureSpec) {\n        boolean optical = isLayoutModeOptical(this);\n        if (optical != isLayoutModeOptical(mParent)) {\n            Insets insets = getOpticalInsets();\n            int oWidth  = insets.left + insets.right;\n            int oHeight = insets.top  + insets.bottom;\n            widthMeasureSpec  = MeasureSpec.adjust(widthMeasureSpec,  optical ? -oWidth  : oWidth);\n            heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight);\n        }\n\n        // Suppress sign extension for the low bytes\n        long key = (long) widthMeasureSpec << 32 | (long) heightMeasureSpec & 0xffffffffL;\n        if (mMeasureCache == null) mMeasureCache = new LongSparseLongArray(2);\n\n        if ((mPrivateFlags & PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ||\n                widthMeasureSpec != mOldWidthMeasureSpec ||\n                heightMeasureSpec != mOldHeightMeasureSpec) {\n\n            // first clears the measured dimension flag\n            mPrivateFlags &= ~PFLAG_MEASURED_DIMENSION_SET;\n\n            resolveRtlPropertiesIfNeeded();\n\n            int cacheIndex = (mPrivateFlags & PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ? -1 :\n                    mMeasureCache.indexOfKey(key);\n            if (cacheIndex < 0 || sIgnoreMeasureCache) {\n                // measure ourselves, this should set the measured dimension flag back\n                onMeasure(widthMeasureSpec, heightMeasureSpec);\n                mPrivateFlags3 &= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;\n            } else {\n                long value = mMeasureCache.valueAt(cacheIndex);\n                // Casting a long to int drops the high 32 bits, no mask needed\n                setMeasuredDimensionRaw((int) (value >> 32), (int) value);\n                mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;\n            }\n\n            // flag not set, setMeasuredDimension() was not invoked, we raise\n            // an exception to warn the developer\n            if ((mPrivateFlags & PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) {\n                throw new IllegalStateException(\"View with id \" + getId() + \": \"\n                        + getClass().getName() + \"#onMeasure() did not set the\"\n                        + \" measured dimension by calling\"\n                        + \" setMeasuredDimension()\");\n            }\n\n            mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;\n        }\n\n        mOldWidthMeasureSpec = widthMeasureSpec;\n        mOldHeightMeasureSpec = heightMeasureSpec;\n\n        mMeasureCache.put(key, ((long) mMeasuredWidth) << 32 |\n                (long) mMeasuredHeight & 0xffffffffL); // suppress sign extension\n    }\n\n//不过可以看到的是在measure方法里调用了onMeasure方法\n//所以就能知道 我们在自定义view的时候一定是重写这个方法！\n protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),\n                getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));\n    }\n \n ```\n - 简要分析view的measure流程？\n \n```\nviewgroup 算出子view的spec以后 会调用子view的measure方法，而子view的measure方法 我们问题5也看过了实际上是调用的onMeasure方法。\n\n所以我们只要分析好onMeasure方法即可，注意onMeasure方法的参数 正是他的父view算出来的那2个spec的值(这里view的measure方法会把这个spec里的specSize值做略微的修改 这个部分 不做分析 因为measure方法修改specSize的部分很简单)。\n\n//可以看出来这个就是setMeasuredDimension方法的调用 这个方法看名字就知道就是确定view的测量宽高的\n//所以我们分析的重点就是看这个getDefaultSize 方法 是怎么确定view的测量宽高的\n protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),\n                getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));\n    }\n\n\n//这个方法特别简单 基本可以认为就是近似的返回spec中的specSize，除非你的specMode是UNSPECIFIED\n//UNSPECIFIED 这个一般都是系统内部测量才用的到，这种时候返回size 也就是getSuggestedMinimumWidth的返回值\n public static int getDefaultSize(int size, int measureSpec) {\n        int result = size;\n        int specMode = MeasureSpec.getMode(measureSpec);\n        int specSize = MeasureSpec.getSize(measureSpec);\n\n        switch (specMode) {\n        case MeasureSpec.UNSPECIFIED:\n            result = size;\n            break;\n        case MeasureSpec.AT_MOST:\n        case MeasureSpec.EXACTLY:\n            result = specSize;\n            break;\n        }\n        return result;\n}\n\n//跟view的背景相关 这里不多做分析了\nprotected int getSuggestedMinimumWidth() {\n        return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());\n    }\n \n ```\n - .自定义view中 如果onMeasure方法 没有对wrap_content 做处理 会发生什么？为什么？怎么解决？\n \n```\n 如果没有对wrap_content做处理 ，那即使你在xml里设置为wrap_content.其效果也和match_parent相同。看问题4的分析。我们可以知道view自己的layout为wrap，那mode就是at_most（不管父亲view是什么specmode）.\n\n这种模式下宽高就是等于specSize(getDefaultSize函数分析可知)，而这里的specSize显然就是parentSize的大小。也就是父容器剩余的大小。那不就和我们直接设置成match_parent是一样的效果了么？\n\n解决方式就是在onMeasure里 针对wrap 来做特殊处理 比如指定一个默认的宽高，当发现是wrap_content 就设置这个默认宽高即可。\n\n```\n- 为什么在activity的生命周期里无法获得测量宽高？有什么方法可以解决这个问题吗？\n\n```\n因为measure的过程和activity的生命周期  没有任何关系。你无法确定在哪个生命周期执行完毕以后 view的measure过程一定走完。可以尝试如下几种方法 获取view的测量宽高。\n\n//重写activity的这个方法\npublic void onWindowFocusChanged(boolean hasFocus) {\n        super.onWindowFocusChanged(hasFocus);\n        if (hasFocus) {\n            int width = tv.getMeasuredWidth();\n            int height = tv.getMeasuredHeight();\n            Log.v(\"burning\", \"width==\" + width);\n            Log.v(\"burning\", \"height==\" + height);\n\n        }\n    }\n\n或者重写这个方法\n\n@Override\n    protected void onStart() {\n        super.onStart();\n        tv.post(new Runnable() {\n            @Override\n            public void run() {\n                int width = tv.getMeasuredWidth();\n                int height = tv.getMeasuredHeight();\n            }\n        });\n    }\n\n再或者：\n\n@Override\n    protected void onStart() {\n        super.onStart();\n        ViewTreeObserver observer = tv.getViewTreeObserver();\n        observer.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {\n            @Override\n            public void onGlobalLayout() {\n                int width = tv.getMeasuredWidth();\n                int height = tv.getMeasuredHeight();\n                tv.getViewTreeObserver().removeOnGlobalLayoutListener(this);\n            }\n        });\n    }\n\n```\n- layout和onLayout方法有什么区别？\n\n```\nlayout是确定本身view的位置 而onLayout是确定所有子元素的位置。layout里面 就是通过serFrame方法设设定本身view的 四个顶点的位置。这4个位置以确定 自己view的位置就固定了。\n\n然后就调用onLayout来确定子元素的位置。view和viewgroup的onlayout方法都没有写。都留给我们自己给子元素布局\n\n```\n\n- draw方法 大概有几个步骤？\n\n``` \n一共是4个步骤， 绘制背景---------绘制自己--------绘制chrildren----绘制装饰。\n\n```\n- setWillNotDraw方法有什么用？\n\n```\n这个方法在view里。\n\n/**\n     * If this view doesn't do any drawing on its own, set this flag to\n     * allow further optimizations. By default, this flag is not set on\n     * View, but could be set on some View subclasses such as ViewGroup.\n     *\n     * Typically, if you override {@link #onDraw(android.graphics.Canvas)}\n     * you should clear this flag.\n     *\n     * @param willNotDraw whether or not this View draw on its own\n     */\n    public void setWillNotDraw(boolean willNotDraw) {\n        setFlags(willNotDraw ? WILL_NOT_DRAW : 0, DRAW_MASK);\n    }\n\n用于设置标志位的 也就是说 如果你的自定义view 不需要draw的话，就可以设置这个方法为true。这样系统知道你这个view 不需要draw 可以优化执行速度。viewgroup 一般都默认设置这个为true，因为viewgroup多数都是只负责布局，不负责draw的。而view 这个标志位 默认一般都是关闭的。\n\n```\n\n- 自定义view 有哪些需要注意的点？\n\n```\n 主要是要处理wrap_content 和padding。否则xml 那边设置这2个属性就根本没用了。还有不要在view中使用handler 因为人家已经提供了post方法。如果是继承自viewGroup,那在onMeasure和onLayout里面 也要考虑padding和layout的影响。也就是说specSize 要算一下 。最后就是如果view的动画或者线程需要停止，可以考虑在onDetachedFromWindow里面来做。\n\n针对上述的几点，给出几个简单的自定义view 供大家理解。\n\n给出一个圆形的view 范例：\n\npackage com.example.administrator.motioneventtest;\n\nimport android.content.Context;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.Paint;\nimport android.util.AttributeSet;\nimport android.view.View;\n\n/**\n * Created by Administrator on 2016/2/4.\n */\npublic class CircleView extends View {\n\n    private int mColor = Color.RED;\n    private Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);\n\n    private void init() {\n        mPaint.setColor(mColor);\n    }\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n        int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);\n        int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);\n        int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);\n        int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec);\n\n        //处理为wrap_content时的情况\n        if (widthSpecMode == MeasureSpec.AT_MOST && heightSpecMode == MeasureSpec.AT_MOST) {\n            setMeasuredDimension(200, 200);\n        } else if (widthSpecMode == MeasureSpec.AT_MOST) {\n            setMeasuredDimension(200, heightSpecSize);\n        } else if (heightSpecMode == MeasureSpec.AT_MOST) {\n            setMeasuredDimension(widthSpecSize, 200);\n        }\n\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        //处理padding的情况\n        final int paddingLeft = getPaddingLeft();\n        final int paddingRight = getPaddingRight();\n        final int paddingTop = getPaddingTop();\n        final int paddingBottom = getPaddingBottom();\n\n\n        int width = getWidth() - paddingLeft - paddingRight;\n        int height = getHeight() - paddingTop - paddingBottom;\n        int radius = Math.min(width, height) / 2;\n        canvas.drawCircle(paddingLeft + width / 2, paddingTop + height / 2, radius, mPaint);\n    }\n\n    public CircleView(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        init();\n    }\n\n    public CircleView(Context context) {\n        super(context);\n        init();\n\n    }\n\n    public CircleView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init();\n    }\n}\n\n```\n```\n\n\t1. Measure 过程决定了 View 的测量宽/高，measure 过程结束后可以通过 getMeasuredWidth 和 getMeasuredHeight 方法获取 View 测量后的宽/高（正常情况下它都等于 View 最后的宽高，但是也有特殊情况）\n\t2. Layout 决定了四个顶点的坐标和实际 View 的宽和高，完成以后可以通过 getTop,getBottom,getLeft,getRight 拿到四个顶点的坐标，通过 getWidth,getHeight得到最终实际的宽高。\n\t3. Draw 决定 View 的显示，只有 draw 执行完毕以后，View 的内容才最终显示到屏幕上。\n\n```\n\n\n","slug":"Android-View的绘制","published":1,"updated":"2016-11-27T07:32:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjecoc8he0001fuv1b9l9hzj9","content":"<ul>\n<li><p>.View的绘制流程分几步，从哪开始？哪个过程结束以后能看到view？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">从ViewRoot的performTraversals开始，经过measure，layout,draw 三个流程。draw流程结束以后就可以在屏幕上看到view了。</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>view的测量宽高和实际宽高有区别吗？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">基本上百分之99的情况下都是可以认为没有区别的。有两种情况，有区别。第一种 就是有的时候会因为某些原因 view会多次测量，那第一次测量的宽高 肯定和最后实际的宽高 是不一定相等的，但是在这种情况下最后一次测量的宽高和实际宽高是一致的。此外，实际宽高是在layout流程里确定的，我们可以在layout流程里 将实际宽高写死 写成硬编码，这样测量的宽高和实际宽高就肯定不一样了，虽然这么做没有意义 而且也不好。</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<a id=\"more\"></a>\n<ul>\n<li>view的measureSpec 由谁决定?顶级view呢？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">由view自己的layoutparams和父容器  一起决定自己的measureSpec。一旦确定了spec，onMeasure中就可以确定view的宽高了。</div><div class=\"line\"></div><div class=\"line\">顶级view就稍微特殊一点，对于decorView的测量在ViewRootImpl的源码里。</div><div class=\"line\"></div><div class=\"line\">/desire的这2个参数就代表屏幕的宽高，</div><div class=\"line\">  childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);</div><div class=\"line\">  childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);</div><div class=\"line\">  performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class=\"line\"></div><div class=\"line\">  //decorView的measureSpec就是在这里确定的，其实比普通view的measurespec要简单的多</div><div class=\"line\">  //代码就不分析了 一目了然的东西</div><div class=\"line\">  private static int getRootMeasureSpec(int windowSize, int rootDimension) &#123;</div><div class=\"line\">        int measureSpec;</div><div class=\"line\">        switch (rootDimension) &#123;</div><div class=\"line\"></div><div class=\"line\">        case ViewGroup.LayoutParams.MATCH_PARENT:</div><div class=\"line\">            // Window can&apos;t resize. Force root view to be windowSize.</div><div class=\"line\">            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</div><div class=\"line\">            break;</div><div class=\"line\">        case ViewGroup.LayoutParams.WRAP_CONTENT:</div><div class=\"line\">            // Window can resize. Set max size for root view.</div><div class=\"line\">            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);</div><div class=\"line\">            break;</div><div class=\"line\">        default:</div><div class=\"line\">            // Window wants to be an exact size. Force root view to be that size.</div><div class=\"line\">            measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);</div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return measureSpec;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>对于普通view来说，他的measure过程中，与父view有关吗？如果有关，这个父view也就是viewgroup扮演了什么角色？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div></pre></td><td class=\"code\"><pre><div class=\"line\">//对于普通view的measure来说 是由这个view的 父view ，也就是viewgroup来触发的。</div><div class=\"line\">//也就是下面这个measureChildWithMargins方法</div><div class=\"line\"></div><div class=\"line\">protected void measureChildWithMargins(View child,</div><div class=\"line\">            int parentWidthMeasureSpec, int widthUsed,</div><div class=\"line\">            int parentHeightMeasureSpec, int heightUsed) &#123;</div><div class=\"line\">         //第一步 先取得子view的 layoutParams 参数值   </div><div class=\"line\">        final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class=\"line\"></div><div class=\"line\">        //然后开始计算子view的spec的值，注意这里看到 计算的时候除了要用子view的 layoutparams参数以外</div><div class=\"line\">        //还用到了父view 也就是viewgroup自己的spec的值</div><div class=\"line\">        final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class=\"line\">                mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</div><div class=\"line\">                        + widthUsed, lp.width);</div><div class=\"line\">        final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class=\"line\">                mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</div><div class=\"line\">                        + heightUsed, lp.height);</div><div class=\"line\"></div><div class=\"line\">        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//这个算view的spec的方法 看上去一大串 但是真的逻辑非常简单 就是根据父亲viewgroup</div><div class=\"line\">//的meaurespec 同时还有view自己的params来确定 view自己的measureSpec。</div><div class=\"line\">//注意这里的参数是padding,这个值的含义是 父容器已占用的控件的大小 所以view的Specsize</div><div class=\"line\">//的值 你们可以看到 是要减去这个padding的值的。总大小-已经用的 =可用的。 很好理解。</div><div class=\"line\"></div><div class=\"line\">//然后就是下面的switch逻辑 要自己梳理清楚。其实也不难，主要是下面几条原则</div><div class=\"line\">//如果view采用固定宽高，也就是写死的数值那种。那就不管父亲的spec的值了，view的spec 就肯定是exactly 并且大小遵循layout参数里设置的大小。</div><div class=\"line\"></div><div class=\"line\">//如果view的宽高是match_parent ，那么就要看父容器viewgroup的 spec的值了，如果父view的spec是exactly模式，</div><div class=\"line\">//那view也肯定是exactly,并且大小就是父容器剩下的空间。如果父容器是at_most模式，那view也是at_most 并且不会超过剩余空间大小</div><div class=\"line\"></div><div class=\"line\">//如果view的宽高是wrap_content, 那就不管父容器的spec了，view的spec一定是at_most 并且不会超过父view 剩余空间的大小。</div><div class=\"line\"></div><div class=\"line\">public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123;</div><div class=\"line\">        int specMode = MeasureSpec.getMode(spec);</div><div class=\"line\">        int specSize = MeasureSpec.getSize(spec);</div><div class=\"line\"></div><div class=\"line\">        int size = Math.max(0, specSize - padding);</div><div class=\"line\"></div><div class=\"line\">        int resultSize = 0;</div><div class=\"line\">        int resultMode = 0;</div><div class=\"line\"></div><div class=\"line\">        switch (specMode) &#123;</div><div class=\"line\">        // Parent has imposed an exact size on us</div><div class=\"line\">        case MeasureSpec.EXACTLY:</div><div class=\"line\">            if (childDimension &gt;= 0) &#123;</div><div class=\"line\">                resultSize = childDimension;</div><div class=\"line\">                resultMode = MeasureSpec.EXACTLY;</div><div class=\"line\">            &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class=\"line\">                // Child wants to be our size. So be it.</div><div class=\"line\">                resultSize = size;</div><div class=\"line\">                resultMode = MeasureSpec.EXACTLY;</div><div class=\"line\">            &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class=\"line\">                // Child wants to determine its own size. It can&apos;t be</div><div class=\"line\">                // bigger than us.</div><div class=\"line\">                resultSize = size;</div><div class=\"line\">                resultMode = MeasureSpec.AT_MOST;</div><div class=\"line\">            &#125;</div><div class=\"line\">            break;</div><div class=\"line\"></div><div class=\"line\">        // Parent has imposed a maximum size on us</div><div class=\"line\">        case MeasureSpec.AT_MOST:</div><div class=\"line\">            if (childDimension &gt;= 0) &#123;</div><div class=\"line\">                // Child wants a specific size... so be it</div><div class=\"line\">                resultSize = childDimension;</div><div class=\"line\">                resultMode = MeasureSpec.EXACTLY;</div><div class=\"line\">            &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class=\"line\">                // Child wants to be our size, but our size is not fixed.</div><div class=\"line\">                // Constrain child to not be bigger than us.</div><div class=\"line\">                resultSize = size;</div><div class=\"line\">                resultMode = MeasureSpec.AT_MOST;</div><div class=\"line\">            &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class=\"line\">                // Child wants to determine its own size. It can&apos;t be</div><div class=\"line\">                // bigger than us.</div><div class=\"line\">                resultSize = size;</div><div class=\"line\">                resultMode = MeasureSpec.AT_MOST;</div><div class=\"line\">            &#125;</div><div class=\"line\">            break;</div><div class=\"line\"></div><div class=\"line\">        // Parent asked to see how big we want to be</div><div class=\"line\">        case MeasureSpec.UNSPECIFIED:</div><div class=\"line\">            if (childDimension &gt;= 0) &#123;</div><div class=\"line\">                // Child wants a specific size... let him have it</div><div class=\"line\">                resultSize = childDimension;</div><div class=\"line\">                resultMode = MeasureSpec.EXACTLY;</div><div class=\"line\">            &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class=\"line\">                // Child wants to be our size... find out how big it should</div><div class=\"line\">                // be</div><div class=\"line\">                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;</div><div class=\"line\">                resultMode = MeasureSpec.UNSPECIFIED;</div><div class=\"line\">            &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class=\"line\">                // Child wants to determine its own size.... find out how</div><div class=\"line\">                // big it should be</div><div class=\"line\">                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;</div><div class=\"line\">                resultMode = MeasureSpec.UNSPECIFIED;</div><div class=\"line\">            &#125;</div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return MeasureSpec.makeMeasureSpec(resultSize, resultMode);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>.view的meaure和onMeasure有什么关系？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div></pre></td><td class=\"code\"><pre><div class=\"line\">//view的measure是final 方法 我们子类无法修改的。</div><div class=\"line\"> public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class=\"line\">        boolean optical = isLayoutModeOptical(this);</div><div class=\"line\">        if (optical != isLayoutModeOptical(mParent)) &#123;</div><div class=\"line\">            Insets insets = getOpticalInsets();</div><div class=\"line\">            int oWidth  = insets.left + insets.right;</div><div class=\"line\">            int oHeight = insets.top  + insets.bottom;</div><div class=\"line\">            widthMeasureSpec  = MeasureSpec.adjust(widthMeasureSpec,  optical ? -oWidth  : oWidth);</div><div class=\"line\">            heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Suppress sign extension for the low bytes</div><div class=\"line\">        long key = (long) widthMeasureSpec &lt;&lt; 32 | (long) heightMeasureSpec &amp; 0xffffffffL;</div><div class=\"line\">        if (mMeasureCache == null) mMeasureCache = new LongSparseLongArray(2);</div><div class=\"line\"></div><div class=\"line\">        if ((mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ||</div><div class=\"line\">                widthMeasureSpec != mOldWidthMeasureSpec ||</div><div class=\"line\">                heightMeasureSpec != mOldHeightMeasureSpec) &#123;</div><div class=\"line\"></div><div class=\"line\">            // first clears the measured dimension flag</div><div class=\"line\">            mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET;</div><div class=\"line\"></div><div class=\"line\">            resolveRtlPropertiesIfNeeded();</div><div class=\"line\"></div><div class=\"line\">            int cacheIndex = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ? -1 :</div><div class=\"line\">                    mMeasureCache.indexOfKey(key);</div><div class=\"line\">            if (cacheIndex &lt; 0 || sIgnoreMeasureCache) &#123;</div><div class=\"line\">                // measure ourselves, this should set the measured dimension flag back</div><div class=\"line\">                onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class=\"line\">                mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                long value = mMeasureCache.valueAt(cacheIndex);</div><div class=\"line\">                // Casting a long to int drops the high 32 bits, no mask needed</div><div class=\"line\">                setMeasuredDimensionRaw((int) (value &gt;&gt; 32), (int) value);</div><div class=\"line\">                mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // flag not set, setMeasuredDimension() was not invoked, we raise</div><div class=\"line\">            // an exception to warn the developer</div><div class=\"line\">            if ((mPrivateFlags &amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) &#123;</div><div class=\"line\">                throw new IllegalStateException(&quot;View with id &quot; + getId() + &quot;: &quot;</div><div class=\"line\">                        + getClass().getName() + &quot;#onMeasure() did not set the&quot;</div><div class=\"line\">                        + &quot; measured dimension by calling&quot;</div><div class=\"line\">                        + &quot; setMeasuredDimension()&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        mOldWidthMeasureSpec = widthMeasureSpec;</div><div class=\"line\">        mOldHeightMeasureSpec = heightMeasureSpec;</div><div class=\"line\"></div><div class=\"line\">        mMeasureCache.put(key, ((long) mMeasuredWidth) &lt;&lt; 32 |</div><div class=\"line\">                (long) mMeasuredHeight &amp; 0xffffffffL); // suppress sign extension</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">//不过可以看到的是在measure方法里调用了onMeasure方法</div><div class=\"line\">//所以就能知道 我们在自定义view的时候一定是重写这个方法！</div><div class=\"line\"> protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class=\"line\">        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</div><div class=\"line\">                getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>简要分析view的measure流程？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">viewgroup 算出子view的spec以后 会调用子view的measure方法，而子view的measure方法 我们问题5也看过了实际上是调用的onMeasure方法。</div><div class=\"line\"></div><div class=\"line\">所以我们只要分析好onMeasure方法即可，注意onMeasure方法的参数 正是他的父view算出来的那2个spec的值(这里view的measure方法会把这个spec里的specSize值做略微的修改 这个部分 不做分析 因为measure方法修改specSize的部分很简单)。</div><div class=\"line\"></div><div class=\"line\">//可以看出来这个就是setMeasuredDimension方法的调用 这个方法看名字就知道就是确定view的测量宽高的</div><div class=\"line\">//所以我们分析的重点就是看这个getDefaultSize 方法 是怎么确定view的测量宽高的</div><div class=\"line\"> protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class=\"line\">        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</div><div class=\"line\">                getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//这个方法特别简单 基本可以认为就是近似的返回spec中的specSize，除非你的specMode是UNSPECIFIED</div><div class=\"line\">//UNSPECIFIED 这个一般都是系统内部测量才用的到，这种时候返回size 也就是getSuggestedMinimumWidth的返回值</div><div class=\"line\"> public static int getDefaultSize(int size, int measureSpec) &#123;</div><div class=\"line\">        int result = size;</div><div class=\"line\">        int specMode = MeasureSpec.getMode(measureSpec);</div><div class=\"line\">        int specSize = MeasureSpec.getSize(measureSpec);</div><div class=\"line\"></div><div class=\"line\">        switch (specMode) &#123;</div><div class=\"line\">        case MeasureSpec.UNSPECIFIED:</div><div class=\"line\">            result = size;</div><div class=\"line\">            break;</div><div class=\"line\">        case MeasureSpec.AT_MOST:</div><div class=\"line\">        case MeasureSpec.EXACTLY:</div><div class=\"line\">            result = specSize;</div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return result;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//跟view的背景相关 这里不多做分析了</div><div class=\"line\">protected int getSuggestedMinimumWidth() &#123;</div><div class=\"line\">        return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>.自定义view中 如果onMeasure方法 没有对wrap_content 做处理 会发生什么？为什么？怎么解决？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"> 如果没有对wrap_content做处理 ，那即使你在xml里设置为wrap_content.其效果也和match_parent相同。看问题4的分析。我们可以知道view自己的layout为wrap，那mode就是at_most（不管父亲view是什么specmode）.</div><div class=\"line\"></div><div class=\"line\">这种模式下宽高就是等于specSize(getDefaultSize函数分析可知)，而这里的specSize显然就是parentSize的大小。也就是父容器剩余的大小。那不就和我们直接设置成match_parent是一样的效果了么？</div><div class=\"line\"></div><div class=\"line\">解决方式就是在onMeasure里 针对wrap 来做特殊处理 比如指定一个默认的宽高，当发现是wrap_content 就设置这个默认宽高即可。</div></pre></td></tr></table></figure>\n<ul>\n<li>为什么在activity的生命周期里无法获得测量宽高？有什么方法可以解决这个问题吗？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">因为measure的过程和activity的生命周期  没有任何关系。你无法确定在哪个生命周期执行完毕以后 view的measure过程一定走完。可以尝试如下几种方法 获取view的测量宽高。</div><div class=\"line\"></div><div class=\"line\">//重写activity的这个方法</div><div class=\"line\">public void onWindowFocusChanged(boolean hasFocus) &#123;</div><div class=\"line\">        super.onWindowFocusChanged(hasFocus);</div><div class=\"line\">        if (hasFocus) &#123;</div><div class=\"line\">            int width = tv.getMeasuredWidth();</div><div class=\"line\">            int height = tv.getMeasuredHeight();</div><div class=\"line\">            Log.v(&quot;burning&quot;, &quot;width==&quot; + width);</div><div class=\"line\">            Log.v(&quot;burning&quot;, &quot;height==&quot; + height);</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">或者重写这个方法</div><div class=\"line\"></div><div class=\"line\">@Override</div><div class=\"line\">    protected void onStart() &#123;</div><div class=\"line\">        super.onStart();</div><div class=\"line\">        tv.post(new Runnable() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public void run() &#123;</div><div class=\"line\">                int width = tv.getMeasuredWidth();</div><div class=\"line\">                int height = tv.getMeasuredHeight();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">再或者：</div><div class=\"line\"></div><div class=\"line\">@Override</div><div class=\"line\">    protected void onStart() &#123;</div><div class=\"line\">        super.onStart();</div><div class=\"line\">        ViewTreeObserver observer = tv.getViewTreeObserver();</div><div class=\"line\">        observer.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public void onGlobalLayout() &#123;</div><div class=\"line\">                int width = tv.getMeasuredWidth();</div><div class=\"line\">                int height = tv.getMeasuredHeight();</div><div class=\"line\">                tv.getViewTreeObserver().removeOnGlobalLayoutListener(this);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>layout和onLayout方法有什么区别？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">layout是确定本身view的位置 而onLayout是确定所有子元素的位置。layout里面 就是通过serFrame方法设设定本身view的 四个顶点的位置。这4个位置以确定 自己view的位置就固定了。</div><div class=\"line\"></div><div class=\"line\">然后就调用onLayout来确定子元素的位置。view和viewgroup的onlayout方法都没有写。都留给我们自己给子元素布局</div></pre></td></tr></table></figure>\n<ul>\n<li>draw方法 大概有几个步骤？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">一共是4个步骤， 绘制背景---------绘制自己--------绘制chrildren----绘制装饰。</div></pre></td></tr></table></figure>\n<ul>\n<li>setWillNotDraw方法有什么用？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">这个方法在view里。</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">     * If this view doesn&apos;t do any drawing on its own, set this flag to</div><div class=\"line\">     * allow further optimizations. By default, this flag is not set on</div><div class=\"line\">     * View, but could be set on some View subclasses such as ViewGroup.</div><div class=\"line\">     *</div><div class=\"line\">     * Typically, if you override &#123;@link #onDraw(android.graphics.Canvas)&#125;</div><div class=\"line\">     * you should clear this flag.</div><div class=\"line\">     *</div><div class=\"line\">     * @param willNotDraw whether or not this View draw on its own</div><div class=\"line\">     */</div><div class=\"line\">    public void setWillNotDraw(boolean willNotDraw) &#123;</div><div class=\"line\">        setFlags(willNotDraw ? WILL_NOT_DRAW : 0, DRAW_MASK);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">用于设置标志位的 也就是说 如果你的自定义view 不需要draw的话，就可以设置这个方法为true。这样系统知道你这个view 不需要draw 可以优化执行速度。viewgroup 一般都默认设置这个为true，因为viewgroup多数都是只负责布局，不负责draw的。而view 这个标志位 默认一般都是关闭的。</div></pre></td></tr></table></figure>\n<ul>\n<li>自定义view 有哪些需要注意的点？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div></pre></td><td class=\"code\"><pre><div class=\"line\"> 主要是要处理wrap_content 和padding。否则xml 那边设置这2个属性就根本没用了。还有不要在view中使用handler 因为人家已经提供了post方法。如果是继承自viewGroup,那在onMeasure和onLayout里面 也要考虑padding和layout的影响。也就是说specSize 要算一下 。最后就是如果view的动画或者线程需要停止，可以考虑在onDetachedFromWindow里面来做。</div><div class=\"line\"></div><div class=\"line\">针对上述的几点，给出几个简单的自定义view 供大家理解。</div><div class=\"line\"></div><div class=\"line\">给出一个圆形的view 范例：</div><div class=\"line\"></div><div class=\"line\">package com.example.administrator.motioneventtest;</div><div class=\"line\"></div><div class=\"line\">import android.content.Context;</div><div class=\"line\">import android.graphics.Canvas;</div><div class=\"line\">import android.graphics.Color;</div><div class=\"line\">import android.graphics.Paint;</div><div class=\"line\">import android.util.AttributeSet;</div><div class=\"line\">import android.view.View;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * Created by Administrator on 2016/2/4.</div><div class=\"line\"> */</div><div class=\"line\">public class CircleView extends View &#123;</div><div class=\"line\"></div><div class=\"line\">    private int mColor = Color.RED;</div><div class=\"line\">    private Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);</div><div class=\"line\"></div><div class=\"line\">    private void init() &#123;</div><div class=\"line\">        mPaint.setColor(mColor);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class=\"line\">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class=\"line\">        int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);</div><div class=\"line\">        int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);</div><div class=\"line\">        int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);</div><div class=\"line\">        int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec);</div><div class=\"line\"></div><div class=\"line\">        //处理为wrap_content时的情况</div><div class=\"line\">        if (widthSpecMode == MeasureSpec.AT_MOST &amp;&amp; heightSpecMode == MeasureSpec.AT_MOST) &#123;</div><div class=\"line\">            setMeasuredDimension(200, 200);</div><div class=\"line\">        &#125; else if (widthSpecMode == MeasureSpec.AT_MOST) &#123;</div><div class=\"line\">            setMeasuredDimension(200, heightSpecSize);</div><div class=\"line\">        &#125; else if (heightSpecMode == MeasureSpec.AT_MOST) &#123;</div><div class=\"line\">            setMeasuredDimension(widthSpecSize, 200);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    protected void onDraw(Canvas canvas) &#123;</div><div class=\"line\">        super.onDraw(canvas);</div><div class=\"line\">        //处理padding的情况</div><div class=\"line\">        final int paddingLeft = getPaddingLeft();</div><div class=\"line\">        final int paddingRight = getPaddingRight();</div><div class=\"line\">        final int paddingTop = getPaddingTop();</div><div class=\"line\">        final int paddingBottom = getPaddingBottom();</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">        int width = getWidth() - paddingLeft - paddingRight;</div><div class=\"line\">        int height = getHeight() - paddingTop - paddingBottom;</div><div class=\"line\">        int radius = Math.min(width, height) / 2;</div><div class=\"line\">        canvas.drawCircle(paddingLeft + width / 2, paddingTop + height / 2, radius, mPaint);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public CircleView(Context context, AttributeSet attrs, int defStyleAttr) &#123;</div><div class=\"line\">        super(context, attrs, defStyleAttr);</div><div class=\"line\">        init();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public CircleView(Context context) &#123;</div><div class=\"line\">        super(context);</div><div class=\"line\">        init();</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public CircleView(Context context, AttributeSet attrs) &#123;</div><div class=\"line\">        super(context, attrs);</div><div class=\"line\">        init();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">1. Measure 过程决定了 View 的测量宽/高，measure 过程结束后可以通过 getMeasuredWidth 和 getMeasuredHeight 方法获取 View 测量后的宽/高（正常情况下它都等于 View 最后的宽高，但是也有特殊情况）</div><div class=\"line\">2. Layout 决定了四个顶点的坐标和实际 View 的宽和高，完成以后可以通过 getTop,getBottom,getLeft,getRight 拿到四个顶点的坐标，通过 getWidth,getHeight得到最终实际的宽高。</div><div class=\"line\">3. Draw 决定 View 的显示，只有 draw 执行完毕以后，View 的内容才最终显示到屏幕上。</div></pre></td></tr></table></figure>\n","excerpt":"<ul>\n<li><p>.View的绘制流程分几步，从哪开始？哪个过程结束以后能看到view？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">从ViewRoot的performTraversals开始，经过measure，layout,draw 三个流程。draw流程结束以后就可以在屏幕上看到view了。</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>view的测量宽高和实际宽高有区别吗？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">基本上百分之99的情况下都是可以认为没有区别的。有两种情况，有区别。第一种 就是有的时候会因为某些原因 view会多次测量，那第一次测量的宽高 肯定和最后实际的宽高 是不一定相等的，但是在这种情况下最后一次测量的宽高和实际宽高是一致的。此外，实际宽高是在layout流程里确定的，我们可以在layout流程里 将实际宽高写死 写成硬编码，这样测量的宽高和实际宽高就肯定不一样了，虽然这么做没有意义 而且也不好。</div></pre></td></tr></table></figure>\n</li>\n</ul>","more":"<ul>\n<li>view的measureSpec 由谁决定?顶级view呢？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">由view自己的layoutparams和父容器  一起决定自己的measureSpec。一旦确定了spec，onMeasure中就可以确定view的宽高了。</div><div class=\"line\"></div><div class=\"line\">顶级view就稍微特殊一点，对于decorView的测量在ViewRootImpl的源码里。</div><div class=\"line\"></div><div class=\"line\">/desire的这2个参数就代表屏幕的宽高，</div><div class=\"line\">  childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);</div><div class=\"line\">  childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);</div><div class=\"line\">  performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class=\"line\"></div><div class=\"line\">  //decorView的measureSpec就是在这里确定的，其实比普通view的measurespec要简单的多</div><div class=\"line\">  //代码就不分析了 一目了然的东西</div><div class=\"line\">  private static int getRootMeasureSpec(int windowSize, int rootDimension) &#123;</div><div class=\"line\">        int measureSpec;</div><div class=\"line\">        switch (rootDimension) &#123;</div><div class=\"line\"></div><div class=\"line\">        case ViewGroup.LayoutParams.MATCH_PARENT:</div><div class=\"line\">            // Window can&apos;t resize. Force root view to be windowSize.</div><div class=\"line\">            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</div><div class=\"line\">            break;</div><div class=\"line\">        case ViewGroup.LayoutParams.WRAP_CONTENT:</div><div class=\"line\">            // Window can resize. Set max size for root view.</div><div class=\"line\">            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);</div><div class=\"line\">            break;</div><div class=\"line\">        default:</div><div class=\"line\">            // Window wants to be an exact size. Force root view to be that size.</div><div class=\"line\">            measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);</div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return measureSpec;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>对于普通view来说，他的measure过程中，与父view有关吗？如果有关，这个父view也就是viewgroup扮演了什么角色？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div></pre></td><td class=\"code\"><pre><div class=\"line\">//对于普通view的measure来说 是由这个view的 父view ，也就是viewgroup来触发的。</div><div class=\"line\">//也就是下面这个measureChildWithMargins方法</div><div class=\"line\"></div><div class=\"line\">protected void measureChildWithMargins(View child,</div><div class=\"line\">            int parentWidthMeasureSpec, int widthUsed,</div><div class=\"line\">            int parentHeightMeasureSpec, int heightUsed) &#123;</div><div class=\"line\">         //第一步 先取得子view的 layoutParams 参数值   </div><div class=\"line\">        final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class=\"line\"></div><div class=\"line\">        //然后开始计算子view的spec的值，注意这里看到 计算的时候除了要用子view的 layoutparams参数以外</div><div class=\"line\">        //还用到了父view 也就是viewgroup自己的spec的值</div><div class=\"line\">        final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class=\"line\">                mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</div><div class=\"line\">                        + widthUsed, lp.width);</div><div class=\"line\">        final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class=\"line\">                mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</div><div class=\"line\">                        + heightUsed, lp.height);</div><div class=\"line\"></div><div class=\"line\">        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//这个算view的spec的方法 看上去一大串 但是真的逻辑非常简单 就是根据父亲viewgroup</div><div class=\"line\">//的meaurespec 同时还有view自己的params来确定 view自己的measureSpec。</div><div class=\"line\">//注意这里的参数是padding,这个值的含义是 父容器已占用的控件的大小 所以view的Specsize</div><div class=\"line\">//的值 你们可以看到 是要减去这个padding的值的。总大小-已经用的 =可用的。 很好理解。</div><div class=\"line\"></div><div class=\"line\">//然后就是下面的switch逻辑 要自己梳理清楚。其实也不难，主要是下面几条原则</div><div class=\"line\">//如果view采用固定宽高，也就是写死的数值那种。那就不管父亲的spec的值了，view的spec 就肯定是exactly 并且大小遵循layout参数里设置的大小。</div><div class=\"line\"></div><div class=\"line\">//如果view的宽高是match_parent ，那么就要看父容器viewgroup的 spec的值了，如果父view的spec是exactly模式，</div><div class=\"line\">//那view也肯定是exactly,并且大小就是父容器剩下的空间。如果父容器是at_most模式，那view也是at_most 并且不会超过剩余空间大小</div><div class=\"line\"></div><div class=\"line\">//如果view的宽高是wrap_content, 那就不管父容器的spec了，view的spec一定是at_most 并且不会超过父view 剩余空间的大小。</div><div class=\"line\"></div><div class=\"line\">public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123;</div><div class=\"line\">        int specMode = MeasureSpec.getMode(spec);</div><div class=\"line\">        int specSize = MeasureSpec.getSize(spec);</div><div class=\"line\"></div><div class=\"line\">        int size = Math.max(0, specSize - padding);</div><div class=\"line\"></div><div class=\"line\">        int resultSize = 0;</div><div class=\"line\">        int resultMode = 0;</div><div class=\"line\"></div><div class=\"line\">        switch (specMode) &#123;</div><div class=\"line\">        // Parent has imposed an exact size on us</div><div class=\"line\">        case MeasureSpec.EXACTLY:</div><div class=\"line\">            if (childDimension &gt;= 0) &#123;</div><div class=\"line\">                resultSize = childDimension;</div><div class=\"line\">                resultMode = MeasureSpec.EXACTLY;</div><div class=\"line\">            &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class=\"line\">                // Child wants to be our size. So be it.</div><div class=\"line\">                resultSize = size;</div><div class=\"line\">                resultMode = MeasureSpec.EXACTLY;</div><div class=\"line\">            &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class=\"line\">                // Child wants to determine its own size. It can&apos;t be</div><div class=\"line\">                // bigger than us.</div><div class=\"line\">                resultSize = size;</div><div class=\"line\">                resultMode = MeasureSpec.AT_MOST;</div><div class=\"line\">            &#125;</div><div class=\"line\">            break;</div><div class=\"line\"></div><div class=\"line\">        // Parent has imposed a maximum size on us</div><div class=\"line\">        case MeasureSpec.AT_MOST:</div><div class=\"line\">            if (childDimension &gt;= 0) &#123;</div><div class=\"line\">                // Child wants a specific size... so be it</div><div class=\"line\">                resultSize = childDimension;</div><div class=\"line\">                resultMode = MeasureSpec.EXACTLY;</div><div class=\"line\">            &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class=\"line\">                // Child wants to be our size, but our size is not fixed.</div><div class=\"line\">                // Constrain child to not be bigger than us.</div><div class=\"line\">                resultSize = size;</div><div class=\"line\">                resultMode = MeasureSpec.AT_MOST;</div><div class=\"line\">            &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class=\"line\">                // Child wants to determine its own size. It can&apos;t be</div><div class=\"line\">                // bigger than us.</div><div class=\"line\">                resultSize = size;</div><div class=\"line\">                resultMode = MeasureSpec.AT_MOST;</div><div class=\"line\">            &#125;</div><div class=\"line\">            break;</div><div class=\"line\"></div><div class=\"line\">        // Parent asked to see how big we want to be</div><div class=\"line\">        case MeasureSpec.UNSPECIFIED:</div><div class=\"line\">            if (childDimension &gt;= 0) &#123;</div><div class=\"line\">                // Child wants a specific size... let him have it</div><div class=\"line\">                resultSize = childDimension;</div><div class=\"line\">                resultMode = MeasureSpec.EXACTLY;</div><div class=\"line\">            &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class=\"line\">                // Child wants to be our size... find out how big it should</div><div class=\"line\">                // be</div><div class=\"line\">                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;</div><div class=\"line\">                resultMode = MeasureSpec.UNSPECIFIED;</div><div class=\"line\">            &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class=\"line\">                // Child wants to determine its own size.... find out how</div><div class=\"line\">                // big it should be</div><div class=\"line\">                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;</div><div class=\"line\">                resultMode = MeasureSpec.UNSPECIFIED;</div><div class=\"line\">            &#125;</div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return MeasureSpec.makeMeasureSpec(resultSize, resultMode);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>.view的meaure和onMeasure有什么关系？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div></pre></td><td class=\"code\"><pre><div class=\"line\">//view的measure是final 方法 我们子类无法修改的。</div><div class=\"line\"> public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class=\"line\">        boolean optical = isLayoutModeOptical(this);</div><div class=\"line\">        if (optical != isLayoutModeOptical(mParent)) &#123;</div><div class=\"line\">            Insets insets = getOpticalInsets();</div><div class=\"line\">            int oWidth  = insets.left + insets.right;</div><div class=\"line\">            int oHeight = insets.top  + insets.bottom;</div><div class=\"line\">            widthMeasureSpec  = MeasureSpec.adjust(widthMeasureSpec,  optical ? -oWidth  : oWidth);</div><div class=\"line\">            heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Suppress sign extension for the low bytes</div><div class=\"line\">        long key = (long) widthMeasureSpec &lt;&lt; 32 | (long) heightMeasureSpec &amp; 0xffffffffL;</div><div class=\"line\">        if (mMeasureCache == null) mMeasureCache = new LongSparseLongArray(2);</div><div class=\"line\"></div><div class=\"line\">        if ((mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ||</div><div class=\"line\">                widthMeasureSpec != mOldWidthMeasureSpec ||</div><div class=\"line\">                heightMeasureSpec != mOldHeightMeasureSpec) &#123;</div><div class=\"line\"></div><div class=\"line\">            // first clears the measured dimension flag</div><div class=\"line\">            mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET;</div><div class=\"line\"></div><div class=\"line\">            resolveRtlPropertiesIfNeeded();</div><div class=\"line\"></div><div class=\"line\">            int cacheIndex = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ? -1 :</div><div class=\"line\">                    mMeasureCache.indexOfKey(key);</div><div class=\"line\">            if (cacheIndex &lt; 0 || sIgnoreMeasureCache) &#123;</div><div class=\"line\">                // measure ourselves, this should set the measured dimension flag back</div><div class=\"line\">                onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class=\"line\">                mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                long value = mMeasureCache.valueAt(cacheIndex);</div><div class=\"line\">                // Casting a long to int drops the high 32 bits, no mask needed</div><div class=\"line\">                setMeasuredDimensionRaw((int) (value &gt;&gt; 32), (int) value);</div><div class=\"line\">                mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // flag not set, setMeasuredDimension() was not invoked, we raise</div><div class=\"line\">            // an exception to warn the developer</div><div class=\"line\">            if ((mPrivateFlags &amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) &#123;</div><div class=\"line\">                throw new IllegalStateException(&quot;View with id &quot; + getId() + &quot;: &quot;</div><div class=\"line\">                        + getClass().getName() + &quot;#onMeasure() did not set the&quot;</div><div class=\"line\">                        + &quot; measured dimension by calling&quot;</div><div class=\"line\">                        + &quot; setMeasuredDimension()&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        mOldWidthMeasureSpec = widthMeasureSpec;</div><div class=\"line\">        mOldHeightMeasureSpec = heightMeasureSpec;</div><div class=\"line\"></div><div class=\"line\">        mMeasureCache.put(key, ((long) mMeasuredWidth) &lt;&lt; 32 |</div><div class=\"line\">                (long) mMeasuredHeight &amp; 0xffffffffL); // suppress sign extension</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">//不过可以看到的是在measure方法里调用了onMeasure方法</div><div class=\"line\">//所以就能知道 我们在自定义view的时候一定是重写这个方法！</div><div class=\"line\"> protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class=\"line\">        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</div><div class=\"line\">                getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>简要分析view的measure流程？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">viewgroup 算出子view的spec以后 会调用子view的measure方法，而子view的measure方法 我们问题5也看过了实际上是调用的onMeasure方法。</div><div class=\"line\"></div><div class=\"line\">所以我们只要分析好onMeasure方法即可，注意onMeasure方法的参数 正是他的父view算出来的那2个spec的值(这里view的measure方法会把这个spec里的specSize值做略微的修改 这个部分 不做分析 因为measure方法修改specSize的部分很简单)。</div><div class=\"line\"></div><div class=\"line\">//可以看出来这个就是setMeasuredDimension方法的调用 这个方法看名字就知道就是确定view的测量宽高的</div><div class=\"line\">//所以我们分析的重点就是看这个getDefaultSize 方法 是怎么确定view的测量宽高的</div><div class=\"line\"> protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class=\"line\">        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</div><div class=\"line\">                getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//这个方法特别简单 基本可以认为就是近似的返回spec中的specSize，除非你的specMode是UNSPECIFIED</div><div class=\"line\">//UNSPECIFIED 这个一般都是系统内部测量才用的到，这种时候返回size 也就是getSuggestedMinimumWidth的返回值</div><div class=\"line\"> public static int getDefaultSize(int size, int measureSpec) &#123;</div><div class=\"line\">        int result = size;</div><div class=\"line\">        int specMode = MeasureSpec.getMode(measureSpec);</div><div class=\"line\">        int specSize = MeasureSpec.getSize(measureSpec);</div><div class=\"line\"></div><div class=\"line\">        switch (specMode) &#123;</div><div class=\"line\">        case MeasureSpec.UNSPECIFIED:</div><div class=\"line\">            result = size;</div><div class=\"line\">            break;</div><div class=\"line\">        case MeasureSpec.AT_MOST:</div><div class=\"line\">        case MeasureSpec.EXACTLY:</div><div class=\"line\">            result = specSize;</div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return result;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//跟view的背景相关 这里不多做分析了</div><div class=\"line\">protected int getSuggestedMinimumWidth() &#123;</div><div class=\"line\">        return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>.自定义view中 如果onMeasure方法 没有对wrap_content 做处理 会发生什么？为什么？怎么解决？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"> 如果没有对wrap_content做处理 ，那即使你在xml里设置为wrap_content.其效果也和match_parent相同。看问题4的分析。我们可以知道view自己的layout为wrap，那mode就是at_most（不管父亲view是什么specmode）.</div><div class=\"line\"></div><div class=\"line\">这种模式下宽高就是等于specSize(getDefaultSize函数分析可知)，而这里的specSize显然就是parentSize的大小。也就是父容器剩余的大小。那不就和我们直接设置成match_parent是一样的效果了么？</div><div class=\"line\"></div><div class=\"line\">解决方式就是在onMeasure里 针对wrap 来做特殊处理 比如指定一个默认的宽高，当发现是wrap_content 就设置这个默认宽高即可。</div></pre></td></tr></table></figure>\n<ul>\n<li>为什么在activity的生命周期里无法获得测量宽高？有什么方法可以解决这个问题吗？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">因为measure的过程和activity的生命周期  没有任何关系。你无法确定在哪个生命周期执行完毕以后 view的measure过程一定走完。可以尝试如下几种方法 获取view的测量宽高。</div><div class=\"line\"></div><div class=\"line\">//重写activity的这个方法</div><div class=\"line\">public void onWindowFocusChanged(boolean hasFocus) &#123;</div><div class=\"line\">        super.onWindowFocusChanged(hasFocus);</div><div class=\"line\">        if (hasFocus) &#123;</div><div class=\"line\">            int width = tv.getMeasuredWidth();</div><div class=\"line\">            int height = tv.getMeasuredHeight();</div><div class=\"line\">            Log.v(&quot;burning&quot;, &quot;width==&quot; + width);</div><div class=\"line\">            Log.v(&quot;burning&quot;, &quot;height==&quot; + height);</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">或者重写这个方法</div><div class=\"line\"></div><div class=\"line\">@Override</div><div class=\"line\">    protected void onStart() &#123;</div><div class=\"line\">        super.onStart();</div><div class=\"line\">        tv.post(new Runnable() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public void run() &#123;</div><div class=\"line\">                int width = tv.getMeasuredWidth();</div><div class=\"line\">                int height = tv.getMeasuredHeight();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">再或者：</div><div class=\"line\"></div><div class=\"line\">@Override</div><div class=\"line\">    protected void onStart() &#123;</div><div class=\"line\">        super.onStart();</div><div class=\"line\">        ViewTreeObserver observer = tv.getViewTreeObserver();</div><div class=\"line\">        observer.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public void onGlobalLayout() &#123;</div><div class=\"line\">                int width = tv.getMeasuredWidth();</div><div class=\"line\">                int height = tv.getMeasuredHeight();</div><div class=\"line\">                tv.getViewTreeObserver().removeOnGlobalLayoutListener(this);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>layout和onLayout方法有什么区别？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">layout是确定本身view的位置 而onLayout是确定所有子元素的位置。layout里面 就是通过serFrame方法设设定本身view的 四个顶点的位置。这4个位置以确定 自己view的位置就固定了。</div><div class=\"line\"></div><div class=\"line\">然后就调用onLayout来确定子元素的位置。view和viewgroup的onlayout方法都没有写。都留给我们自己给子元素布局</div></pre></td></tr></table></figure>\n<ul>\n<li>draw方法 大概有几个步骤？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">一共是4个步骤， 绘制背景---------绘制自己--------绘制chrildren----绘制装饰。</div></pre></td></tr></table></figure>\n<ul>\n<li>setWillNotDraw方法有什么用？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">这个方法在view里。</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">     * If this view doesn&apos;t do any drawing on its own, set this flag to</div><div class=\"line\">     * allow further optimizations. By default, this flag is not set on</div><div class=\"line\">     * View, but could be set on some View subclasses such as ViewGroup.</div><div class=\"line\">     *</div><div class=\"line\">     * Typically, if you override &#123;@link #onDraw(android.graphics.Canvas)&#125;</div><div class=\"line\">     * you should clear this flag.</div><div class=\"line\">     *</div><div class=\"line\">     * @param willNotDraw whether or not this View draw on its own</div><div class=\"line\">     */</div><div class=\"line\">    public void setWillNotDraw(boolean willNotDraw) &#123;</div><div class=\"line\">        setFlags(willNotDraw ? WILL_NOT_DRAW : 0, DRAW_MASK);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">用于设置标志位的 也就是说 如果你的自定义view 不需要draw的话，就可以设置这个方法为true。这样系统知道你这个view 不需要draw 可以优化执行速度。viewgroup 一般都默认设置这个为true，因为viewgroup多数都是只负责布局，不负责draw的。而view 这个标志位 默认一般都是关闭的。</div></pre></td></tr></table></figure>\n<ul>\n<li>自定义view 有哪些需要注意的点？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div></pre></td><td class=\"code\"><pre><div class=\"line\"> 主要是要处理wrap_content 和padding。否则xml 那边设置这2个属性就根本没用了。还有不要在view中使用handler 因为人家已经提供了post方法。如果是继承自viewGroup,那在onMeasure和onLayout里面 也要考虑padding和layout的影响。也就是说specSize 要算一下 。最后就是如果view的动画或者线程需要停止，可以考虑在onDetachedFromWindow里面来做。</div><div class=\"line\"></div><div class=\"line\">针对上述的几点，给出几个简单的自定义view 供大家理解。</div><div class=\"line\"></div><div class=\"line\">给出一个圆形的view 范例：</div><div class=\"line\"></div><div class=\"line\">package com.example.administrator.motioneventtest;</div><div class=\"line\"></div><div class=\"line\">import android.content.Context;</div><div class=\"line\">import android.graphics.Canvas;</div><div class=\"line\">import android.graphics.Color;</div><div class=\"line\">import android.graphics.Paint;</div><div class=\"line\">import android.util.AttributeSet;</div><div class=\"line\">import android.view.View;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * Created by Administrator on 2016/2/4.</div><div class=\"line\"> */</div><div class=\"line\">public class CircleView extends View &#123;</div><div class=\"line\"></div><div class=\"line\">    private int mColor = Color.RED;</div><div class=\"line\">    private Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);</div><div class=\"line\"></div><div class=\"line\">    private void init() &#123;</div><div class=\"line\">        mPaint.setColor(mColor);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class=\"line\">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class=\"line\">        int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);</div><div class=\"line\">        int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);</div><div class=\"line\">        int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);</div><div class=\"line\">        int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec);</div><div class=\"line\"></div><div class=\"line\">        //处理为wrap_content时的情况</div><div class=\"line\">        if (widthSpecMode == MeasureSpec.AT_MOST &amp;&amp; heightSpecMode == MeasureSpec.AT_MOST) &#123;</div><div class=\"line\">            setMeasuredDimension(200, 200);</div><div class=\"line\">        &#125; else if (widthSpecMode == MeasureSpec.AT_MOST) &#123;</div><div class=\"line\">            setMeasuredDimension(200, heightSpecSize);</div><div class=\"line\">        &#125; else if (heightSpecMode == MeasureSpec.AT_MOST) &#123;</div><div class=\"line\">            setMeasuredDimension(widthSpecSize, 200);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    protected void onDraw(Canvas canvas) &#123;</div><div class=\"line\">        super.onDraw(canvas);</div><div class=\"line\">        //处理padding的情况</div><div class=\"line\">        final int paddingLeft = getPaddingLeft();</div><div class=\"line\">        final int paddingRight = getPaddingRight();</div><div class=\"line\">        final int paddingTop = getPaddingTop();</div><div class=\"line\">        final int paddingBottom = getPaddingBottom();</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">        int width = getWidth() - paddingLeft - paddingRight;</div><div class=\"line\">        int height = getHeight() - paddingTop - paddingBottom;</div><div class=\"line\">        int radius = Math.min(width, height) / 2;</div><div class=\"line\">        canvas.drawCircle(paddingLeft + width / 2, paddingTop + height / 2, radius, mPaint);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public CircleView(Context context, AttributeSet attrs, int defStyleAttr) &#123;</div><div class=\"line\">        super(context, attrs, defStyleAttr);</div><div class=\"line\">        init();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public CircleView(Context context) &#123;</div><div class=\"line\">        super(context);</div><div class=\"line\">        init();</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public CircleView(Context context, AttributeSet attrs) &#123;</div><div class=\"line\">        super(context, attrs);</div><div class=\"line\">        init();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">1. Measure 过程决定了 View 的测量宽/高，measure 过程结束后可以通过 getMeasuredWidth 和 getMeasuredHeight 方法获取 View 测量后的宽/高（正常情况下它都等于 View 最后的宽高，但是也有特殊情况）</div><div class=\"line\">2. Layout 决定了四个顶点的坐标和实际 View 的宽和高，完成以后可以通过 getTop,getBottom,getLeft,getRight 拿到四个顶点的坐标，通过 getWidth,getHeight得到最终实际的宽高。</div><div class=\"line\">3. Draw 决定 View 的显示，只有 draw 执行完毕以后，View 的内容才最终显示到屏幕上。</div></pre></td></tr></table></figure>"},{"title":"Bitmap缩放技巧总结","toc":true,"date":"2016-05-30T14:33:03.000Z","_content":"1.使用BitmapFactory.Options来控制缩放比例，降低图片色彩模式\n```\nBitmapFactory.Options options = new BitmapFactory.Options();\n  options.inJustDecodeBounds = true;\n  // 获取这个图片的宽和高\n  Bitmap bitmap = BitmapFactory.decodeFile(path, options); // 此时返回bm为空\n  options.inJustDecodeBounds = false;\n  // 计算缩放比\n  int be = (int) (options.outHeight / (float) 200);\n  if (be <= 0)\n   be = 1;\n  options.inSampleSize = 2; // 图片长宽各缩小二分之一\n  //每个像素占据2个字节\n  options.inPreferredConfig = Bitmap.Config.RGB_565;\n  // 重新读入图片，注意这次要把options.inJustDecodeBounds 设为 false哦\n  bitmap = BitmapFactory.decodeFile(path, options);\n由于只是对bitmap加载到内存一次，所以效率比较高。解析速度快\n```\n<!-- more-->\n2.Bitmap+Matrix\n```\npublic static Bitmap zoomBitmap(Bitmap bitmap, int width, int height) {\n        if (bitmap == null) {\n            return null;\n        }\n    int w = bitmap.getWidth();\n        int h = bitmap.getHeight();\n        Matrix matrix = new Matrix();\n        float scaleWidth = ((float) width / w);\n        float scaleHeight = ((float) height / h);\n        matrix.postScale(scaleWidth, scaleHeight);\n        Bitmap newbmp = Bitmap.createBitmap(bitmap, 0, 0, w, h, matrix, true);\n        return newbmp;\n    }\n ```\n \n> 对于Drawable、Bitmap、Canvas和Paint它们之间的概念不是很清楚，其实它们除了Drawable外早在Sun的J2ME中就已经出现了，但是在Android平台中，Bitmap、Canvas相关的都有所变化。\n  首先让我们理解下Android平台中的显示类是View，但是还提供了底层图形类android.graphics，今天所说的这些均为graphics底层图形接口。\n  Bitmap - 称作位图，一般位图的文件格式后缀为bmp，当然编码器也有很多如RGB565、RGB888。作为一种逐像素的显示对象执行效率高，但是缺点也很明显存储效率低。我们理解为一种存储对象比较好。\n  Drawable - 作为Android平下通用的图形对象，它可以装载常用格式的图像，比如GIF、PNG、JPG，当然也支持BMP，当然还提供一些高级的可视化对象，比如渐变、图形等。\n  Canvas - 名为画布，我们可以看作是一种处理过程，使用各种方法来管理Bitmap、GL或者Path路径，同时它可以配合Matrix矩阵类给图像做旋转、缩放等操作，同时Canvas类还提供了裁剪、选取等操作。\n   Paint - 我们可以把它看做一个画图工具，比如画笔、画刷。他管理了每个画图工具的字体、颜色、样式。\n  如果涉及一些Android游戏开发、显示特效可以通过这些底层图形类来高效实现自己的应用。\n  \n  \n\n\n","source":"_posts/Bitmap缩放技巧总结.md","raw":"---\ntitle: Bitmap缩放技巧总结\ntoc: true\ndate: 2016-05-30 22:33:03\ntags: Bitmap\ncategories: 性能优化\n---\n1.使用BitmapFactory.Options来控制缩放比例，降低图片色彩模式\n```\nBitmapFactory.Options options = new BitmapFactory.Options();\n  options.inJustDecodeBounds = true;\n  // 获取这个图片的宽和高\n  Bitmap bitmap = BitmapFactory.decodeFile(path, options); // 此时返回bm为空\n  options.inJustDecodeBounds = false;\n  // 计算缩放比\n  int be = (int) (options.outHeight / (float) 200);\n  if (be <= 0)\n   be = 1;\n  options.inSampleSize = 2; // 图片长宽各缩小二分之一\n  //每个像素占据2个字节\n  options.inPreferredConfig = Bitmap.Config.RGB_565;\n  // 重新读入图片，注意这次要把options.inJustDecodeBounds 设为 false哦\n  bitmap = BitmapFactory.decodeFile(path, options);\n由于只是对bitmap加载到内存一次，所以效率比较高。解析速度快\n```\n<!-- more-->\n2.Bitmap+Matrix\n```\npublic static Bitmap zoomBitmap(Bitmap bitmap, int width, int height) {\n        if (bitmap == null) {\n            return null;\n        }\n    int w = bitmap.getWidth();\n        int h = bitmap.getHeight();\n        Matrix matrix = new Matrix();\n        float scaleWidth = ((float) width / w);\n        float scaleHeight = ((float) height / h);\n        matrix.postScale(scaleWidth, scaleHeight);\n        Bitmap newbmp = Bitmap.createBitmap(bitmap, 0, 0, w, h, matrix, true);\n        return newbmp;\n    }\n ```\n \n> 对于Drawable、Bitmap、Canvas和Paint它们之间的概念不是很清楚，其实它们除了Drawable外早在Sun的J2ME中就已经出现了，但是在Android平台中，Bitmap、Canvas相关的都有所变化。\n  首先让我们理解下Android平台中的显示类是View，但是还提供了底层图形类android.graphics，今天所说的这些均为graphics底层图形接口。\n  Bitmap - 称作位图，一般位图的文件格式后缀为bmp，当然编码器也有很多如RGB565、RGB888。作为一种逐像素的显示对象执行效率高，但是缺点也很明显存储效率低。我们理解为一种存储对象比较好。\n  Drawable - 作为Android平下通用的图形对象，它可以装载常用格式的图像，比如GIF、PNG、JPG，当然也支持BMP，当然还提供一些高级的可视化对象，比如渐变、图形等。\n  Canvas - 名为画布，我们可以看作是一种处理过程，使用各种方法来管理Bitmap、GL或者Path路径，同时它可以配合Matrix矩阵类给图像做旋转、缩放等操作，同时Canvas类还提供了裁剪、选取等操作。\n   Paint - 我们可以把它看做一个画图工具，比如画笔、画刷。他管理了每个画图工具的字体、颜色、样式。\n  如果涉及一些Android游戏开发、显示特效可以通过这些底层图形类来高效实现自己的应用。\n  \n  \n\n\n","slug":"Bitmap缩放技巧总结","published":1,"updated":"2016-11-27T07:32:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjecoc8hl0004fuv17u9icdw9","content":"<p>1.使用BitmapFactory.Options来控制缩放比例，降低图片色彩模式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">BitmapFactory.Options options = new BitmapFactory.Options();</div><div class=\"line\">  options.inJustDecodeBounds = true;</div><div class=\"line\">  // 获取这个图片的宽和高</div><div class=\"line\">  Bitmap bitmap = BitmapFactory.decodeFile(path, options); // 此时返回bm为空</div><div class=\"line\">  options.inJustDecodeBounds = false;</div><div class=\"line\">  // 计算缩放比</div><div class=\"line\">  int be = (int) (options.outHeight / (float) 200);</div><div class=\"line\">  if (be &lt;= 0)</div><div class=\"line\">   be = 1;</div><div class=\"line\">  options.inSampleSize = 2; // 图片长宽各缩小二分之一</div><div class=\"line\">  //每个像素占据2个字节</div><div class=\"line\">  options.inPreferredConfig = Bitmap.Config.RGB_565;</div><div class=\"line\">  // 重新读入图片，注意这次要把options.inJustDecodeBounds 设为 false哦</div><div class=\"line\">  bitmap = BitmapFactory.decodeFile(path, options);</div><div class=\"line\">由于只是对bitmap加载到内存一次，所以效率比较高。解析速度快</div></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>2.Bitmap+Matrix<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static Bitmap zoomBitmap(Bitmap bitmap, int width, int height) &#123;</div><div class=\"line\">        if (bitmap == null) &#123;</div><div class=\"line\">            return null;</div><div class=\"line\">        &#125;</div><div class=\"line\">    int w = bitmap.getWidth();</div><div class=\"line\">        int h = bitmap.getHeight();</div><div class=\"line\">        Matrix matrix = new Matrix();</div><div class=\"line\">        float scaleWidth = ((float) width / w);</div><div class=\"line\">        float scaleHeight = ((float) height / h);</div><div class=\"line\">        matrix.postScale(scaleWidth, scaleHeight);</div><div class=\"line\">        Bitmap newbmp = Bitmap.createBitmap(bitmap, 0, 0, w, h, matrix, true);</div><div class=\"line\">        return newbmp;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>对于Drawable、Bitmap、Canvas和Paint它们之间的概念不是很清楚，其实它们除了Drawable外早在Sun的J2ME中就已经出现了，但是在Android平台中，Bitmap、Canvas相关的都有所变化。<br>  首先让我们理解下Android平台中的显示类是View，但是还提供了底层图形类android.graphics，今天所说的这些均为graphics底层图形接口。<br>  Bitmap - 称作位图，一般位图的文件格式后缀为bmp，当然编码器也有很多如RGB565、RGB888。作为一种逐像素的显示对象执行效率高，但是缺点也很明显存储效率低。我们理解为一种存储对象比较好。<br>  Drawable - 作为Android平下通用的图形对象，它可以装载常用格式的图像，比如GIF、PNG、JPG，当然也支持BMP，当然还提供一些高级的可视化对象，比如渐变、图形等。<br>  Canvas - 名为画布，我们可以看作是一种处理过程，使用各种方法来管理Bitmap、GL或者Path路径，同时它可以配合Matrix矩阵类给图像做旋转、缩放等操作，同时Canvas类还提供了裁剪、选取等操作。<br>   Paint - 我们可以把它看做一个画图工具，比如画笔、画刷。他管理了每个画图工具的字体、颜色、样式。<br>  如果涉及一些Android游戏开发、显示特效可以通过这些底层图形类来高效实现自己的应用。</p>\n</blockquote>\n","excerpt":"<p>1.使用BitmapFactory.Options来控制缩放比例，降低图片色彩模式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">BitmapFactory.Options options = new BitmapFactory.Options();</div><div class=\"line\">  options.inJustDecodeBounds = true;</div><div class=\"line\">  // 获取这个图片的宽和高</div><div class=\"line\">  Bitmap bitmap = BitmapFactory.decodeFile(path, options); // 此时返回bm为空</div><div class=\"line\">  options.inJustDecodeBounds = false;</div><div class=\"line\">  // 计算缩放比</div><div class=\"line\">  int be = (int) (options.outHeight / (float) 200);</div><div class=\"line\">  if (be &lt;= 0)</div><div class=\"line\">   be = 1;</div><div class=\"line\">  options.inSampleSize = 2; // 图片长宽各缩小二分之一</div><div class=\"line\">  //每个像素占据2个字节</div><div class=\"line\">  options.inPreferredConfig = Bitmap.Config.RGB_565;</div><div class=\"line\">  // 重新读入图片，注意这次要把options.inJustDecodeBounds 设为 false哦</div><div class=\"line\">  bitmap = BitmapFactory.decodeFile(path, options);</div><div class=\"line\">由于只是对bitmap加载到内存一次，所以效率比较高。解析速度快</div></pre></td></tr></table></figure></p>","more":"<p>2.Bitmap+Matrix<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static Bitmap zoomBitmap(Bitmap bitmap, int width, int height) &#123;</div><div class=\"line\">        if (bitmap == null) &#123;</div><div class=\"line\">            return null;</div><div class=\"line\">        &#125;</div><div class=\"line\">    int w = bitmap.getWidth();</div><div class=\"line\">        int h = bitmap.getHeight();</div><div class=\"line\">        Matrix matrix = new Matrix();</div><div class=\"line\">        float scaleWidth = ((float) width / w);</div><div class=\"line\">        float scaleHeight = ((float) height / h);</div><div class=\"line\">        matrix.postScale(scaleWidth, scaleHeight);</div><div class=\"line\">        Bitmap newbmp = Bitmap.createBitmap(bitmap, 0, 0, w, h, matrix, true);</div><div class=\"line\">        return newbmp;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>对于Drawable、Bitmap、Canvas和Paint它们之间的概念不是很清楚，其实它们除了Drawable外早在Sun的J2ME中就已经出现了，但是在Android平台中，Bitmap、Canvas相关的都有所变化。<br>  首先让我们理解下Android平台中的显示类是View，但是还提供了底层图形类android.graphics，今天所说的这些均为graphics底层图形接口。<br>  Bitmap - 称作位图，一般位图的文件格式后缀为bmp，当然编码器也有很多如RGB565、RGB888。作为一种逐像素的显示对象执行效率高，但是缺点也很明显存储效率低。我们理解为一种存储对象比较好。<br>  Drawable - 作为Android平下通用的图形对象，它可以装载常用格式的图像，比如GIF、PNG、JPG，当然也支持BMP，当然还提供一些高级的可视化对象，比如渐变、图形等。<br>  Canvas - 名为画布，我们可以看作是一种处理过程，使用各种方法来管理Bitmap、GL或者Path路径，同时它可以配合Matrix矩阵类给图像做旋转、缩放等操作，同时Canvas类还提供了裁剪、选取等操作。<br>   Paint - 我们可以把它看做一个画图工具，比如画笔、画刷。他管理了每个画图工具的字体、颜色、样式。<br>  如果涉及一些Android游戏开发、显示特效可以通过这些底层图形类来高效实现自己的应用。</p>\n</blockquote>"},{"title":"Drawable、Bitmap、String、InputStream、Bitmap、byte数组互转","toc":true,"date":"2016-05-30T14:53:04.000Z","_content":"```\n对于Drawable、Bitmap、Canvas和Paint它们之间的概念不是很清楚，其实它们除了Drawable外早在Sun的J2ME中就已经出现了，但是在Android平台中，Bitmap、Canvas相关的都有所变化。首先让我们理解下Android平台中的显示类是View，但是还提供了底层图形类android.graphics，今天所说的这些均为graphics底层图形接口。 Bitmap - 称作位图，一般位图的文件格式后缀为bmp，当然编码器也有很多如RGB565、RGB888。作为一种逐像素的显示对象执行效率高，但是缺点也很明显存储效率低。我们理解为一种存储对象比较好。 Drawable - 作为Android平下通用的图形对象，它可以装载常用格式的图像，比如GIF、PNG、JPG，当然也支持BMP，当然还提供一些高级的可视化对象，比如渐变、图形等。 Canvas - 名为画布，我们可以看作是一种处理过程，使用各种方法来管理Bitmap、GL或者Path路径，同时它可以配合Matrix矩阵类给图像做旋转、缩放等操作，同时Canvas类还提供了裁剪、选取等操作。 Paint - 我们可以把它看做一个画图工具，比如画笔、画刷。他管理了每个画图工具的字体、颜色、样式。如果涉及一些Android游戏开发、显示特效可以通过这些底层图形类来高效实现自己的应用\n\n```\n<!-- more-->\n\nDrawable转Bitmap\n\n```\nResources res = getResources();\nDrawable drawable = res.getDrawable(R.drawable.myimage);\nBitmapDrawable bd = (BitmapDrawable) d;\nBitmap bm = bd.getBitmap();\n\n\npublic static Bitmap drawableToBitmap(Drawable drawable) {\nBitmap bitmap = Bitmap.createBitmap(\ndrawable.getIntrinsicWidth(),\ndrawable.getIntrinsicHeight(),\ndrawable.getOpacity() != PixelFormat.OPAQUE ?Bitmap.Config.ARGB_8888\n: Bitmap.Config.RGB_565);\nCanvas canvas = new Canvas(bitmap);\n//canvas.setBitmap(bitmap);\ndrawable.setBounds(0, 0, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight());\ndrawable.draw(canvas);\nreturn bitmap;\n}\n\n```\n- Bitmap转Drawable\n\n```\n\nBitmap bm=xxx; //xxx根据你的情况获取\nBitmapDrawable bd=BitmapDrawable(bm);\nBtimapDrawable是Drawable的子类，最终直接使用bd对象即可。\n\nmPicPath//本地图片路径转成Bitmap格式\nBitmap pic = BitmapFactory.decodeFile(this.mPicPath);\nimage.setImageBitmap(pic);\n转成Bitmap格式\n\n```\n\n- String to InputStream\n\n```\n\nString str = \"String与InputStream相互转换\";\nInputStream   in_nocode   =   new   ByteArrayInputStream(str.getBytes());   \nInputStream   in_withcode   =   new   ByteArrayInputStream(str.getBytes(\"UTF-8\"));\n\n```\n\n- InputStream to String\n\n```\npublic String convertStreamToString(InputStream is) {\nBufferedReader reader = new BufferedReader(new InputStreamReader(is));\nStringBuilder sb = new StringBuilder();\n\nString line = null;\ntry {\nwhile ((line = reader.readLine()) != null) {\nsb.append(line + \"/n\");\n}\n} catch (IOException e) {\ne.printStackTrace();\n} finally {\ntry {\nis.close();\n} catch (IOException e) {\ne.printStackTrace();\n}\n}\n\nreturn sb.toString();\n}\n\n---\n\npublic String inputStream2String (InputStream in) throws IOException {\nStringBuffer out = new StringBuffer();\nbyte[] b = new byte[4096];\nfor (int n; (n = in.read(b)) != -1;) {\nout.append(new String(b, 0, n));\n}\nreturn out.toString();\n}\n\n---\n\npublic static String inputStream2String(InputStream is) throws IOException{\nByteArrayOutputStream baos = new ByteArrayOutputStream();\nint i=-1;\nwhile((i=is.read())!=-1){\nbaos.write(i);\n}\nreturn baos.toString();\n}\n\n```\n\n- Bitmap → byte[]\n\n```\n\nprivate byte[] Bitmap2Bytes(Bitmap bm){\nByteArrayOutputStream baos = new ByteArrayOutputStream();\nbm.compress(Bitmap.CompressFormat.PNG, 100, baos);\nreturn baos.toByteArray(); }\n\n```\n\n- byte[] → Bitmap\n\n```\nprivate Bitmap Bytes2Bimap(byte[] b){\nif(b.length!=0){\nreturn BitmapFactory.decodeByteArray(b, 0, b.length);\n}\nelse {\nreturn null;\n}\n}\n\n```\n","source":"_posts/Drawable、Bitmap、String、InputStream、Bitmap、byte数组互转.md","raw":"---\ntitle: Drawable、Bitmap、String、InputStream、Bitmap、byte数组互转\ntoc: true\ndate: 2016-05-30 22:53:04\ntags: \n- Bitmap\n- Drawable\ncategories: Utils\n---\n```\n对于Drawable、Bitmap、Canvas和Paint它们之间的概念不是很清楚，其实它们除了Drawable外早在Sun的J2ME中就已经出现了，但是在Android平台中，Bitmap、Canvas相关的都有所变化。首先让我们理解下Android平台中的显示类是View，但是还提供了底层图形类android.graphics，今天所说的这些均为graphics底层图形接口。 Bitmap - 称作位图，一般位图的文件格式后缀为bmp，当然编码器也有很多如RGB565、RGB888。作为一种逐像素的显示对象执行效率高，但是缺点也很明显存储效率低。我们理解为一种存储对象比较好。 Drawable - 作为Android平下通用的图形对象，它可以装载常用格式的图像，比如GIF、PNG、JPG，当然也支持BMP，当然还提供一些高级的可视化对象，比如渐变、图形等。 Canvas - 名为画布，我们可以看作是一种处理过程，使用各种方法来管理Bitmap、GL或者Path路径，同时它可以配合Matrix矩阵类给图像做旋转、缩放等操作，同时Canvas类还提供了裁剪、选取等操作。 Paint - 我们可以把它看做一个画图工具，比如画笔、画刷。他管理了每个画图工具的字体、颜色、样式。如果涉及一些Android游戏开发、显示特效可以通过这些底层图形类来高效实现自己的应用\n\n```\n<!-- more-->\n\nDrawable转Bitmap\n\n```\nResources res = getResources();\nDrawable drawable = res.getDrawable(R.drawable.myimage);\nBitmapDrawable bd = (BitmapDrawable) d;\nBitmap bm = bd.getBitmap();\n\n\npublic static Bitmap drawableToBitmap(Drawable drawable) {\nBitmap bitmap = Bitmap.createBitmap(\ndrawable.getIntrinsicWidth(),\ndrawable.getIntrinsicHeight(),\ndrawable.getOpacity() != PixelFormat.OPAQUE ?Bitmap.Config.ARGB_8888\n: Bitmap.Config.RGB_565);\nCanvas canvas = new Canvas(bitmap);\n//canvas.setBitmap(bitmap);\ndrawable.setBounds(0, 0, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight());\ndrawable.draw(canvas);\nreturn bitmap;\n}\n\n```\n- Bitmap转Drawable\n\n```\n\nBitmap bm=xxx; //xxx根据你的情况获取\nBitmapDrawable bd=BitmapDrawable(bm);\nBtimapDrawable是Drawable的子类，最终直接使用bd对象即可。\n\nmPicPath//本地图片路径转成Bitmap格式\nBitmap pic = BitmapFactory.decodeFile(this.mPicPath);\nimage.setImageBitmap(pic);\n转成Bitmap格式\n\n```\n\n- String to InputStream\n\n```\n\nString str = \"String与InputStream相互转换\";\nInputStream   in_nocode   =   new   ByteArrayInputStream(str.getBytes());   \nInputStream   in_withcode   =   new   ByteArrayInputStream(str.getBytes(\"UTF-8\"));\n\n```\n\n- InputStream to String\n\n```\npublic String convertStreamToString(InputStream is) {\nBufferedReader reader = new BufferedReader(new InputStreamReader(is));\nStringBuilder sb = new StringBuilder();\n\nString line = null;\ntry {\nwhile ((line = reader.readLine()) != null) {\nsb.append(line + \"/n\");\n}\n} catch (IOException e) {\ne.printStackTrace();\n} finally {\ntry {\nis.close();\n} catch (IOException e) {\ne.printStackTrace();\n}\n}\n\nreturn sb.toString();\n}\n\n---\n\npublic String inputStream2String (InputStream in) throws IOException {\nStringBuffer out = new StringBuffer();\nbyte[] b = new byte[4096];\nfor (int n; (n = in.read(b)) != -1;) {\nout.append(new String(b, 0, n));\n}\nreturn out.toString();\n}\n\n---\n\npublic static String inputStream2String(InputStream is) throws IOException{\nByteArrayOutputStream baos = new ByteArrayOutputStream();\nint i=-1;\nwhile((i=is.read())!=-1){\nbaos.write(i);\n}\nreturn baos.toString();\n}\n\n```\n\n- Bitmap → byte[]\n\n```\n\nprivate byte[] Bitmap2Bytes(Bitmap bm){\nByteArrayOutputStream baos = new ByteArrayOutputStream();\nbm.compress(Bitmap.CompressFormat.PNG, 100, baos);\nreturn baos.toByteArray(); }\n\n```\n\n- byte[] → Bitmap\n\n```\nprivate Bitmap Bytes2Bimap(byte[] b){\nif(b.length!=0){\nreturn BitmapFactory.decodeByteArray(b, 0, b.length);\n}\nelse {\nreturn null;\n}\n}\n\n```\n","slug":"Drawable、Bitmap、String、InputStream、Bitmap、byte数组互转","published":1,"updated":"2016-11-27T07:32:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjecoc8hm0005fuv1c00jf4mq","content":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">对于Drawable、Bitmap、Canvas和Paint它们之间的概念不是很清楚，其实它们除了Drawable外早在Sun的J2ME中就已经出现了，但是在Android平台中，Bitmap、Canvas相关的都有所变化。首先让我们理解下Android平台中的显示类是View，但是还提供了底层图形类android.graphics，今天所说的这些均为graphics底层图形接口。 Bitmap - 称作位图，一般位图的文件格式后缀为bmp，当然编码器也有很多如RGB565、RGB888。作为一种逐像素的显示对象执行效率高，但是缺点也很明显存储效率低。我们理解为一种存储对象比较好。 Drawable - 作为Android平下通用的图形对象，它可以装载常用格式的图像，比如GIF、PNG、JPG，当然也支持BMP，当然还提供一些高级的可视化对象，比如渐变、图形等。 Canvas - 名为画布，我们可以看作是一种处理过程，使用各种方法来管理Bitmap、GL或者Path路径，同时它可以配合Matrix矩阵类给图像做旋转、缩放等操作，同时Canvas类还提供了裁剪、选取等操作。 Paint - 我们可以把它看做一个画图工具，比如画笔、画刷。他管理了每个画图工具的字体、颜色、样式。如果涉及一些Android游戏开发、显示特效可以通过这些底层图形类来高效实现自己的应用</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>Drawable转Bitmap</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">Resources res = getResources();</div><div class=\"line\">Drawable drawable = res.getDrawable(R.drawable.myimage);</div><div class=\"line\">BitmapDrawable bd = (BitmapDrawable) d;</div><div class=\"line\">Bitmap bm = bd.getBitmap();</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">public static Bitmap drawableToBitmap(Drawable drawable) &#123;</div><div class=\"line\">Bitmap bitmap = Bitmap.createBitmap(</div><div class=\"line\">drawable.getIntrinsicWidth(),</div><div class=\"line\">drawable.getIntrinsicHeight(),</div><div class=\"line\">drawable.getOpacity() != PixelFormat.OPAQUE ?Bitmap.Config.ARGB_8888</div><div class=\"line\">: Bitmap.Config.RGB_565);</div><div class=\"line\">Canvas canvas = new Canvas(bitmap);</div><div class=\"line\">//canvas.setBitmap(bitmap);</div><div class=\"line\">drawable.setBounds(0, 0, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight());</div><div class=\"line\">drawable.draw(canvas);</div><div class=\"line\">return bitmap;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>Bitmap转Drawable</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">Bitmap bm=xxx; //xxx根据你的情况获取</div><div class=\"line\">BitmapDrawable bd=BitmapDrawable(bm);</div><div class=\"line\">BtimapDrawable是Drawable的子类，最终直接使用bd对象即可。</div><div class=\"line\"></div><div class=\"line\">mPicPath//本地图片路径转成Bitmap格式</div><div class=\"line\">Bitmap pic = BitmapFactory.decodeFile(this.mPicPath);</div><div class=\"line\">image.setImageBitmap(pic);</div><div class=\"line\">转成Bitmap格式</div></pre></td></tr></table></figure>\n<ul>\n<li>String to InputStream</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">String str = &quot;String与InputStream相互转换&quot;;</div><div class=\"line\">InputStream   in_nocode   =   new   ByteArrayInputStream(str.getBytes());   </div><div class=\"line\">InputStream   in_withcode   =   new   ByteArrayInputStream(str.getBytes(&quot;UTF-8&quot;));</div></pre></td></tr></table></figure>\n<ul>\n<li>InputStream to String</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">public String convertStreamToString(InputStream is) &#123;</div><div class=\"line\">BufferedReader reader = new BufferedReader(new InputStreamReader(is));</div><div class=\"line\">StringBuilder sb = new StringBuilder();</div><div class=\"line\"></div><div class=\"line\">String line = null;</div><div class=\"line\">try &#123;</div><div class=\"line\">while ((line = reader.readLine()) != null) &#123;</div><div class=\"line\">sb.append(line + &quot;/n&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">&#125; catch (IOException e) &#123;</div><div class=\"line\">e.printStackTrace();</div><div class=\"line\">&#125; finally &#123;</div><div class=\"line\">try &#123;</div><div class=\"line\">is.close();</div><div class=\"line\">&#125; catch (IOException e) &#123;</div><div class=\"line\">e.printStackTrace();</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">return sb.toString();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">---</div><div class=\"line\"></div><div class=\"line\">public String inputStream2String (InputStream in) throws IOException &#123;</div><div class=\"line\">StringBuffer out = new StringBuffer();</div><div class=\"line\">byte[] b = new byte[4096];</div><div class=\"line\">for (int n; (n = in.read(b)) != -1;) &#123;</div><div class=\"line\">out.append(new String(b, 0, n));</div><div class=\"line\">&#125;</div><div class=\"line\">return out.toString();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">---</div><div class=\"line\"></div><div class=\"line\">public static String inputStream2String(InputStream is) throws IOException&#123;</div><div class=\"line\">ByteArrayOutputStream baos = new ByteArrayOutputStream();</div><div class=\"line\">int i=-1;</div><div class=\"line\">while((i=is.read())!=-1)&#123;</div><div class=\"line\">baos.write(i);</div><div class=\"line\">&#125;</div><div class=\"line\">return baos.toString();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>Bitmap → byte[]</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">private byte[] Bitmap2Bytes(Bitmap bm)&#123;</div><div class=\"line\">ByteArrayOutputStream baos = new ByteArrayOutputStream();</div><div class=\"line\">bm.compress(Bitmap.CompressFormat.PNG, 100, baos);</div><div class=\"line\">return baos.toByteArray(); &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>byte[] → Bitmap</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">private Bitmap Bytes2Bimap(byte[] b)&#123;</div><div class=\"line\">if(b.length!=0)&#123;</div><div class=\"line\">return BitmapFactory.decodeByteArray(b, 0, b.length);</div><div class=\"line\">&#125;</div><div class=\"line\">else &#123;</div><div class=\"line\">return null;</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">对于Drawable、Bitmap、Canvas和Paint它们之间的概念不是很清楚，其实它们除了Drawable外早在Sun的J2ME中就已经出现了，但是在Android平台中，Bitmap、Canvas相关的都有所变化。首先让我们理解下Android平台中的显示类是View，但是还提供了底层图形类android.graphics，今天所说的这些均为graphics底层图形接口。 Bitmap - 称作位图，一般位图的文件格式后缀为bmp，当然编码器也有很多如RGB565、RGB888。作为一种逐像素的显示对象执行效率高，但是缺点也很明显存储效率低。我们理解为一种存储对象比较好。 Drawable - 作为Android平下通用的图形对象，它可以装载常用格式的图像，比如GIF、PNG、JPG，当然也支持BMP，当然还提供一些高级的可视化对象，比如渐变、图形等。 Canvas - 名为画布，我们可以看作是一种处理过程，使用各种方法来管理Bitmap、GL或者Path路径，同时它可以配合Matrix矩阵类给图像做旋转、缩放等操作，同时Canvas类还提供了裁剪、选取等操作。 Paint - 我们可以把它看做一个画图工具，比如画笔、画刷。他管理了每个画图工具的字体、颜色、样式。如果涉及一些Android游戏开发、显示特效可以通过这些底层图形类来高效实现自己的应用</div></pre></td></tr></table></figure>","more":"<p>Drawable转Bitmap</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">Resources res = getResources();</div><div class=\"line\">Drawable drawable = res.getDrawable(R.drawable.myimage);</div><div class=\"line\">BitmapDrawable bd = (BitmapDrawable) d;</div><div class=\"line\">Bitmap bm = bd.getBitmap();</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">public static Bitmap drawableToBitmap(Drawable drawable) &#123;</div><div class=\"line\">Bitmap bitmap = Bitmap.createBitmap(</div><div class=\"line\">drawable.getIntrinsicWidth(),</div><div class=\"line\">drawable.getIntrinsicHeight(),</div><div class=\"line\">drawable.getOpacity() != PixelFormat.OPAQUE ?Bitmap.Config.ARGB_8888</div><div class=\"line\">: Bitmap.Config.RGB_565);</div><div class=\"line\">Canvas canvas = new Canvas(bitmap);</div><div class=\"line\">//canvas.setBitmap(bitmap);</div><div class=\"line\">drawable.setBounds(0, 0, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight());</div><div class=\"line\">drawable.draw(canvas);</div><div class=\"line\">return bitmap;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>Bitmap转Drawable</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">Bitmap bm=xxx; //xxx根据你的情况获取</div><div class=\"line\">BitmapDrawable bd=BitmapDrawable(bm);</div><div class=\"line\">BtimapDrawable是Drawable的子类，最终直接使用bd对象即可。</div><div class=\"line\"></div><div class=\"line\">mPicPath//本地图片路径转成Bitmap格式</div><div class=\"line\">Bitmap pic = BitmapFactory.decodeFile(this.mPicPath);</div><div class=\"line\">image.setImageBitmap(pic);</div><div class=\"line\">转成Bitmap格式</div></pre></td></tr></table></figure>\n<ul>\n<li>String to InputStream</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">String str = &quot;String与InputStream相互转换&quot;;</div><div class=\"line\">InputStream   in_nocode   =   new   ByteArrayInputStream(str.getBytes());   </div><div class=\"line\">InputStream   in_withcode   =   new   ByteArrayInputStream(str.getBytes(&quot;UTF-8&quot;));</div></pre></td></tr></table></figure>\n<ul>\n<li>InputStream to String</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">public String convertStreamToString(InputStream is) &#123;</div><div class=\"line\">BufferedReader reader = new BufferedReader(new InputStreamReader(is));</div><div class=\"line\">StringBuilder sb = new StringBuilder();</div><div class=\"line\"></div><div class=\"line\">String line = null;</div><div class=\"line\">try &#123;</div><div class=\"line\">while ((line = reader.readLine()) != null) &#123;</div><div class=\"line\">sb.append(line + &quot;/n&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">&#125; catch (IOException e) &#123;</div><div class=\"line\">e.printStackTrace();</div><div class=\"line\">&#125; finally &#123;</div><div class=\"line\">try &#123;</div><div class=\"line\">is.close();</div><div class=\"line\">&#125; catch (IOException e) &#123;</div><div class=\"line\">e.printStackTrace();</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">return sb.toString();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">---</div><div class=\"line\"></div><div class=\"line\">public String inputStream2String (InputStream in) throws IOException &#123;</div><div class=\"line\">StringBuffer out = new StringBuffer();</div><div class=\"line\">byte[] b = new byte[4096];</div><div class=\"line\">for (int n; (n = in.read(b)) != -1;) &#123;</div><div class=\"line\">out.append(new String(b, 0, n));</div><div class=\"line\">&#125;</div><div class=\"line\">return out.toString();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">---</div><div class=\"line\"></div><div class=\"line\">public static String inputStream2String(InputStream is) throws IOException&#123;</div><div class=\"line\">ByteArrayOutputStream baos = new ByteArrayOutputStream();</div><div class=\"line\">int i=-1;</div><div class=\"line\">while((i=is.read())!=-1)&#123;</div><div class=\"line\">baos.write(i);</div><div class=\"line\">&#125;</div><div class=\"line\">return baos.toString();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>Bitmap → byte[]</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">private byte[] Bitmap2Bytes(Bitmap bm)&#123;</div><div class=\"line\">ByteArrayOutputStream baos = new ByteArrayOutputStream();</div><div class=\"line\">bm.compress(Bitmap.CompressFormat.PNG, 100, baos);</div><div class=\"line\">return baos.toByteArray(); &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>byte[] → Bitmap</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">private Bitmap Bytes2Bimap(byte[] b)&#123;</div><div class=\"line\">if(b.length!=0)&#123;</div><div class=\"line\">return BitmapFactory.decodeByteArray(b, 0, b.length);</div><div class=\"line\">&#125;</div><div class=\"line\">else &#123;</div><div class=\"line\">return null;</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"Handler消息传递机制","date":"2016-05-30T14:02:13.000Z","_content":"- Handler消息传递机制\n\nHandler类的主要机制有两个：在子线程中发送消息；在主线程中获取处理消息。\nHandler包含如下方法用于发送处理消息：\n<!-- more-->\n\n```\nvoid handleMessage(Message msg)：处理消息\nfinal boolean hasMessages(int what, Object object)：检查消息队列中是否包含what属性为指定值且object属性为指定对象的消息\nboolean sendEmptyMessage(int what)：发送空消息\nboolean sendEmptyMessageDelayed(int what, long delayMillis)：延迟发送空消息\nboolean sendMessage(Message msg)：发送消息\nboolean sendMessageDelayed(Message msg, long delayMillis)：延迟发送消息\n\n```\n- Handler、Looper、MessageQueue\n    \nHandler、Looper、MessageQueue各自作用如下：\nHandler：能发送消息给MessageQueue，并能处理Looper分发给它的消息；\nLooper：每个线程只有一个Looper，负责管理MessageQueue，从MessageQueue中取出消息分发给对应的Handler；\nMessageQueue：采用先进先出管理Message；\n\n注意：避免在主线程中执行耗时操作，否则会引发ANR异常。","source":"_posts/Handler消息传递机制.md","raw":"---\ntitle: Handler消息传递机制\ndate: 2016-05-30 22:02:13\ntags: Handler\ncategories: Andoroid通信\n\n---\n- Handler消息传递机制\n\nHandler类的主要机制有两个：在子线程中发送消息；在主线程中获取处理消息。\nHandler包含如下方法用于发送处理消息：\n<!-- more-->\n\n```\nvoid handleMessage(Message msg)：处理消息\nfinal boolean hasMessages(int what, Object object)：检查消息队列中是否包含what属性为指定值且object属性为指定对象的消息\nboolean sendEmptyMessage(int what)：发送空消息\nboolean sendEmptyMessageDelayed(int what, long delayMillis)：延迟发送空消息\nboolean sendMessage(Message msg)：发送消息\nboolean sendMessageDelayed(Message msg, long delayMillis)：延迟发送消息\n\n```\n- Handler、Looper、MessageQueue\n    \nHandler、Looper、MessageQueue各自作用如下：\nHandler：能发送消息给MessageQueue，并能处理Looper分发给它的消息；\nLooper：每个线程只有一个Looper，负责管理MessageQueue，从MessageQueue中取出消息分发给对应的Handler；\nMessageQueue：采用先进先出管理Message；\n\n注意：避免在主线程中执行耗时操作，否则会引发ANR异常。","slug":"Handler消息传递机制","published":1,"updated":"2016-11-27T07:32:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjecoc8hn0007fuv13gp6calf","content":"<ul>\n<li>Handler消息传递机制</li>\n</ul>\n<p>Handler类的主要机制有两个：在子线程中发送消息；在主线程中获取处理消息。<br>Handler包含如下方法用于发送处理消息：<br><a id=\"more\"></a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">void handleMessage(Message msg)：处理消息</div><div class=\"line\">final boolean hasMessages(int what, Object object)：检查消息队列中是否包含what属性为指定值且object属性为指定对象的消息</div><div class=\"line\">boolean sendEmptyMessage(int what)：发送空消息</div><div class=\"line\">boolean sendEmptyMessageDelayed(int what, long delayMillis)：延迟发送空消息</div><div class=\"line\">boolean sendMessage(Message msg)：发送消息</div><div class=\"line\">boolean sendMessageDelayed(Message msg, long delayMillis)：延迟发送消息</div></pre></td></tr></table></figure>\n<ul>\n<li>Handler、Looper、MessageQueue</li>\n</ul>\n<p>Handler、Looper、MessageQueue各自作用如下：<br>Handler：能发送消息给MessageQueue，并能处理Looper分发给它的消息；<br>Looper：每个线程只有一个Looper，负责管理MessageQueue，从MessageQueue中取出消息分发给对应的Handler；<br>MessageQueue：采用先进先出管理Message；</p>\n<p>注意：避免在主线程中执行耗时操作，否则会引发ANR异常。</p>\n","excerpt":"<ul>\n<li>Handler消息传递机制</li>\n</ul>\n<p>Handler类的主要机制有两个：在子线程中发送消息；在主线程中获取处理消息。<br>Handler包含如下方法用于发送处理消息：<br>","more":"</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">void handleMessage(Message msg)：处理消息</div><div class=\"line\">final boolean hasMessages(int what, Object object)：检查消息队列中是否包含what属性为指定值且object属性为指定对象的消息</div><div class=\"line\">boolean sendEmptyMessage(int what)：发送空消息</div><div class=\"line\">boolean sendEmptyMessageDelayed(int what, long delayMillis)：延迟发送空消息</div><div class=\"line\">boolean sendMessage(Message msg)：发送消息</div><div class=\"line\">boolean sendMessageDelayed(Message msg, long delayMillis)：延迟发送消息</div></pre></td></tr></table></figure>\n<ul>\n<li>Handler、Looper、MessageQueue</li>\n</ul>\n<p>Handler、Looper、MessageQueue各自作用如下：<br>Handler：能发送消息给MessageQueue，并能处理Looper分发给它的消息；<br>Looper：每个线程只有一个Looper，负责管理MessageQueue，从MessageQueue中取出消息分发给对应的Handler；<br>MessageQueue：采用先进先出管理Message；</p>\n<p>注意：避免在主线程中执行耗时操作，否则会引发ANR异常。</p>"},{"title":"Surfaceview","toc":true,"date":"2016-05-30T14:56:56.000Z","_content":"# Surfaceview \n- SurfaceHolder\n\n```\n  SurfaceHolder.Callback主要是当底层的Surface被创建、销毁或者改变时提供回调通知，由于绘制必须在Surface被创建后才能进行，因此SurfaceHolder.Callback中的surfaceCreated 和surfaceDestroyed 就成了绘图处理代码的边界。\n \n        SurfaceHolder.Callback中定义了三个接口方法：\n \n        1、abstract void surfaceChanged(SurfaceHolder holder, int format, int width, int height)：当surface发生任何结构性的变化时（格式或者大小），该方法就会被立即调用。\n \n        2、abstract void surfaceCreated(SurfaceHolder holder)：当surface对象创建后，该方法就会被立即调用。\n \n        3、abstract void  surfaceDestroyed(SurfaceHolder holder)：当surface对象在将要销毁前，该方法会被立即调\n\n```\n\n<!-- more-->\n- setFixSize\n\n```\nsetFixSize 不是设置SurfaceView的大小，而是告诉系统真     实的 video Size的大小。\n改变SurfaceView大小，就是改变SurfaceView layout的大小surfaceView里面有两个大小。一个是surface的大小，在sur  facechanged里面输出width和height的值来查看；还有一个就    是surfaceView本身的大小，重写onMeasure函数可以得到。具    体看下面的代码。而且，视频播放只与surfaceView的大小有关。\n ```\n\n\n- Surfaceview 简单应用\n\n```\n 1、在Activity的OnCreate函数中设置好SurfaceView，包括设置SurfaceHolder.Callback对象和SurfaceHolder对象的类型，具体如下\nSurfaceView mpreview = (SurfaceView) this.findViewById(R.id.camera_preview);\nSurfaceHolder mSurfaceHolder = mpreview.getHolder();\nmSurfaceHolder.addCallback(this);\n\n\t1. //为了实现照片预览功能，需要将SurfaceHolder的类型设置为PUSH  \n\t2.         //这样，画图缓存就由Camera类来管理，画图缓存是独立于Surface的\n\nmSurfaceHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);\n\n2、在SurfaceHolder.Callback的surfaceCreated函数中，使用Camera的Open函数开机摄像头硬件，这个API在SDK 2.3之前，是没有参数的，2.3以后支持多摄像头，所以开启前可以通过getNumberOfCameras先获取摄像头数目，再通过getCameraInfo得到需要开启的摄像头id，然后传入Open函数开启摄像头，假如摄像头开启成功则返回一个Camera对象，否则就抛出异常；\n\n3、开启成功的情况下，在SurfaceHolder.Callback的surfaceChanged函数中调用getParameters函数得到已打开的摄像头的配置参数Parameters对象，如果有需要就修改对象的参数，然后调用setParameters函数设置进去（SDK2.2以后，还可以通过Camera：：setDisplayOrientation设置方向）\n\n4、同样在surfaceChanged函数中，通过Camera：：setPreviewDisplay为摄像头设置SurfaceHolder对象，设置成功后调用Camera::startPreview函数开启预览功能，上面3,4两步的代码可以如下所示\npublic void surfaceChanged(SurfaceHolder holder, int format, int w, int h)\n{\n//已经获得Surface的width和height，设置Camera的参数\nCamera.Parameters parameters = camera.getParameters();\nparameters.setPreviewSize(w, h);\nList<Size> vSizeList = .getSupportedPictureSizes();\nfor(int num = 0; num < vSizeList.size(); num++)\n{\nSize vSize = vSizeList.get(num);\n}\nif(this.getResources().getConfiguration().orientation != Configuration.ORIENTATION_LANDSCAPE)\n{\n//如果是竖屏\nparameters.set(\"orientation\", \"portrait\");\n//在2.2以上可以使用\n//camera.setDisplayOrientation(90);\n}\nelse\n{\nparameters.set(\"orientation\", \"landscape\");\n//在2.2以上可以使用\n//camera.setDisplayOrientation(0);\n}\ncamera.setParameters(parameters);\ntry {\n//设置显示\ncamera.setPreviewDisplay(holder);\n} catch (IOException exception) {\ncamera.release();\ncamera = null;\n}\n//开始预览\ncamera.startPreview();\n}\n\n---\n\n\n\t // 当Surface被创建的时候，该方法被调用，可以在这里实例化Camera对象  \n\t         //同时可以对Camera进行定制  \n\t         camera = Camera.open(); //获取Camera实例  \n\n\n\t  /** \n\t          * Camera对象中含有一个内部类Camera.Parameters.该类可以对Camera的特性进行定制 \n\t          * 在Parameters中设置完成后，需要调用Camera.setParameters()方法，相应的设置才会生效 \n\t          * 由于不同的设备，Camera的特性是不同的，所以在设置时，需要首先判断设备对应的特性，再加以设置 \n\t          * 比如在调用setEffects之前最好先调用getSupportedColorEffects。如果设备不支持颜色特性，那么该方法将 \n\t          * 返回一个null \n\t          */  \n\t         try {  \n\t               \n\t             Camera.Parameters param = camera.getParameters();  \n\t             if(this.getResources().getConfiguration().orientation != Configuration.ORIENTATION_LANDSCAPE){  \n\t                 //如果是竖屏  \n\t                 param.set(\"orientation\", \"portrait\");  \n\t                 //在2.2以上可以使用  \n\t                 //camera.setDisplayOrientation(90);  \n\t             }else{  \n\t                 param.set(\"orientation\", \"landscape\");  \n\t                //在2.2以上可以使用  \n\t                 //camera.setDisplayOrientation(0);                \n\t             }  \n\t             //首先获取系统设备支持的所有颜色特效，有复合我们的，则设置；否则不设置  \n\t            List<String> colorEffects = param.getSupportedColorEffects();  \n\t             Iterator<String> colorItor = colorEffects.iterator();  \n\t             while(colorItor.hasNext()){  \n\t                 String currColor = colorItor.next();  \n\t                 if(currColor.equals(Camera.Parameters.EFFECT_SOLARIZE)){  \n\t                     param.setColorEffect(Camera.Parameters.EFFECT_SOLARIZE);  \n\t                     break;  \n\t                }  \n\t             }  \n\t             //设置完成需要再次调用setParameter方法才能生效  \n\t             camera.setParameters(param);  \n\t               \n\t            camera.setPreviewDisplay(holder);  \n\t               \n            /** \n\t              * 在显示了预览后，我们有时候希望限制预览的Size \n\t             * 我们并不是自己指定一个SIze而是指定一个Size，然后 \n\t              * 获取系统支持的SIZE，然后选择一个比指定SIZE小且最接近所指定SIZE的一个 \n\t              * Camera.Size对象就是该SIZE。 \n\t             *  \n\t            */  \n\t             int bestWidth = 0;  \n\t             int bestHeight = 0;  \n\t               \n\t             List<Camera.Size> sizeList = param.getSupportedPreviewSizes();  \n\t             //如果sizeList只有一个我们也没有必要做什么了，因为就他一个别无选择  \n\t             if(sizeList.size() > 1){  \n\t                 Iterator<Camera.Size> itor = sizeList.iterator();  \n\t                 while(itor.hasNext()){  \n\t                     Camera.Size cur = itor.next();  \n\t                     if(cur.width > bestWidth && cur.height>bestHeight && cur.width <MAX_WIDTH && cur.height < MAX_HEIGHT){  \n\t                         bestWidth = cur.width;  \n\t                         bestHeight = cur.height;  \n\t                    }  \n\t                 }  \n\t                 if(bestWidth != 0 && bestHeight != 0){  \n\t                     param.setPreviewSize(bestWidth, bestHeight);  \n\t                    //这里改变了SIze后，我们还要告诉SurfaceView，否则，Surface将不会改变大小，进入Camera的图像将质量很差  \n\t                    surfaceView.setLayoutParams(new LinearLayout.LayoutParams(bestWidth, bestHeight));  \n\t                }  \n\t             }  \n\t             camera.setParameters(param);  \n\t         } catch (Exception e) {  \n\t             // 如果出现异常，则释放Camera对象  \n\t             camera.release();  \n\t         }  \n\t           \n\t        //启动预览功能  \n\t         camera.startPreview();  \n\n\n\t1.  // 当Surface被销毁的时候，该方法被调用  \n\t2.         //在这里需要释放Camera资源  \n\t3.         camera.stopPreview();  \n\t4.         camera.release();  \n\n---\n\n5、假设要支持自动对焦功能，则在需要的情况下，或者在上述surfaceChanged调用完startPreview函数后，可以调用Camera::autoFocus函数来设置自动对焦回调函数，该步是可选操作，有些设备可能不支持，可以通过Camera::getFocusMode函数查询。代码可以参考如下：\n// 自动对焦\ncamera.autoFocus(new AutoFocusCallback()\n{\n@Override\npublic void onAutoFocus(boolean success, Camera camera)\n{\nif (success)\n{\n// success为true表示对焦成功，改变对焦状态图像\nivFocus.setImageResource(R.drawable.focus2);\n}\n}\n});\n\n\n6、在需要拍照的时候，调用takePicture(Camera.ShutterCallback, Camera.PictureCallback, Camera.PictureCallback, Camera.PictureCallback)函数来完成拍照，这个函数中可以四个回调接口，ShutterCallback是快门按下的回调，在这里我们可以设置播放“咔嚓”声之类的操作，后面有三个PictureCallback接口，分别对应三份图像数据，分别是原始图像、缩放和压缩图像和JPG图像，图像数据可以在PictureCallback接口的void onPictureTaken(byte[] data, Camera camera)中获得，三份数据相应的三个回调正好按照参数顺序调用，通常我们只关心JPG图像数据，此时前面两个PictureCallback接口参数可以直接传null；\n\n7、每次调用takePicture获取图像后，摄像头会停止预览，假如需要继续拍照，则我们需要在上面的PictureCallback的onPictureTaken函数末尾，再次掉哟更Camera::startPreview函数；\n\n8、在不需要拍照的时候，我们需要主动调用Camera::stopPreview函数停止预览功能，并且调用Camera::release函数释放Camera，以便其他应用程序调用。SDK中建议放在Activity的Pause函数中，但是我觉得放在surfaceDestroyed函数中更好，示例代码如下\n// 停止拍照时调用该方法\npublic void surfaceDestroyed(SurfaceHolder holder)\n{\n// 释放手机摄像头\ncamera.release();\n}\n以上就是自己实现拍照程序的的流程，一般还可以还可以获取预览帧的图像数据，可以分别通过Camera::setPreviewCallback和Camera::setOneShotPreviewCallback来设置每帧或下一帧图像数据的回调，这里就不做展开了。\n\n---\n\n/** A safe way to get an instance of the Camera object. */\npublic static Camera getCameraInstance(){\n    Camera c = null;\n    try {\n        c = Camera.open(); // attempt to get a Camera instance\n    }\n    catch (Exception e){\n        // Camera is not available (in use or does not exist)\n    }\n    return c; // returns null if camera is unavailable\n}\n\n---\n\n```","source":"_posts/Surfaceview.md","raw":"---\ntitle: Surfaceview\ntoc: true\ndate: 2016-05-30 22:56:56\ntags: View\ncategories: View\n---\n# Surfaceview \n- SurfaceHolder\n\n```\n  SurfaceHolder.Callback主要是当底层的Surface被创建、销毁或者改变时提供回调通知，由于绘制必须在Surface被创建后才能进行，因此SurfaceHolder.Callback中的surfaceCreated 和surfaceDestroyed 就成了绘图处理代码的边界。\n \n        SurfaceHolder.Callback中定义了三个接口方法：\n \n        1、abstract void surfaceChanged(SurfaceHolder holder, int format, int width, int height)：当surface发生任何结构性的变化时（格式或者大小），该方法就会被立即调用。\n \n        2、abstract void surfaceCreated(SurfaceHolder holder)：当surface对象创建后，该方法就会被立即调用。\n \n        3、abstract void  surfaceDestroyed(SurfaceHolder holder)：当surface对象在将要销毁前，该方法会被立即调\n\n```\n\n<!-- more-->\n- setFixSize\n\n```\nsetFixSize 不是设置SurfaceView的大小，而是告诉系统真     实的 video Size的大小。\n改变SurfaceView大小，就是改变SurfaceView layout的大小surfaceView里面有两个大小。一个是surface的大小，在sur  facechanged里面输出width和height的值来查看；还有一个就    是surfaceView本身的大小，重写onMeasure函数可以得到。具    体看下面的代码。而且，视频播放只与surfaceView的大小有关。\n ```\n\n\n- Surfaceview 简单应用\n\n```\n 1、在Activity的OnCreate函数中设置好SurfaceView，包括设置SurfaceHolder.Callback对象和SurfaceHolder对象的类型，具体如下\nSurfaceView mpreview = (SurfaceView) this.findViewById(R.id.camera_preview);\nSurfaceHolder mSurfaceHolder = mpreview.getHolder();\nmSurfaceHolder.addCallback(this);\n\n\t1. //为了实现照片预览功能，需要将SurfaceHolder的类型设置为PUSH  \n\t2.         //这样，画图缓存就由Camera类来管理，画图缓存是独立于Surface的\n\nmSurfaceHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);\n\n2、在SurfaceHolder.Callback的surfaceCreated函数中，使用Camera的Open函数开机摄像头硬件，这个API在SDK 2.3之前，是没有参数的，2.3以后支持多摄像头，所以开启前可以通过getNumberOfCameras先获取摄像头数目，再通过getCameraInfo得到需要开启的摄像头id，然后传入Open函数开启摄像头，假如摄像头开启成功则返回一个Camera对象，否则就抛出异常；\n\n3、开启成功的情况下，在SurfaceHolder.Callback的surfaceChanged函数中调用getParameters函数得到已打开的摄像头的配置参数Parameters对象，如果有需要就修改对象的参数，然后调用setParameters函数设置进去（SDK2.2以后，还可以通过Camera：：setDisplayOrientation设置方向）\n\n4、同样在surfaceChanged函数中，通过Camera：：setPreviewDisplay为摄像头设置SurfaceHolder对象，设置成功后调用Camera::startPreview函数开启预览功能，上面3,4两步的代码可以如下所示\npublic void surfaceChanged(SurfaceHolder holder, int format, int w, int h)\n{\n//已经获得Surface的width和height，设置Camera的参数\nCamera.Parameters parameters = camera.getParameters();\nparameters.setPreviewSize(w, h);\nList<Size> vSizeList = .getSupportedPictureSizes();\nfor(int num = 0; num < vSizeList.size(); num++)\n{\nSize vSize = vSizeList.get(num);\n}\nif(this.getResources().getConfiguration().orientation != Configuration.ORIENTATION_LANDSCAPE)\n{\n//如果是竖屏\nparameters.set(\"orientation\", \"portrait\");\n//在2.2以上可以使用\n//camera.setDisplayOrientation(90);\n}\nelse\n{\nparameters.set(\"orientation\", \"landscape\");\n//在2.2以上可以使用\n//camera.setDisplayOrientation(0);\n}\ncamera.setParameters(parameters);\ntry {\n//设置显示\ncamera.setPreviewDisplay(holder);\n} catch (IOException exception) {\ncamera.release();\ncamera = null;\n}\n//开始预览\ncamera.startPreview();\n}\n\n---\n\n\n\t // 当Surface被创建的时候，该方法被调用，可以在这里实例化Camera对象  \n\t         //同时可以对Camera进行定制  \n\t         camera = Camera.open(); //获取Camera实例  \n\n\n\t  /** \n\t          * Camera对象中含有一个内部类Camera.Parameters.该类可以对Camera的特性进行定制 \n\t          * 在Parameters中设置完成后，需要调用Camera.setParameters()方法，相应的设置才会生效 \n\t          * 由于不同的设备，Camera的特性是不同的，所以在设置时，需要首先判断设备对应的特性，再加以设置 \n\t          * 比如在调用setEffects之前最好先调用getSupportedColorEffects。如果设备不支持颜色特性，那么该方法将 \n\t          * 返回一个null \n\t          */  \n\t         try {  \n\t               \n\t             Camera.Parameters param = camera.getParameters();  \n\t             if(this.getResources().getConfiguration().orientation != Configuration.ORIENTATION_LANDSCAPE){  \n\t                 //如果是竖屏  \n\t                 param.set(\"orientation\", \"portrait\");  \n\t                 //在2.2以上可以使用  \n\t                 //camera.setDisplayOrientation(90);  \n\t             }else{  \n\t                 param.set(\"orientation\", \"landscape\");  \n\t                //在2.2以上可以使用  \n\t                 //camera.setDisplayOrientation(0);                \n\t             }  \n\t             //首先获取系统设备支持的所有颜色特效，有复合我们的，则设置；否则不设置  \n\t            List<String> colorEffects = param.getSupportedColorEffects();  \n\t             Iterator<String> colorItor = colorEffects.iterator();  \n\t             while(colorItor.hasNext()){  \n\t                 String currColor = colorItor.next();  \n\t                 if(currColor.equals(Camera.Parameters.EFFECT_SOLARIZE)){  \n\t                     param.setColorEffect(Camera.Parameters.EFFECT_SOLARIZE);  \n\t                     break;  \n\t                }  \n\t             }  \n\t             //设置完成需要再次调用setParameter方法才能生效  \n\t             camera.setParameters(param);  \n\t               \n\t            camera.setPreviewDisplay(holder);  \n\t               \n            /** \n\t              * 在显示了预览后，我们有时候希望限制预览的Size \n\t             * 我们并不是自己指定一个SIze而是指定一个Size，然后 \n\t              * 获取系统支持的SIZE，然后选择一个比指定SIZE小且最接近所指定SIZE的一个 \n\t              * Camera.Size对象就是该SIZE。 \n\t             *  \n\t            */  \n\t             int bestWidth = 0;  \n\t             int bestHeight = 0;  \n\t               \n\t             List<Camera.Size> sizeList = param.getSupportedPreviewSizes();  \n\t             //如果sizeList只有一个我们也没有必要做什么了，因为就他一个别无选择  \n\t             if(sizeList.size() > 1){  \n\t                 Iterator<Camera.Size> itor = sizeList.iterator();  \n\t                 while(itor.hasNext()){  \n\t                     Camera.Size cur = itor.next();  \n\t                     if(cur.width > bestWidth && cur.height>bestHeight && cur.width <MAX_WIDTH && cur.height < MAX_HEIGHT){  \n\t                         bestWidth = cur.width;  \n\t                         bestHeight = cur.height;  \n\t                    }  \n\t                 }  \n\t                 if(bestWidth != 0 && bestHeight != 0){  \n\t                     param.setPreviewSize(bestWidth, bestHeight);  \n\t                    //这里改变了SIze后，我们还要告诉SurfaceView，否则，Surface将不会改变大小，进入Camera的图像将质量很差  \n\t                    surfaceView.setLayoutParams(new LinearLayout.LayoutParams(bestWidth, bestHeight));  \n\t                }  \n\t             }  \n\t             camera.setParameters(param);  \n\t         } catch (Exception e) {  \n\t             // 如果出现异常，则释放Camera对象  \n\t             camera.release();  \n\t         }  \n\t           \n\t        //启动预览功能  \n\t         camera.startPreview();  \n\n\n\t1.  // 当Surface被销毁的时候，该方法被调用  \n\t2.         //在这里需要释放Camera资源  \n\t3.         camera.stopPreview();  \n\t4.         camera.release();  \n\n---\n\n5、假设要支持自动对焦功能，则在需要的情况下，或者在上述surfaceChanged调用完startPreview函数后，可以调用Camera::autoFocus函数来设置自动对焦回调函数，该步是可选操作，有些设备可能不支持，可以通过Camera::getFocusMode函数查询。代码可以参考如下：\n// 自动对焦\ncamera.autoFocus(new AutoFocusCallback()\n{\n@Override\npublic void onAutoFocus(boolean success, Camera camera)\n{\nif (success)\n{\n// success为true表示对焦成功，改变对焦状态图像\nivFocus.setImageResource(R.drawable.focus2);\n}\n}\n});\n\n\n6、在需要拍照的时候，调用takePicture(Camera.ShutterCallback, Camera.PictureCallback, Camera.PictureCallback, Camera.PictureCallback)函数来完成拍照，这个函数中可以四个回调接口，ShutterCallback是快门按下的回调，在这里我们可以设置播放“咔嚓”声之类的操作，后面有三个PictureCallback接口，分别对应三份图像数据，分别是原始图像、缩放和压缩图像和JPG图像，图像数据可以在PictureCallback接口的void onPictureTaken(byte[] data, Camera camera)中获得，三份数据相应的三个回调正好按照参数顺序调用，通常我们只关心JPG图像数据，此时前面两个PictureCallback接口参数可以直接传null；\n\n7、每次调用takePicture获取图像后，摄像头会停止预览，假如需要继续拍照，则我们需要在上面的PictureCallback的onPictureTaken函数末尾，再次掉哟更Camera::startPreview函数；\n\n8、在不需要拍照的时候，我们需要主动调用Camera::stopPreview函数停止预览功能，并且调用Camera::release函数释放Camera，以便其他应用程序调用。SDK中建议放在Activity的Pause函数中，但是我觉得放在surfaceDestroyed函数中更好，示例代码如下\n// 停止拍照时调用该方法\npublic void surfaceDestroyed(SurfaceHolder holder)\n{\n// 释放手机摄像头\ncamera.release();\n}\n以上就是自己实现拍照程序的的流程，一般还可以还可以获取预览帧的图像数据，可以分别通过Camera::setPreviewCallback和Camera::setOneShotPreviewCallback来设置每帧或下一帧图像数据的回调，这里就不做展开了。\n\n---\n\n/** A safe way to get an instance of the Camera object. */\npublic static Camera getCameraInstance(){\n    Camera c = null;\n    try {\n        c = Camera.open(); // attempt to get a Camera instance\n    }\n    catch (Exception e){\n        // Camera is not available (in use or does not exist)\n    }\n    return c; // returns null if camera is unavailable\n}\n\n---\n\n```","slug":"Surfaceview","published":1,"updated":"2016-11-27T07:32:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjecoc8hq000afuv1ox3cp7o9","content":"<h1 id=\"Surfaceview\"><a href=\"#Surfaceview\" class=\"headerlink\" title=\"Surfaceview\"></a>Surfaceview</h1><ul>\n<li>SurfaceHolder</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">SurfaceHolder.Callback主要是当底层的Surface被创建、销毁或者改变时提供回调通知，由于绘制必须在Surface被创建后才能进行，因此SurfaceHolder.Callback中的surfaceCreated 和surfaceDestroyed 就成了绘图处理代码的边界。</div><div class=\"line\"> </div><div class=\"line\">      SurfaceHolder.Callback中定义了三个接口方法：</div><div class=\"line\"> </div><div class=\"line\">      1、abstract void surfaceChanged(SurfaceHolder holder, int format, int width, int height)：当surface发生任何结构性的变化时（格式或者大小），该方法就会被立即调用。</div><div class=\"line\"> </div><div class=\"line\">      2、abstract void surfaceCreated(SurfaceHolder holder)：当surface对象创建后，该方法就会被立即调用。</div><div class=\"line\"> </div><div class=\"line\">      3、abstract void  surfaceDestroyed(SurfaceHolder holder)：当surface对象在将要销毁前，该方法会被立即调</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<ul>\n<li>setFixSize</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">setFixSize 不是设置SurfaceView的大小，而是告诉系统真     实的 video Size的大小。</div><div class=\"line\">改变SurfaceView大小，就是改变SurfaceView layout的大小surfaceView里面有两个大小。一个是surface的大小，在sur  facechanged里面输出width和height的值来查看；还有一个就    是surfaceView本身的大小，重写onMeasure函数可以得到。具    体看下面的代码。而且，视频播放只与surfaceView的大小有关。</div></pre></td></tr></table></figure>\n<ul>\n<li>Surfaceview 简单应用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div></pre></td><td class=\"code\"><pre><div class=\"line\"> 1、在Activity的OnCreate函数中设置好SurfaceView，包括设置SurfaceHolder.Callback对象和SurfaceHolder对象的类型，具体如下</div><div class=\"line\">SurfaceView mpreview = (SurfaceView) this.findViewById(R.id.camera_preview);</div><div class=\"line\">SurfaceHolder mSurfaceHolder = mpreview.getHolder();</div><div class=\"line\">mSurfaceHolder.addCallback(this);</div><div class=\"line\"></div><div class=\"line\">\t1. //为了实现照片预览功能，需要将SurfaceHolder的类型设置为PUSH  </div><div class=\"line\">\t2.         //这样，画图缓存就由Camera类来管理，画图缓存是独立于Surface的</div><div class=\"line\"></div><div class=\"line\">mSurfaceHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);</div><div class=\"line\"></div><div class=\"line\">2、在SurfaceHolder.Callback的surfaceCreated函数中，使用Camera的Open函数开机摄像头硬件，这个API在SDK 2.3之前，是没有参数的，2.3以后支持多摄像头，所以开启前可以通过getNumberOfCameras先获取摄像头数目，再通过getCameraInfo得到需要开启的摄像头id，然后传入Open函数开启摄像头，假如摄像头开启成功则返回一个Camera对象，否则就抛出异常；</div><div class=\"line\"></div><div class=\"line\">3、开启成功的情况下，在SurfaceHolder.Callback的surfaceChanged函数中调用getParameters函数得到已打开的摄像头的配置参数Parameters对象，如果有需要就修改对象的参数，然后调用setParameters函数设置进去（SDK2.2以后，还可以通过Camera：：setDisplayOrientation设置方向）</div><div class=\"line\"></div><div class=\"line\">4、同样在surfaceChanged函数中，通过Camera：：setPreviewDisplay为摄像头设置SurfaceHolder对象，设置成功后调用Camera::startPreview函数开启预览功能，上面3,4两步的代码可以如下所示</div><div class=\"line\">public void surfaceChanged(SurfaceHolder holder, int format, int w, int h)</div><div class=\"line\">&#123;</div><div class=\"line\">//已经获得Surface的width和height，设置Camera的参数</div><div class=\"line\">Camera.Parameters parameters = camera.getParameters();</div><div class=\"line\">parameters.setPreviewSize(w, h);</div><div class=\"line\">List&lt;Size&gt; vSizeList = .getSupportedPictureSizes();</div><div class=\"line\">for(int num = 0; num &lt; vSizeList.size(); num++)</div><div class=\"line\">&#123;</div><div class=\"line\">Size vSize = vSizeList.get(num);</div><div class=\"line\">&#125;</div><div class=\"line\">if(this.getResources().getConfiguration().orientation != Configuration.ORIENTATION_LANDSCAPE)</div><div class=\"line\">&#123;</div><div class=\"line\">//如果是竖屏</div><div class=\"line\">parameters.set(&quot;orientation&quot;, &quot;portrait&quot;);</div><div class=\"line\">//在2.2以上可以使用</div><div class=\"line\">//camera.setDisplayOrientation(90);</div><div class=\"line\">&#125;</div><div class=\"line\">else</div><div class=\"line\">&#123;</div><div class=\"line\">parameters.set(&quot;orientation&quot;, &quot;landscape&quot;);</div><div class=\"line\">//在2.2以上可以使用</div><div class=\"line\">//camera.setDisplayOrientation(0);</div><div class=\"line\">&#125;</div><div class=\"line\">camera.setParameters(parameters);</div><div class=\"line\">try &#123;</div><div class=\"line\">//设置显示</div><div class=\"line\">camera.setPreviewDisplay(holder);</div><div class=\"line\">&#125; catch (IOException exception) &#123;</div><div class=\"line\">camera.release();</div><div class=\"line\">camera = null;</div><div class=\"line\">&#125;</div><div class=\"line\">//开始预览</div><div class=\"line\">camera.startPreview();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">---</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t // 当Surface被创建的时候，该方法被调用，可以在这里实例化Camera对象  </div><div class=\"line\">\t         //同时可以对Camera进行定制  </div><div class=\"line\">\t         camera = Camera.open(); //获取Camera实例  </div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t  /** </div><div class=\"line\">\t          * Camera对象中含有一个内部类Camera.Parameters.该类可以对Camera的特性进行定制 </div><div class=\"line\">\t          * 在Parameters中设置完成后，需要调用Camera.setParameters()方法，相应的设置才会生效 </div><div class=\"line\">\t          * 由于不同的设备，Camera的特性是不同的，所以在设置时，需要首先判断设备对应的特性，再加以设置 </div><div class=\"line\">\t          * 比如在调用setEffects之前最好先调用getSupportedColorEffects。如果设备不支持颜色特性，那么该方法将 </div><div class=\"line\">\t          * 返回一个null </div><div class=\"line\">\t          */  </div><div class=\"line\">\t         try &#123;  </div><div class=\"line\">\t               </div><div class=\"line\">\t             Camera.Parameters param = camera.getParameters();  </div><div class=\"line\">\t             if(this.getResources().getConfiguration().orientation != Configuration.ORIENTATION_LANDSCAPE)&#123;  </div><div class=\"line\">\t                 //如果是竖屏  </div><div class=\"line\">\t                 param.set(&quot;orientation&quot;, &quot;portrait&quot;);  </div><div class=\"line\">\t                 //在2.2以上可以使用  </div><div class=\"line\">\t                 //camera.setDisplayOrientation(90);  </div><div class=\"line\">\t             &#125;else&#123;  </div><div class=\"line\">\t                 param.set(&quot;orientation&quot;, &quot;landscape&quot;);  </div><div class=\"line\">\t                //在2.2以上可以使用  </div><div class=\"line\">\t                 //camera.setDisplayOrientation(0);                </div><div class=\"line\">\t             &#125;  </div><div class=\"line\">\t             //首先获取系统设备支持的所有颜色特效，有复合我们的，则设置；否则不设置  </div><div class=\"line\">\t            List&lt;String&gt; colorEffects = param.getSupportedColorEffects();  </div><div class=\"line\">\t             Iterator&lt;String&gt; colorItor = colorEffects.iterator();  </div><div class=\"line\">\t             while(colorItor.hasNext())&#123;  </div><div class=\"line\">\t                 String currColor = colorItor.next();  </div><div class=\"line\">\t                 if(currColor.equals(Camera.Parameters.EFFECT_SOLARIZE))&#123;  </div><div class=\"line\">\t                     param.setColorEffect(Camera.Parameters.EFFECT_SOLARIZE);  </div><div class=\"line\">\t                     break;  </div><div class=\"line\">\t                &#125;  </div><div class=\"line\">\t             &#125;  </div><div class=\"line\">\t             //设置完成需要再次调用setParameter方法才能生效  </div><div class=\"line\">\t             camera.setParameters(param);  </div><div class=\"line\">\t               </div><div class=\"line\">\t            camera.setPreviewDisplay(holder);  </div><div class=\"line\">\t               </div><div class=\"line\">            /** </div><div class=\"line\">\t              * 在显示了预览后，我们有时候希望限制预览的Size </div><div class=\"line\">\t             * 我们并不是自己指定一个SIze而是指定一个Size，然后 </div><div class=\"line\">\t              * 获取系统支持的SIZE，然后选择一个比指定SIZE小且最接近所指定SIZE的一个 </div><div class=\"line\">\t              * Camera.Size对象就是该SIZE。 </div><div class=\"line\">\t             *  </div><div class=\"line\">\t            */  </div><div class=\"line\">\t             int bestWidth = 0;  </div><div class=\"line\">\t             int bestHeight = 0;  </div><div class=\"line\">\t               </div><div class=\"line\">\t             List&lt;Camera.Size&gt; sizeList = param.getSupportedPreviewSizes();  </div><div class=\"line\">\t             //如果sizeList只有一个我们也没有必要做什么了，因为就他一个别无选择  </div><div class=\"line\">\t             if(sizeList.size() &gt; 1)&#123;  </div><div class=\"line\">\t                 Iterator&lt;Camera.Size&gt; itor = sizeList.iterator();  </div><div class=\"line\">\t                 while(itor.hasNext())&#123;  </div><div class=\"line\">\t                     Camera.Size cur = itor.next();  </div><div class=\"line\">\t                     if(cur.width &gt; bestWidth &amp;&amp; cur.height&gt;bestHeight &amp;&amp; cur.width &lt;MAX_WIDTH &amp;&amp; cur.height &lt; MAX_HEIGHT)&#123;  </div><div class=\"line\">\t                         bestWidth = cur.width;  </div><div class=\"line\">\t                         bestHeight = cur.height;  </div><div class=\"line\">\t                    &#125;  </div><div class=\"line\">\t                 &#125;  </div><div class=\"line\">\t                 if(bestWidth != 0 &amp;&amp; bestHeight != 0)&#123;  </div><div class=\"line\">\t                     param.setPreviewSize(bestWidth, bestHeight);  </div><div class=\"line\">\t                    //这里改变了SIze后，我们还要告诉SurfaceView，否则，Surface将不会改变大小，进入Camera的图像将质量很差  </div><div class=\"line\">\t                    surfaceView.setLayoutParams(new LinearLayout.LayoutParams(bestWidth, bestHeight));  </div><div class=\"line\">\t                &#125;  </div><div class=\"line\">\t             &#125;  </div><div class=\"line\">\t             camera.setParameters(param);  </div><div class=\"line\">\t         &#125; catch (Exception e) &#123;  </div><div class=\"line\">\t             // 如果出现异常，则释放Camera对象  </div><div class=\"line\">\t             camera.release();  </div><div class=\"line\">\t         &#125;  </div><div class=\"line\">\t           </div><div class=\"line\">\t        //启动预览功能  </div><div class=\"line\">\t         camera.startPreview();  </div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t1.  // 当Surface被销毁的时候，该方法被调用  </div><div class=\"line\">\t2.         //在这里需要释放Camera资源  </div><div class=\"line\">\t3.         camera.stopPreview();  </div><div class=\"line\">\t4.         camera.release();  </div><div class=\"line\"></div><div class=\"line\">---</div><div class=\"line\"></div><div class=\"line\">5、假设要支持自动对焦功能，则在需要的情况下，或者在上述surfaceChanged调用完startPreview函数后，可以调用Camera::autoFocus函数来设置自动对焦回调函数，该步是可选操作，有些设备可能不支持，可以通过Camera::getFocusMode函数查询。代码可以参考如下：</div><div class=\"line\">// 自动对焦</div><div class=\"line\">camera.autoFocus(new AutoFocusCallback()</div><div class=\"line\">&#123;</div><div class=\"line\">@Override</div><div class=\"line\">public void onAutoFocus(boolean success, Camera camera)</div><div class=\"line\">&#123;</div><div class=\"line\">if (success)</div><div class=\"line\">&#123;</div><div class=\"line\">// success为true表示对焦成功，改变对焦状态图像</div><div class=\"line\">ivFocus.setImageResource(R.drawable.focus2);</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">6、在需要拍照的时候，调用takePicture(Camera.ShutterCallback, Camera.PictureCallback, Camera.PictureCallback, Camera.PictureCallback)函数来完成拍照，这个函数中可以四个回调接口，ShutterCallback是快门按下的回调，在这里我们可以设置播放“咔嚓”声之类的操作，后面有三个PictureCallback接口，分别对应三份图像数据，分别是原始图像、缩放和压缩图像和JPG图像，图像数据可以在PictureCallback接口的void onPictureTaken(byte[] data, Camera camera)中获得，三份数据相应的三个回调正好按照参数顺序调用，通常我们只关心JPG图像数据，此时前面两个PictureCallback接口参数可以直接传null；</div><div class=\"line\"></div><div class=\"line\">7、每次调用takePicture获取图像后，摄像头会停止预览，假如需要继续拍照，则我们需要在上面的PictureCallback的onPictureTaken函数末尾，再次掉哟更Camera::startPreview函数；</div><div class=\"line\"></div><div class=\"line\">8、在不需要拍照的时候，我们需要主动调用Camera::stopPreview函数停止预览功能，并且调用Camera::release函数释放Camera，以便其他应用程序调用。SDK中建议放在Activity的Pause函数中，但是我觉得放在surfaceDestroyed函数中更好，示例代码如下</div><div class=\"line\">// 停止拍照时调用该方法</div><div class=\"line\">public void surfaceDestroyed(SurfaceHolder holder)</div><div class=\"line\">&#123;</div><div class=\"line\">// 释放手机摄像头</div><div class=\"line\">camera.release();</div><div class=\"line\">&#125;</div><div class=\"line\">以上就是自己实现拍照程序的的流程，一般还可以还可以获取预览帧的图像数据，可以分别通过Camera::setPreviewCallback和Camera::setOneShotPreviewCallback来设置每帧或下一帧图像数据的回调，这里就不做展开了。</div><div class=\"line\"></div><div class=\"line\">---</div><div class=\"line\"></div><div class=\"line\">/** A safe way to get an instance of the Camera object. */</div><div class=\"line\">public static Camera getCameraInstance()&#123;</div><div class=\"line\">    Camera c = null;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        c = Camera.open(); // attempt to get a Camera instance</div><div class=\"line\">    &#125;</div><div class=\"line\">    catch (Exception e)&#123;</div><div class=\"line\">        // Camera is not available (in use or does not exist)</div><div class=\"line\">    &#125;</div><div class=\"line\">    return c; // returns null if camera is unavailable</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">---</div></pre></td></tr></table></figure>","excerpt":"<h1 id=\"Surfaceview\"><a href=\"#Surfaceview\" class=\"headerlink\" title=\"Surfaceview\"></a>Surfaceview</h1><ul>\n<li>SurfaceHolder</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">SurfaceHolder.Callback主要是当底层的Surface被创建、销毁或者改变时提供回调通知，由于绘制必须在Surface被创建后才能进行，因此SurfaceHolder.Callback中的surfaceCreated 和surfaceDestroyed 就成了绘图处理代码的边界。</div><div class=\"line\"> </div><div class=\"line\">      SurfaceHolder.Callback中定义了三个接口方法：</div><div class=\"line\"> </div><div class=\"line\">      1、abstract void surfaceChanged(SurfaceHolder holder, int format, int width, int height)：当surface发生任何结构性的变化时（格式或者大小），该方法就会被立即调用。</div><div class=\"line\"> </div><div class=\"line\">      2、abstract void surfaceCreated(SurfaceHolder holder)：当surface对象创建后，该方法就会被立即调用。</div><div class=\"line\"> </div><div class=\"line\">      3、abstract void  surfaceDestroyed(SurfaceHolder holder)：当surface对象在将要销毁前，该方法会被立即调</div></pre></td></tr></table></figure>","more":"<ul>\n<li>setFixSize</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">setFixSize 不是设置SurfaceView的大小，而是告诉系统真     实的 video Size的大小。</div><div class=\"line\">改变SurfaceView大小，就是改变SurfaceView layout的大小surfaceView里面有两个大小。一个是surface的大小，在sur  facechanged里面输出width和height的值来查看；还有一个就    是surfaceView本身的大小，重写onMeasure函数可以得到。具    体看下面的代码。而且，视频播放只与surfaceView的大小有关。</div></pre></td></tr></table></figure>\n<ul>\n<li>Surfaceview 简单应用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div></pre></td><td class=\"code\"><pre><div class=\"line\"> 1、在Activity的OnCreate函数中设置好SurfaceView，包括设置SurfaceHolder.Callback对象和SurfaceHolder对象的类型，具体如下</div><div class=\"line\">SurfaceView mpreview = (SurfaceView) this.findViewById(R.id.camera_preview);</div><div class=\"line\">SurfaceHolder mSurfaceHolder = mpreview.getHolder();</div><div class=\"line\">mSurfaceHolder.addCallback(this);</div><div class=\"line\"></div><div class=\"line\">\t1. //为了实现照片预览功能，需要将SurfaceHolder的类型设置为PUSH  </div><div class=\"line\">\t2.         //这样，画图缓存就由Camera类来管理，画图缓存是独立于Surface的</div><div class=\"line\"></div><div class=\"line\">mSurfaceHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);</div><div class=\"line\"></div><div class=\"line\">2、在SurfaceHolder.Callback的surfaceCreated函数中，使用Camera的Open函数开机摄像头硬件，这个API在SDK 2.3之前，是没有参数的，2.3以后支持多摄像头，所以开启前可以通过getNumberOfCameras先获取摄像头数目，再通过getCameraInfo得到需要开启的摄像头id，然后传入Open函数开启摄像头，假如摄像头开启成功则返回一个Camera对象，否则就抛出异常；</div><div class=\"line\"></div><div class=\"line\">3、开启成功的情况下，在SurfaceHolder.Callback的surfaceChanged函数中调用getParameters函数得到已打开的摄像头的配置参数Parameters对象，如果有需要就修改对象的参数，然后调用setParameters函数设置进去（SDK2.2以后，还可以通过Camera：：setDisplayOrientation设置方向）</div><div class=\"line\"></div><div class=\"line\">4、同样在surfaceChanged函数中，通过Camera：：setPreviewDisplay为摄像头设置SurfaceHolder对象，设置成功后调用Camera::startPreview函数开启预览功能，上面3,4两步的代码可以如下所示</div><div class=\"line\">public void surfaceChanged(SurfaceHolder holder, int format, int w, int h)</div><div class=\"line\">&#123;</div><div class=\"line\">//已经获得Surface的width和height，设置Camera的参数</div><div class=\"line\">Camera.Parameters parameters = camera.getParameters();</div><div class=\"line\">parameters.setPreviewSize(w, h);</div><div class=\"line\">List&lt;Size&gt; vSizeList = .getSupportedPictureSizes();</div><div class=\"line\">for(int num = 0; num &lt; vSizeList.size(); num++)</div><div class=\"line\">&#123;</div><div class=\"line\">Size vSize = vSizeList.get(num);</div><div class=\"line\">&#125;</div><div class=\"line\">if(this.getResources().getConfiguration().orientation != Configuration.ORIENTATION_LANDSCAPE)</div><div class=\"line\">&#123;</div><div class=\"line\">//如果是竖屏</div><div class=\"line\">parameters.set(&quot;orientation&quot;, &quot;portrait&quot;);</div><div class=\"line\">//在2.2以上可以使用</div><div class=\"line\">//camera.setDisplayOrientation(90);</div><div class=\"line\">&#125;</div><div class=\"line\">else</div><div class=\"line\">&#123;</div><div class=\"line\">parameters.set(&quot;orientation&quot;, &quot;landscape&quot;);</div><div class=\"line\">//在2.2以上可以使用</div><div class=\"line\">//camera.setDisplayOrientation(0);</div><div class=\"line\">&#125;</div><div class=\"line\">camera.setParameters(parameters);</div><div class=\"line\">try &#123;</div><div class=\"line\">//设置显示</div><div class=\"line\">camera.setPreviewDisplay(holder);</div><div class=\"line\">&#125; catch (IOException exception) &#123;</div><div class=\"line\">camera.release();</div><div class=\"line\">camera = null;</div><div class=\"line\">&#125;</div><div class=\"line\">//开始预览</div><div class=\"line\">camera.startPreview();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">---</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t // 当Surface被创建的时候，该方法被调用，可以在这里实例化Camera对象  </div><div class=\"line\">\t         //同时可以对Camera进行定制  </div><div class=\"line\">\t         camera = Camera.open(); //获取Camera实例  </div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t  /** </div><div class=\"line\">\t          * Camera对象中含有一个内部类Camera.Parameters.该类可以对Camera的特性进行定制 </div><div class=\"line\">\t          * 在Parameters中设置完成后，需要调用Camera.setParameters()方法，相应的设置才会生效 </div><div class=\"line\">\t          * 由于不同的设备，Camera的特性是不同的，所以在设置时，需要首先判断设备对应的特性，再加以设置 </div><div class=\"line\">\t          * 比如在调用setEffects之前最好先调用getSupportedColorEffects。如果设备不支持颜色特性，那么该方法将 </div><div class=\"line\">\t          * 返回一个null </div><div class=\"line\">\t          */  </div><div class=\"line\">\t         try &#123;  </div><div class=\"line\">\t               </div><div class=\"line\">\t             Camera.Parameters param = camera.getParameters();  </div><div class=\"line\">\t             if(this.getResources().getConfiguration().orientation != Configuration.ORIENTATION_LANDSCAPE)&#123;  </div><div class=\"line\">\t                 //如果是竖屏  </div><div class=\"line\">\t                 param.set(&quot;orientation&quot;, &quot;portrait&quot;);  </div><div class=\"line\">\t                 //在2.2以上可以使用  </div><div class=\"line\">\t                 //camera.setDisplayOrientation(90);  </div><div class=\"line\">\t             &#125;else&#123;  </div><div class=\"line\">\t                 param.set(&quot;orientation&quot;, &quot;landscape&quot;);  </div><div class=\"line\">\t                //在2.2以上可以使用  </div><div class=\"line\">\t                 //camera.setDisplayOrientation(0);                </div><div class=\"line\">\t             &#125;  </div><div class=\"line\">\t             //首先获取系统设备支持的所有颜色特效，有复合我们的，则设置；否则不设置  </div><div class=\"line\">\t            List&lt;String&gt; colorEffects = param.getSupportedColorEffects();  </div><div class=\"line\">\t             Iterator&lt;String&gt; colorItor = colorEffects.iterator();  </div><div class=\"line\">\t             while(colorItor.hasNext())&#123;  </div><div class=\"line\">\t                 String currColor = colorItor.next();  </div><div class=\"line\">\t                 if(currColor.equals(Camera.Parameters.EFFECT_SOLARIZE))&#123;  </div><div class=\"line\">\t                     param.setColorEffect(Camera.Parameters.EFFECT_SOLARIZE);  </div><div class=\"line\">\t                     break;  </div><div class=\"line\">\t                &#125;  </div><div class=\"line\">\t             &#125;  </div><div class=\"line\">\t             //设置完成需要再次调用setParameter方法才能生效  </div><div class=\"line\">\t             camera.setParameters(param);  </div><div class=\"line\">\t               </div><div class=\"line\">\t            camera.setPreviewDisplay(holder);  </div><div class=\"line\">\t               </div><div class=\"line\">            /** </div><div class=\"line\">\t              * 在显示了预览后，我们有时候希望限制预览的Size </div><div class=\"line\">\t             * 我们并不是自己指定一个SIze而是指定一个Size，然后 </div><div class=\"line\">\t              * 获取系统支持的SIZE，然后选择一个比指定SIZE小且最接近所指定SIZE的一个 </div><div class=\"line\">\t              * Camera.Size对象就是该SIZE。 </div><div class=\"line\">\t             *  </div><div class=\"line\">\t            */  </div><div class=\"line\">\t             int bestWidth = 0;  </div><div class=\"line\">\t             int bestHeight = 0;  </div><div class=\"line\">\t               </div><div class=\"line\">\t             List&lt;Camera.Size&gt; sizeList = param.getSupportedPreviewSizes();  </div><div class=\"line\">\t             //如果sizeList只有一个我们也没有必要做什么了，因为就他一个别无选择  </div><div class=\"line\">\t             if(sizeList.size() &gt; 1)&#123;  </div><div class=\"line\">\t                 Iterator&lt;Camera.Size&gt; itor = sizeList.iterator();  </div><div class=\"line\">\t                 while(itor.hasNext())&#123;  </div><div class=\"line\">\t                     Camera.Size cur = itor.next();  </div><div class=\"line\">\t                     if(cur.width &gt; bestWidth &amp;&amp; cur.height&gt;bestHeight &amp;&amp; cur.width &lt;MAX_WIDTH &amp;&amp; cur.height &lt; MAX_HEIGHT)&#123;  </div><div class=\"line\">\t                         bestWidth = cur.width;  </div><div class=\"line\">\t                         bestHeight = cur.height;  </div><div class=\"line\">\t                    &#125;  </div><div class=\"line\">\t                 &#125;  </div><div class=\"line\">\t                 if(bestWidth != 0 &amp;&amp; bestHeight != 0)&#123;  </div><div class=\"line\">\t                     param.setPreviewSize(bestWidth, bestHeight);  </div><div class=\"line\">\t                    //这里改变了SIze后，我们还要告诉SurfaceView，否则，Surface将不会改变大小，进入Camera的图像将质量很差  </div><div class=\"line\">\t                    surfaceView.setLayoutParams(new LinearLayout.LayoutParams(bestWidth, bestHeight));  </div><div class=\"line\">\t                &#125;  </div><div class=\"line\">\t             &#125;  </div><div class=\"line\">\t             camera.setParameters(param);  </div><div class=\"line\">\t         &#125; catch (Exception e) &#123;  </div><div class=\"line\">\t             // 如果出现异常，则释放Camera对象  </div><div class=\"line\">\t             camera.release();  </div><div class=\"line\">\t         &#125;  </div><div class=\"line\">\t           </div><div class=\"line\">\t        //启动预览功能  </div><div class=\"line\">\t         camera.startPreview();  </div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t1.  // 当Surface被销毁的时候，该方法被调用  </div><div class=\"line\">\t2.         //在这里需要释放Camera资源  </div><div class=\"line\">\t3.         camera.stopPreview();  </div><div class=\"line\">\t4.         camera.release();  </div><div class=\"line\"></div><div class=\"line\">---</div><div class=\"line\"></div><div class=\"line\">5、假设要支持自动对焦功能，则在需要的情况下，或者在上述surfaceChanged调用完startPreview函数后，可以调用Camera::autoFocus函数来设置自动对焦回调函数，该步是可选操作，有些设备可能不支持，可以通过Camera::getFocusMode函数查询。代码可以参考如下：</div><div class=\"line\">// 自动对焦</div><div class=\"line\">camera.autoFocus(new AutoFocusCallback()</div><div class=\"line\">&#123;</div><div class=\"line\">@Override</div><div class=\"line\">public void onAutoFocus(boolean success, Camera camera)</div><div class=\"line\">&#123;</div><div class=\"line\">if (success)</div><div class=\"line\">&#123;</div><div class=\"line\">// success为true表示对焦成功，改变对焦状态图像</div><div class=\"line\">ivFocus.setImageResource(R.drawable.focus2);</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">6、在需要拍照的时候，调用takePicture(Camera.ShutterCallback, Camera.PictureCallback, Camera.PictureCallback, Camera.PictureCallback)函数来完成拍照，这个函数中可以四个回调接口，ShutterCallback是快门按下的回调，在这里我们可以设置播放“咔嚓”声之类的操作，后面有三个PictureCallback接口，分别对应三份图像数据，分别是原始图像、缩放和压缩图像和JPG图像，图像数据可以在PictureCallback接口的void onPictureTaken(byte[] data, Camera camera)中获得，三份数据相应的三个回调正好按照参数顺序调用，通常我们只关心JPG图像数据，此时前面两个PictureCallback接口参数可以直接传null；</div><div class=\"line\"></div><div class=\"line\">7、每次调用takePicture获取图像后，摄像头会停止预览，假如需要继续拍照，则我们需要在上面的PictureCallback的onPictureTaken函数末尾，再次掉哟更Camera::startPreview函数；</div><div class=\"line\"></div><div class=\"line\">8、在不需要拍照的时候，我们需要主动调用Camera::stopPreview函数停止预览功能，并且调用Camera::release函数释放Camera，以便其他应用程序调用。SDK中建议放在Activity的Pause函数中，但是我觉得放在surfaceDestroyed函数中更好，示例代码如下</div><div class=\"line\">// 停止拍照时调用该方法</div><div class=\"line\">public void surfaceDestroyed(SurfaceHolder holder)</div><div class=\"line\">&#123;</div><div class=\"line\">// 释放手机摄像头</div><div class=\"line\">camera.release();</div><div class=\"line\">&#125;</div><div class=\"line\">以上就是自己实现拍照程序的的流程，一般还可以还可以获取预览帧的图像数据，可以分别通过Camera::setPreviewCallback和Camera::setOneShotPreviewCallback来设置每帧或下一帧图像数据的回调，这里就不做展开了。</div><div class=\"line\"></div><div class=\"line\">---</div><div class=\"line\"></div><div class=\"line\">/** A safe way to get an instance of the Camera object. */</div><div class=\"line\">public static Camera getCameraInstance()&#123;</div><div class=\"line\">    Camera c = null;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        c = Camera.open(); // attempt to get a Camera instance</div><div class=\"line\">    &#125;</div><div class=\"line\">    catch (Exception e)&#123;</div><div class=\"line\">        // Camera is not available (in use or does not exist)</div><div class=\"line\">    &#125;</div><div class=\"line\">    return c; // returns null if camera is unavailable</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">---</div></pre></td></tr></table></figure>"},{"title":"View事件处理","toc":true,"_content":"- 基础知识\n\n```\n(1) 所有Touch事件都被封装成了MotionEvent对象，包括Touch的位置、时间、历史记录以及第几个手指(多指触摸)等。\n(2) 事件类型分为ACTION_DOWN, ACTION_UP, ACTION_MOVE, ACTION_POINTER_DOWN, ACTION_POINTER_UP, ACTION_CANCEL，每个事件都是以ACTION_DOWN开始ACTION_UP结束。\n(3) 对事件的处理包括三类，分别为传递——dispatchTouchEvent()函数、拦截——onInterceptTouchEvent()函数、消费——onTouchEvent()函数和OnTouchListener\n\n```\n\n\n- 传递流程\n\n```\n (1) 事件从Activity.dispatchTouchEvent()开始传递，只要没有被停止或拦截，从最上层的View(ViewGroup)开始一直往下(子View)传递。子View可以通过onTouchEvent()对事件进行处理。\n(2) 事件由父View(ViewGroup)传递给子View，ViewGroup可以通过onInterceptTouchEvent()对事件做拦截，停止其往下传递。\n(3) 如果事件从上往下传递过程中一直没有被停止，且最底层子View没有消费事件，事件会反向往上传递，这时父View(ViewGroup)可以进行消费，如果还是没有被消费的话，最后会到Activity的onTouchEvent()函数。\n(4) 如果View没有对ACTION_DOWN进行消费，之后的其他事件不会传递过来。\n(5) OnTouchListener优先于onTouchEvent()对事件进行消费。\n上面的消费即表示相应函数返回值为true。\n\n\n(01) View中的dispatchTouchEvent()会将事件传递给\"自己的onTouch()\", \"自己的onTouchEvent()\"进行处理。而且onTouch()的优先级比onTouchEvent()的优先级要高。 \n(02) onTouch()与onTouchEvent()都是View中用户处理触摸事件的API。onTouch是OnTouchListener接口中的函数，OnTouchListener接口需要用户自己实现。onTouchEvent()是View自带的接口，Android系统提供了默认的实现；当然，用户可以重载该API。\n(03) onTouch()与onTouchEvent()有两个不同之处：(01), onTouch()是View提供给用户，让用户自己处理触摸事件的接口。而onTouchEvent()是Android系统自己实现的接口。(02)，onTouch()的优先级比onTouchEvent()的优先级更高。dispatchTouchEvent()中分发事件的时候，会先将事件分配给onTouch()进行处理，然后才分配给onTouchEvent()进行处理。 如果onTouch()对触摸事件进行了处理，并且返回true；那么，该触摸事件就不会分配在分配给onTouchEvent()进行处理了。只有当onTouch()没有处理，或者处理了但返回false时，才会分配给onTouchEvent()进行处理。\n\n\n```\n<!-- more-->\n\n- view的事件传递机制 如何用伪代码来表示？\n\n```\n/**\n     * 对于一个root viewgroup来说，如果接受了一个点击事件，那么首先会调用他的dispatchTouchEvent方法。\n     * 如果这个viewgroup的onInterceptTouchEvent 返回true，那就代表要拦截这个事件。接下来这个事件就\n     * 给viewgroup自己处理了，从而viewgroup的onTouchEvent方法就会被调用。如果如果这个viewgroup的onInterceptTouchEvent\n     * 返回false就代表我不拦截这个事件，然后就把这个事件传递给自己的子元素，然后子元素的dispatchTouchEvent\n     * 就会被调用，就是这样一个循环直到 事件被处理。\n     *\n     */\npublic　boolean dispatchTouchEvent(MotionEvent ev)\n{\n    boolean consume=false;\n    if (onInterceptTouchEvent(ev)) {\n        consume=onTouchEvent(ev);\n    }else\n    {\n        consume=child.dispatchTouchEvent(ev);\n    }\n    return consume;\n}\n\n```\n- .view的onTouchEvent，OnClickListerner和OnTouchListener的onTouch方法 三者优先级如何？\n\n\n```\nonTouchListener优先级最高，如果onTouch方法返回 false ，那onTouchEvent就被调用了，返回true 就不会被调用。至于onClick 优先级最低。\n\n```\n- 点击事件的传递顺序如何？\n\n\n```\nActivity-Window-View。从上到下依次传递，当然了如果你最低的那个view onTouchEvent返回false 那就说明他不想处理 那就再往上抛，都不处理的话\n最终就还是让Activity自己处理了。举个例子，pm下发一个任务给leader，leader自己不做 给架构师a，小a也不做 给程序员b，b如果做了那就结束了这个任务。\n\nb如果发现自己搞不定，那就找a做，a要是也搞不定 就会不断向上发起请求，最终可能还是pm做。\n\n//activity的dispatchTouchEvent 方法 一开始就是交给window去处理的\n//win的superDispatchTouchEvent 返回true 那就直接结束了 这个函数了。返回false就意味\n//这事件没人处理，最终还是给activity的onTouchEvent 自己处理 这里的getwindow 其实就是phonewindow\n public boolean dispatchTouchEvent(MotionEvent ev) {\n        if (ev.getAction() == MotionEvent.ACTION_DOWN) {\n            onUserInteraction();\n        }\n        if (getWindow().superDispatchTouchEvent(ev)) {\n            return true;\n        }\n        return onTouchEvent(ev);\n    }\n\n\n//来看phonewindow的这个函数 直接把事件传递给了mDecor\n\n @Override\n    public boolean superDispatchTouchEvent(MotionEvent event) {\n        return mDecor.superDispatchTouchEvent(event);\n    }\n\n//devorview就是 我们的rootview了 就是那个framelayout 我们的setContentView里面传递的那个layout\n//就是这个decorview的 子view了\n     @Override\n    public final View getDecorView() {\n        if (mDecor == null) {\n            installDecor();\n        }\n        return mDecor;\n    }\n\n```\n\n- 事件分为几个步骤？\n\n```\n\ndown事件开头，up事件结尾，中间可能会有数目不定的move事件。\n\n```\n\n- ViewGroup如何对点击事件分发？\n\n```\n\nviewgroup就是在actionMasked == MotionEvent.ACTION_DOWN 和 mFirstTouchTarget != null 这两种情况来判断是否会进入拦截事件的流程\n\n看代码可以知道 如果是ACTION_DOWN事件  那就肯定进入 是否要拦截事件的流程\n\n如果不是ACTION_DOWN事件 那就要看mFirstTouchTarget != null 这个条件是否成立\n\n这个地方有点绕但是也好理解，其实就是 对于一个事件序列来说 down是事件的开头 所以肯定进入了这个事件是否拦截的流程 也就是if 括号内。\n\n\nmFirstTouchTarget其实是一个单链表结构他指向的是 成功处理事件的子元素。\n\n也就是说 如果有子元素成功处理了 事件，那这个值就不为NULL。反过来说\n\n只要viewgroup拦截了事件，mFirstTouchTarget就不为NULL，所以括号内就不会执行，也就侧面说明了一个结论：\n\n某个view 一旦决定拦截事件，那么这个事件所属的事件序列 都只能由他来执行。并且onInterceptTouchEvent 这个方法不会被调用了\n\n            final boolean intercepted;\n            if (actionMasked == MotionEvent.ACTION_DOWN\n                    || mFirstTouchTarget != null) {\n                final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;\n                if (!disallowIntercept) {\n                    intercepted = onInterceptTouchEvent(ev);\n                    ev.setAction(action); // restore action in case it was changed\n                } else {\n                    intercepted = false;\n                }\n            } else {\n                // There are no touch targets and this action is not an initial down\n                // so this view group continues to intercept touches.\n                intercepted = true;\n            }\n            \n```\n\n- .如果某个view 处理事件的时候 没有消耗down事件 会有什么结果？\n\n```\n \n 假如一个view，在down事件来的时候 他的onTouchEvent返回false， 那么这个down事件 所属的事件序列 就是他后续的move 和up 都不会给他处理了，全部都给他的父view处理。\n\n```\n- 如果view 不消耗move或者up事件 会有什么结果？\n\n```\n那这个事件所属的事件序列就消失了，父view也不会处理的，最终都给activity 去处理了。\n\n```\n\n- .ViewGroup 默认拦截事件吗？\n\n```\n默认不拦截任何事件，onInterceptTouchEvent返回的是false。\n\n```\n\n- .requestDisallowInterceptTouchEvent 可以在子元素中干扰父元素的事件分发吗？如果可以，是全部都可以干扰吗？\n\n```\n肯定可以，但是down事件干扰不了。\n\n```\n\n- dispatchTouchEvent每次都会被调用吗？\n\n```\n是的，onInterceptTouchEvent则不会。\n```\n\n- 滑动冲突问题如何解决 思路是什么？\n\n```\n要解决滑动冲突 其实最主要的就是有一个核心思想。你到底想在一个事件序列中，让哪个view 来响应你的滑动？比如 从上到下滑，是哪个view来处理这个事件，从左到右呢？\n\n用业务需求 来想明白以后 剩下的 其实就很好做了。核心的方法 就是2个 外部拦截也就是父亲拦截，另外就是内部拦截，也就是子view拦截法。 学会这2种 基本上所有的滑动冲突\n\n都是这2种的变种，而且核心代码思想都一样。\n\n外部拦截法：思路就是重写父容器的onInterceptTouchEvent即可。子元素一般不需要管。可以很容易理解，因为这和android自身的事件处理机制 逻辑是一模一样的\n\n@Override\n    public boolean onInterceptTouchEvent(MotionEvent ev) {\n\n        boolean intercepted = false;\n        int x = (int) ev.getX();\n        int y = (int) ev.getY();\n\n        switch (ev.getAction()) {\n            //down事件肯定不能拦截 拦截了后面的就收不到了\n            case MotionEvent.ACTION_DOWN:\n                intercepted = false;\n                break;\n            case MotionEvent.ACTION_MOVE:\n                if (你的业务需求) {\n                    //如果确定拦截了 就去自己的onTouchEvent里 处理拦截之后的操作和效果 即可了\n                    intercepted = true;\n                } else {\n                    intercepted = false;\n                }\n                break;\n            case MotionEvent.ACTION_UP:\n                //up事件 我们一般都是返回false的 一般父容器都不会拦截他。 因为up是事件的最后一步。这里返回true也没啥意义\n                //唯一的意义就是因为 父元素 up被拦截。导致子元素 收不到up事件，那子元素 就肯定没有onClick事件触发了，这里的\n                //小细节 要想明白\n                intercepted = false;\n                break;\n            default:\n                break;\n        }\n        return intercepted;\n    }\n\n内部拦截法：内部拦截法稍微复杂一点，就是事件到来的时候，父容器不管，让子元素自己来决定是否处理。如果消耗了 就最好，没消耗 自然就转给父容器处理了。\n\n子元素代码：\n\n@Override\n    public boolean dispatchTouchEvent(MotionEvent event) {\n        int x = (int) event.getX();\n        int y = (int) event.getY();\n        switch (event.getAction()) {\n            case MotionEvent.ACTION_DOWN:\n                getParent().requestDisallowInterceptTouchEvent(true);\n                break;\n            case MotionEvent.ACTION_MOVE:\n                if (如果父容器需要这个点击事件) {\n                    getParent().requestDisallowInterceptTouchEvent(false);\n                }//否则的话 就交给自己本身view的onTouchEvent自动处理了\n                break;\n            case MotionEvent.ACTION_UP:\n                break;\n            default:\n                break;\n        }\n        return super.dispatchTouchEvent(event);\n    }\n\n父亲容器代码也要修改一下，其实就是保证父亲别拦截down：\n\n@Override\n    public boolean onInterceptTouchEvent(MotionEvent ev) {\n\n        if (ev.getAction() == MotionEvent.ACTION_DOWN) {\n            return false;\n\n        }\n        return true;\n    }\n    \n```\n\n- 事件来源\n\n```\nInputEvent有2个子类：KeyEvent和MotionEvent，其中KeyEvent表示键盘事件，而MotionEvent表示点击事件\n\n```\n\n- 基于监听的事件监听器\n\n```\nView.OnClickListener    // 单击事件\nView.OnCreateContextMenuListener    // 创建上下文菜单事件\nView.OnFocusChangeListener    // 焦点改变事件\nView.OnKeyListener    // 按钮事件\nView.OnLongClickListener    // 长点击事件\nView.OnTouchListener    // 触摸屏事件\n\n```\n- 基于回调的事件处理\n\n```\n   boolean onKeyDown(int keyCode, KeyEvent event)    // 按下\nboolean onKeyLongPress(int keyCode, KeyEvent event)    // 长按\nboolean onKeyUp(int keyCode, KeyEvent event)    // 松开\nboolean onKeyShortcut(int keyCode, KeyEvent event)        // 键盘快捷键触发时\nboolean onTouchEvent(MotionEvent event)        // 触摸屏事件\n\n基于监听的事件处理更有优势：可维护性高、保证监听的事件监听器会被优先触发。\n基于回调的事件处理更适合于那些比较固定的View。\n\n    *事件传递*\n\n所有基于回调的事件处理的回调方法返回true，表明已处理完成，不会继续传递；返回false，表明未处理完成，该事件继续传递下去。\n\n当某个键被按下时候，Android最先触发的是该按键上绑定的事件监听器，然后触发该组件提供的事件回调方法，最后传递到该组件所在的Activity。\n\n---\n\n一种是委托式一种是回调式。第一种就是将事件的处理委托给监听器处理，你可以定义一个View.OnTouchListener接口的子类作为监听器，其中有onTouch()方法。而第二种是重写View类自己本身的onTouchEvent方法，也就是控件自己处理事件。onTouch方法接收一个MotionEvent参数和一个View参数，而onTouchEvent方法仅接收MotionEvent参数。这是因为监听器可以监听多个View控件的事件。无论是通过onTouchEvent还是onTouch方法 它们的返回值都是boolean类型。true的含义是如果当前处理程序在处理完毕该事件后不希望传播给其他控件，则返回true。如果View对象不但对此事件不感兴趣，而且对与此触摸序列相关的任何未来事件都不感兴趣，那么返回false。比如如果Button的onTouchEvent方法想要处理用户的一次点击 则会有2个事件产生ACTION_DOWN和ACTION_UP，按道理这两个事件都会调用onTouchEvent方法，如果方法返回false则在按下时你可以做一些操作，但是手指抬起时你将不能再接收到MotionEvent对象了，所以你也就无从处理抬起事件了。\n\n---\n```\n","source":"_posts/View事件处理.md","raw":"---\ntitle: View事件处理\ncategories: View\ntags: View\ntoc: true  \n---\n- 基础知识\n\n```\n(1) 所有Touch事件都被封装成了MotionEvent对象，包括Touch的位置、时间、历史记录以及第几个手指(多指触摸)等。\n(2) 事件类型分为ACTION_DOWN, ACTION_UP, ACTION_MOVE, ACTION_POINTER_DOWN, ACTION_POINTER_UP, ACTION_CANCEL，每个事件都是以ACTION_DOWN开始ACTION_UP结束。\n(3) 对事件的处理包括三类，分别为传递——dispatchTouchEvent()函数、拦截——onInterceptTouchEvent()函数、消费——onTouchEvent()函数和OnTouchListener\n\n```\n\n\n- 传递流程\n\n```\n (1) 事件从Activity.dispatchTouchEvent()开始传递，只要没有被停止或拦截，从最上层的View(ViewGroup)开始一直往下(子View)传递。子View可以通过onTouchEvent()对事件进行处理。\n(2) 事件由父View(ViewGroup)传递给子View，ViewGroup可以通过onInterceptTouchEvent()对事件做拦截，停止其往下传递。\n(3) 如果事件从上往下传递过程中一直没有被停止，且最底层子View没有消费事件，事件会反向往上传递，这时父View(ViewGroup)可以进行消费，如果还是没有被消费的话，最后会到Activity的onTouchEvent()函数。\n(4) 如果View没有对ACTION_DOWN进行消费，之后的其他事件不会传递过来。\n(5) OnTouchListener优先于onTouchEvent()对事件进行消费。\n上面的消费即表示相应函数返回值为true。\n\n\n(01) View中的dispatchTouchEvent()会将事件传递给\"自己的onTouch()\", \"自己的onTouchEvent()\"进行处理。而且onTouch()的优先级比onTouchEvent()的优先级要高。 \n(02) onTouch()与onTouchEvent()都是View中用户处理触摸事件的API。onTouch是OnTouchListener接口中的函数，OnTouchListener接口需要用户自己实现。onTouchEvent()是View自带的接口，Android系统提供了默认的实现；当然，用户可以重载该API。\n(03) onTouch()与onTouchEvent()有两个不同之处：(01), onTouch()是View提供给用户，让用户自己处理触摸事件的接口。而onTouchEvent()是Android系统自己实现的接口。(02)，onTouch()的优先级比onTouchEvent()的优先级更高。dispatchTouchEvent()中分发事件的时候，会先将事件分配给onTouch()进行处理，然后才分配给onTouchEvent()进行处理。 如果onTouch()对触摸事件进行了处理，并且返回true；那么，该触摸事件就不会分配在分配给onTouchEvent()进行处理了。只有当onTouch()没有处理，或者处理了但返回false时，才会分配给onTouchEvent()进行处理。\n\n\n```\n<!-- more-->\n\n- view的事件传递机制 如何用伪代码来表示？\n\n```\n/**\n     * 对于一个root viewgroup来说，如果接受了一个点击事件，那么首先会调用他的dispatchTouchEvent方法。\n     * 如果这个viewgroup的onInterceptTouchEvent 返回true，那就代表要拦截这个事件。接下来这个事件就\n     * 给viewgroup自己处理了，从而viewgroup的onTouchEvent方法就会被调用。如果如果这个viewgroup的onInterceptTouchEvent\n     * 返回false就代表我不拦截这个事件，然后就把这个事件传递给自己的子元素，然后子元素的dispatchTouchEvent\n     * 就会被调用，就是这样一个循环直到 事件被处理。\n     *\n     */\npublic　boolean dispatchTouchEvent(MotionEvent ev)\n{\n    boolean consume=false;\n    if (onInterceptTouchEvent(ev)) {\n        consume=onTouchEvent(ev);\n    }else\n    {\n        consume=child.dispatchTouchEvent(ev);\n    }\n    return consume;\n}\n\n```\n- .view的onTouchEvent，OnClickListerner和OnTouchListener的onTouch方法 三者优先级如何？\n\n\n```\nonTouchListener优先级最高，如果onTouch方法返回 false ，那onTouchEvent就被调用了，返回true 就不会被调用。至于onClick 优先级最低。\n\n```\n- 点击事件的传递顺序如何？\n\n\n```\nActivity-Window-View。从上到下依次传递，当然了如果你最低的那个view onTouchEvent返回false 那就说明他不想处理 那就再往上抛，都不处理的话\n最终就还是让Activity自己处理了。举个例子，pm下发一个任务给leader，leader自己不做 给架构师a，小a也不做 给程序员b，b如果做了那就结束了这个任务。\n\nb如果发现自己搞不定，那就找a做，a要是也搞不定 就会不断向上发起请求，最终可能还是pm做。\n\n//activity的dispatchTouchEvent 方法 一开始就是交给window去处理的\n//win的superDispatchTouchEvent 返回true 那就直接结束了 这个函数了。返回false就意味\n//这事件没人处理，最终还是给activity的onTouchEvent 自己处理 这里的getwindow 其实就是phonewindow\n public boolean dispatchTouchEvent(MotionEvent ev) {\n        if (ev.getAction() == MotionEvent.ACTION_DOWN) {\n            onUserInteraction();\n        }\n        if (getWindow().superDispatchTouchEvent(ev)) {\n            return true;\n        }\n        return onTouchEvent(ev);\n    }\n\n\n//来看phonewindow的这个函数 直接把事件传递给了mDecor\n\n @Override\n    public boolean superDispatchTouchEvent(MotionEvent event) {\n        return mDecor.superDispatchTouchEvent(event);\n    }\n\n//devorview就是 我们的rootview了 就是那个framelayout 我们的setContentView里面传递的那个layout\n//就是这个decorview的 子view了\n     @Override\n    public final View getDecorView() {\n        if (mDecor == null) {\n            installDecor();\n        }\n        return mDecor;\n    }\n\n```\n\n- 事件分为几个步骤？\n\n```\n\ndown事件开头，up事件结尾，中间可能会有数目不定的move事件。\n\n```\n\n- ViewGroup如何对点击事件分发？\n\n```\n\nviewgroup就是在actionMasked == MotionEvent.ACTION_DOWN 和 mFirstTouchTarget != null 这两种情况来判断是否会进入拦截事件的流程\n\n看代码可以知道 如果是ACTION_DOWN事件  那就肯定进入 是否要拦截事件的流程\n\n如果不是ACTION_DOWN事件 那就要看mFirstTouchTarget != null 这个条件是否成立\n\n这个地方有点绕但是也好理解，其实就是 对于一个事件序列来说 down是事件的开头 所以肯定进入了这个事件是否拦截的流程 也就是if 括号内。\n\n\nmFirstTouchTarget其实是一个单链表结构他指向的是 成功处理事件的子元素。\n\n也就是说 如果有子元素成功处理了 事件，那这个值就不为NULL。反过来说\n\n只要viewgroup拦截了事件，mFirstTouchTarget就不为NULL，所以括号内就不会执行，也就侧面说明了一个结论：\n\n某个view 一旦决定拦截事件，那么这个事件所属的事件序列 都只能由他来执行。并且onInterceptTouchEvent 这个方法不会被调用了\n\n            final boolean intercepted;\n            if (actionMasked == MotionEvent.ACTION_DOWN\n                    || mFirstTouchTarget != null) {\n                final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;\n                if (!disallowIntercept) {\n                    intercepted = onInterceptTouchEvent(ev);\n                    ev.setAction(action); // restore action in case it was changed\n                } else {\n                    intercepted = false;\n                }\n            } else {\n                // There are no touch targets and this action is not an initial down\n                // so this view group continues to intercept touches.\n                intercepted = true;\n            }\n            \n```\n\n- .如果某个view 处理事件的时候 没有消耗down事件 会有什么结果？\n\n```\n \n 假如一个view，在down事件来的时候 他的onTouchEvent返回false， 那么这个down事件 所属的事件序列 就是他后续的move 和up 都不会给他处理了，全部都给他的父view处理。\n\n```\n- 如果view 不消耗move或者up事件 会有什么结果？\n\n```\n那这个事件所属的事件序列就消失了，父view也不会处理的，最终都给activity 去处理了。\n\n```\n\n- .ViewGroup 默认拦截事件吗？\n\n```\n默认不拦截任何事件，onInterceptTouchEvent返回的是false。\n\n```\n\n- .requestDisallowInterceptTouchEvent 可以在子元素中干扰父元素的事件分发吗？如果可以，是全部都可以干扰吗？\n\n```\n肯定可以，但是down事件干扰不了。\n\n```\n\n- dispatchTouchEvent每次都会被调用吗？\n\n```\n是的，onInterceptTouchEvent则不会。\n```\n\n- 滑动冲突问题如何解决 思路是什么？\n\n```\n要解决滑动冲突 其实最主要的就是有一个核心思想。你到底想在一个事件序列中，让哪个view 来响应你的滑动？比如 从上到下滑，是哪个view来处理这个事件，从左到右呢？\n\n用业务需求 来想明白以后 剩下的 其实就很好做了。核心的方法 就是2个 外部拦截也就是父亲拦截，另外就是内部拦截，也就是子view拦截法。 学会这2种 基本上所有的滑动冲突\n\n都是这2种的变种，而且核心代码思想都一样。\n\n外部拦截法：思路就是重写父容器的onInterceptTouchEvent即可。子元素一般不需要管。可以很容易理解，因为这和android自身的事件处理机制 逻辑是一模一样的\n\n@Override\n    public boolean onInterceptTouchEvent(MotionEvent ev) {\n\n        boolean intercepted = false;\n        int x = (int) ev.getX();\n        int y = (int) ev.getY();\n\n        switch (ev.getAction()) {\n            //down事件肯定不能拦截 拦截了后面的就收不到了\n            case MotionEvent.ACTION_DOWN:\n                intercepted = false;\n                break;\n            case MotionEvent.ACTION_MOVE:\n                if (你的业务需求) {\n                    //如果确定拦截了 就去自己的onTouchEvent里 处理拦截之后的操作和效果 即可了\n                    intercepted = true;\n                } else {\n                    intercepted = false;\n                }\n                break;\n            case MotionEvent.ACTION_UP:\n                //up事件 我们一般都是返回false的 一般父容器都不会拦截他。 因为up是事件的最后一步。这里返回true也没啥意义\n                //唯一的意义就是因为 父元素 up被拦截。导致子元素 收不到up事件，那子元素 就肯定没有onClick事件触发了，这里的\n                //小细节 要想明白\n                intercepted = false;\n                break;\n            default:\n                break;\n        }\n        return intercepted;\n    }\n\n内部拦截法：内部拦截法稍微复杂一点，就是事件到来的时候，父容器不管，让子元素自己来决定是否处理。如果消耗了 就最好，没消耗 自然就转给父容器处理了。\n\n子元素代码：\n\n@Override\n    public boolean dispatchTouchEvent(MotionEvent event) {\n        int x = (int) event.getX();\n        int y = (int) event.getY();\n        switch (event.getAction()) {\n            case MotionEvent.ACTION_DOWN:\n                getParent().requestDisallowInterceptTouchEvent(true);\n                break;\n            case MotionEvent.ACTION_MOVE:\n                if (如果父容器需要这个点击事件) {\n                    getParent().requestDisallowInterceptTouchEvent(false);\n                }//否则的话 就交给自己本身view的onTouchEvent自动处理了\n                break;\n            case MotionEvent.ACTION_UP:\n                break;\n            default:\n                break;\n        }\n        return super.dispatchTouchEvent(event);\n    }\n\n父亲容器代码也要修改一下，其实就是保证父亲别拦截down：\n\n@Override\n    public boolean onInterceptTouchEvent(MotionEvent ev) {\n\n        if (ev.getAction() == MotionEvent.ACTION_DOWN) {\n            return false;\n\n        }\n        return true;\n    }\n    \n```\n\n- 事件来源\n\n```\nInputEvent有2个子类：KeyEvent和MotionEvent，其中KeyEvent表示键盘事件，而MotionEvent表示点击事件\n\n```\n\n- 基于监听的事件监听器\n\n```\nView.OnClickListener    // 单击事件\nView.OnCreateContextMenuListener    // 创建上下文菜单事件\nView.OnFocusChangeListener    // 焦点改变事件\nView.OnKeyListener    // 按钮事件\nView.OnLongClickListener    // 长点击事件\nView.OnTouchListener    // 触摸屏事件\n\n```\n- 基于回调的事件处理\n\n```\n   boolean onKeyDown(int keyCode, KeyEvent event)    // 按下\nboolean onKeyLongPress(int keyCode, KeyEvent event)    // 长按\nboolean onKeyUp(int keyCode, KeyEvent event)    // 松开\nboolean onKeyShortcut(int keyCode, KeyEvent event)        // 键盘快捷键触发时\nboolean onTouchEvent(MotionEvent event)        // 触摸屏事件\n\n基于监听的事件处理更有优势：可维护性高、保证监听的事件监听器会被优先触发。\n基于回调的事件处理更适合于那些比较固定的View。\n\n    *事件传递*\n\n所有基于回调的事件处理的回调方法返回true，表明已处理完成，不会继续传递；返回false，表明未处理完成，该事件继续传递下去。\n\n当某个键被按下时候，Android最先触发的是该按键上绑定的事件监听器，然后触发该组件提供的事件回调方法，最后传递到该组件所在的Activity。\n\n---\n\n一种是委托式一种是回调式。第一种就是将事件的处理委托给监听器处理，你可以定义一个View.OnTouchListener接口的子类作为监听器，其中有onTouch()方法。而第二种是重写View类自己本身的onTouchEvent方法，也就是控件自己处理事件。onTouch方法接收一个MotionEvent参数和一个View参数，而onTouchEvent方法仅接收MotionEvent参数。这是因为监听器可以监听多个View控件的事件。无论是通过onTouchEvent还是onTouch方法 它们的返回值都是boolean类型。true的含义是如果当前处理程序在处理完毕该事件后不希望传播给其他控件，则返回true。如果View对象不但对此事件不感兴趣，而且对与此触摸序列相关的任何未来事件都不感兴趣，那么返回false。比如如果Button的onTouchEvent方法想要处理用户的一次点击 则会有2个事件产生ACTION_DOWN和ACTION_UP，按道理这两个事件都会调用onTouchEvent方法，如果方法返回false则在按下时你可以做一些操作，但是手指抬起时你将不能再接收到MotionEvent对象了，所以你也就无从处理抬起事件了。\n\n---\n```\n","slug":"View事件处理","published":1,"date":"2016-11-27T07:32:19.000Z","updated":"2016-11-27T07:32:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjecoc8hz000cfuv1j5c8g9mz","content":"<ul>\n<li>基础知识</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">(1) 所有Touch事件都被封装成了MotionEvent对象，包括Touch的位置、时间、历史记录以及第几个手指(多指触摸)等。</div><div class=\"line\">(2) 事件类型分为ACTION_DOWN, ACTION_UP, ACTION_MOVE, ACTION_POINTER_DOWN, ACTION_POINTER_UP, ACTION_CANCEL，每个事件都是以ACTION_DOWN开始ACTION_UP结束。</div><div class=\"line\">(3) 对事件的处理包括三类，分别为传递——dispatchTouchEvent()函数、拦截——onInterceptTouchEvent()函数、消费——onTouchEvent()函数和OnTouchListener</div></pre></td></tr></table></figure>\n<ul>\n<li>传递流程</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"> (1) 事件从Activity.dispatchTouchEvent()开始传递，只要没有被停止或拦截，从最上层的View(ViewGroup)开始一直往下(子View)传递。子View可以通过onTouchEvent()对事件进行处理。</div><div class=\"line\">(2) 事件由父View(ViewGroup)传递给子View，ViewGroup可以通过onInterceptTouchEvent()对事件做拦截，停止其往下传递。</div><div class=\"line\">(3) 如果事件从上往下传递过程中一直没有被停止，且最底层子View没有消费事件，事件会反向往上传递，这时父View(ViewGroup)可以进行消费，如果还是没有被消费的话，最后会到Activity的onTouchEvent()函数。</div><div class=\"line\">(4) 如果View没有对ACTION_DOWN进行消费，之后的其他事件不会传递过来。</div><div class=\"line\">(5) OnTouchListener优先于onTouchEvent()对事件进行消费。</div><div class=\"line\">上面的消费即表示相应函数返回值为true。</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">(01) View中的dispatchTouchEvent()会将事件传递给&quot;自己的onTouch()&quot;, &quot;自己的onTouchEvent()&quot;进行处理。而且onTouch()的优先级比onTouchEvent()的优先级要高。 </div><div class=\"line\">(02) onTouch()与onTouchEvent()都是View中用户处理触摸事件的API。onTouch是OnTouchListener接口中的函数，OnTouchListener接口需要用户自己实现。onTouchEvent()是View自带的接口，Android系统提供了默认的实现；当然，用户可以重载该API。</div><div class=\"line\">(03) onTouch()与onTouchEvent()有两个不同之处：(01), onTouch()是View提供给用户，让用户自己处理触摸事件的接口。而onTouchEvent()是Android系统自己实现的接口。(02)，onTouch()的优先级比onTouchEvent()的优先级更高。dispatchTouchEvent()中分发事件的时候，会先将事件分配给onTouch()进行处理，然后才分配给onTouchEvent()进行处理。 如果onTouch()对触摸事件进行了处理，并且返回true；那么，该触摸事件就不会分配在分配给onTouchEvent()进行处理了。只有当onTouch()没有处理，或者处理了但返回false时，才会分配给onTouchEvent()进行处理。</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<ul>\n<li>view的事件传递机制 如何用伪代码来表示？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">     * 对于一个root viewgroup来说，如果接受了一个点击事件，那么首先会调用他的dispatchTouchEvent方法。</div><div class=\"line\">     * 如果这个viewgroup的onInterceptTouchEvent 返回true，那就代表要拦截这个事件。接下来这个事件就</div><div class=\"line\">     * 给viewgroup自己处理了，从而viewgroup的onTouchEvent方法就会被调用。如果如果这个viewgroup的onInterceptTouchEvent</div><div class=\"line\">     * 返回false就代表我不拦截这个事件，然后就把这个事件传递给自己的子元素，然后子元素的dispatchTouchEvent</div><div class=\"line\">     * 就会被调用，就是这样一个循环直到 事件被处理。</div><div class=\"line\">     *</div><div class=\"line\">     */</div><div class=\"line\">public　boolean dispatchTouchEvent(MotionEvent ev)</div><div class=\"line\">&#123;</div><div class=\"line\">    boolean consume=false;</div><div class=\"line\">    if (onInterceptTouchEvent(ev)) &#123;</div><div class=\"line\">        consume=onTouchEvent(ev);</div><div class=\"line\">    &#125;else</div><div class=\"line\">    &#123;</div><div class=\"line\">        consume=child.dispatchTouchEvent(ev);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return consume;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>.view的onTouchEvent，OnClickListerner和OnTouchListener的onTouch方法 三者优先级如何？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">onTouchListener优先级最高，如果onTouch方法返回 false ，那onTouchEvent就被调用了，返回true 就不会被调用。至于onClick 优先级最低。</div></pre></td></tr></table></figure>\n<ul>\n<li>点击事件的传递顺序如何？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">Activity-Window-View。从上到下依次传递，当然了如果你最低的那个view onTouchEvent返回false 那就说明他不想处理 那就再往上抛，都不处理的话</div><div class=\"line\">最终就还是让Activity自己处理了。举个例子，pm下发一个任务给leader，leader自己不做 给架构师a，小a也不做 给程序员b，b如果做了那就结束了这个任务。</div><div class=\"line\"></div><div class=\"line\">b如果发现自己搞不定，那就找a做，a要是也搞不定 就会不断向上发起请求，最终可能还是pm做。</div><div class=\"line\"></div><div class=\"line\">//activity的dispatchTouchEvent 方法 一开始就是交给window去处理的</div><div class=\"line\">//win的superDispatchTouchEvent 返回true 那就直接结束了 这个函数了。返回false就意味</div><div class=\"line\">//这事件没人处理，最终还是给activity的onTouchEvent 自己处理 这里的getwindow 其实就是phonewindow</div><div class=\"line\"> public boolean dispatchTouchEvent(MotionEvent ev) &#123;</div><div class=\"line\">        if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</div><div class=\"line\">            onUserInteraction();</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (getWindow().superDispatchTouchEvent(ev)) &#123;</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return onTouchEvent(ev);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//来看phonewindow的这个函数 直接把事件传递给了mDecor</div><div class=\"line\"></div><div class=\"line\"> @Override</div><div class=\"line\">    public boolean superDispatchTouchEvent(MotionEvent event) &#123;</div><div class=\"line\">        return mDecor.superDispatchTouchEvent(event);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">//devorview就是 我们的rootview了 就是那个framelayout 我们的setContentView里面传递的那个layout</div><div class=\"line\">//就是这个decorview的 子view了</div><div class=\"line\">     @Override</div><div class=\"line\">    public final View getDecorView() &#123;</div><div class=\"line\">        if (mDecor == null) &#123;</div><div class=\"line\">            installDecor();</div><div class=\"line\">        &#125;</div><div class=\"line\">        return mDecor;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>事件分为几个步骤？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">down事件开头，up事件结尾，中间可能会有数目不定的move事件。</div></pre></td></tr></table></figure>\n<ul>\n<li>ViewGroup如何对点击事件分发？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">viewgroup就是在actionMasked == MotionEvent.ACTION_DOWN 和 mFirstTouchTarget != null 这两种情况来判断是否会进入拦截事件的流程</div><div class=\"line\"></div><div class=\"line\">看代码可以知道 如果是ACTION_DOWN事件  那就肯定进入 是否要拦截事件的流程</div><div class=\"line\"></div><div class=\"line\">如果不是ACTION_DOWN事件 那就要看mFirstTouchTarget != null 这个条件是否成立</div><div class=\"line\"></div><div class=\"line\">这个地方有点绕但是也好理解，其实就是 对于一个事件序列来说 down是事件的开头 所以肯定进入了这个事件是否拦截的流程 也就是if 括号内。</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">mFirstTouchTarget其实是一个单链表结构他指向的是 成功处理事件的子元素。</div><div class=\"line\"></div><div class=\"line\">也就是说 如果有子元素成功处理了 事件，那这个值就不为NULL。反过来说</div><div class=\"line\"></div><div class=\"line\">只要viewgroup拦截了事件，mFirstTouchTarget就不为NULL，所以括号内就不会执行，也就侧面说明了一个结论：</div><div class=\"line\"></div><div class=\"line\">某个view 一旦决定拦截事件，那么这个事件所属的事件序列 都只能由他来执行。并且onInterceptTouchEvent 这个方法不会被调用了</div><div class=\"line\"></div><div class=\"line\">            final boolean intercepted;</div><div class=\"line\">            if (actionMasked == MotionEvent.ACTION_DOWN</div><div class=\"line\">                    || mFirstTouchTarget != null) &#123;</div><div class=\"line\">                final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;</div><div class=\"line\">                if (!disallowIntercept) &#123;</div><div class=\"line\">                    intercepted = onInterceptTouchEvent(ev);</div><div class=\"line\">                    ev.setAction(action); // restore action in case it was changed</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    intercepted = false;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // There are no touch targets and this action is not an initial down</div><div class=\"line\">                // so this view group continues to intercept touches.</div><div class=\"line\">                intercepted = true;</div><div class=\"line\">            &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>.如果某个view 处理事件的时候 没有消耗down事件 会有什么结果？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">假如一个view，在down事件来的时候 他的onTouchEvent返回false， 那么这个down事件 所属的事件序列 就是他后续的move 和up 都不会给他处理了，全部都给他的父view处理。</div></pre></td></tr></table></figure>\n<ul>\n<li>如果view 不消耗move或者up事件 会有什么结果？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">那这个事件所属的事件序列就消失了，父view也不会处理的，最终都给activity 去处理了。</div></pre></td></tr></table></figure>\n<ul>\n<li>.ViewGroup 默认拦截事件吗？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">默认不拦截任何事件，onInterceptTouchEvent返回的是false。</div></pre></td></tr></table></figure>\n<ul>\n<li>.requestDisallowInterceptTouchEvent 可以在子元素中干扰父元素的事件分发吗？如果可以，是全部都可以干扰吗？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">肯定可以，但是down事件干扰不了。</div></pre></td></tr></table></figure>\n<ul>\n<li>dispatchTouchEvent每次都会被调用吗？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">是的，onInterceptTouchEvent则不会。</div></pre></td></tr></table></figure>\n<ul>\n<li>滑动冲突问题如何解决 思路是什么？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div></pre></td><td class=\"code\"><pre><div class=\"line\">要解决滑动冲突 其实最主要的就是有一个核心思想。你到底想在一个事件序列中，让哪个view 来响应你的滑动？比如 从上到下滑，是哪个view来处理这个事件，从左到右呢？</div><div class=\"line\"></div><div class=\"line\">用业务需求 来想明白以后 剩下的 其实就很好做了。核心的方法 就是2个 外部拦截也就是父亲拦截，另外就是内部拦截，也就是子view拦截法。 学会这2种 基本上所有的滑动冲突</div><div class=\"line\"></div><div class=\"line\">都是这2种的变种，而且核心代码思想都一样。</div><div class=\"line\"></div><div class=\"line\">外部拦截法：思路就是重写父容器的onInterceptTouchEvent即可。子元素一般不需要管。可以很容易理解，因为这和android自身的事件处理机制 逻辑是一模一样的</div><div class=\"line\"></div><div class=\"line\">@Override</div><div class=\"line\">    public boolean onInterceptTouchEvent(MotionEvent ev) &#123;</div><div class=\"line\"></div><div class=\"line\">        boolean intercepted = false;</div><div class=\"line\">        int x = (int) ev.getX();</div><div class=\"line\">        int y = (int) ev.getY();</div><div class=\"line\"></div><div class=\"line\">        switch (ev.getAction()) &#123;</div><div class=\"line\">            //down事件肯定不能拦截 拦截了后面的就收不到了</div><div class=\"line\">            case MotionEvent.ACTION_DOWN:</div><div class=\"line\">                intercepted = false;</div><div class=\"line\">                break;</div><div class=\"line\">            case MotionEvent.ACTION_MOVE:</div><div class=\"line\">                if (你的业务需求) &#123;</div><div class=\"line\">                    //如果确定拦截了 就去自己的onTouchEvent里 处理拦截之后的操作和效果 即可了</div><div class=\"line\">                    intercepted = true;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    intercepted = false;</div><div class=\"line\">                &#125;</div><div class=\"line\">                break;</div><div class=\"line\">            case MotionEvent.ACTION_UP:</div><div class=\"line\">                //up事件 我们一般都是返回false的 一般父容器都不会拦截他。 因为up是事件的最后一步。这里返回true也没啥意义</div><div class=\"line\">                //唯一的意义就是因为 父元素 up被拦截。导致子元素 收不到up事件，那子元素 就肯定没有onClick事件触发了，这里的</div><div class=\"line\">                //小细节 要想明白</div><div class=\"line\">                intercepted = false;</div><div class=\"line\">                break;</div><div class=\"line\">            default:</div><div class=\"line\">                break;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return intercepted;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">内部拦截法：内部拦截法稍微复杂一点，就是事件到来的时候，父容器不管，让子元素自己来决定是否处理。如果消耗了 就最好，没消耗 自然就转给父容器处理了。</div><div class=\"line\"></div><div class=\"line\">子元素代码：</div><div class=\"line\"></div><div class=\"line\">@Override</div><div class=\"line\">    public boolean dispatchTouchEvent(MotionEvent event) &#123;</div><div class=\"line\">        int x = (int) event.getX();</div><div class=\"line\">        int y = (int) event.getY();</div><div class=\"line\">        switch (event.getAction()) &#123;</div><div class=\"line\">            case MotionEvent.ACTION_DOWN:</div><div class=\"line\">                getParent().requestDisallowInterceptTouchEvent(true);</div><div class=\"line\">                break;</div><div class=\"line\">            case MotionEvent.ACTION_MOVE:</div><div class=\"line\">                if (如果父容器需要这个点击事件) &#123;</div><div class=\"line\">                    getParent().requestDisallowInterceptTouchEvent(false);</div><div class=\"line\">                &#125;//否则的话 就交给自己本身view的onTouchEvent自动处理了</div><div class=\"line\">                break;</div><div class=\"line\">            case MotionEvent.ACTION_UP:</div><div class=\"line\">                break;</div><div class=\"line\">            default:</div><div class=\"line\">                break;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return super.dispatchTouchEvent(event);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">父亲容器代码也要修改一下，其实就是保证父亲别拦截down：</div><div class=\"line\"></div><div class=\"line\">@Override</div><div class=\"line\">    public boolean onInterceptTouchEvent(MotionEvent ev) &#123;</div><div class=\"line\"></div><div class=\"line\">        if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</div><div class=\"line\">            return false;</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>事件来源</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">InputEvent有2个子类：KeyEvent和MotionEvent，其中KeyEvent表示键盘事件，而MotionEvent表示点击事件</div></pre></td></tr></table></figure>\n<ul>\n<li>基于监听的事件监听器</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">View.OnClickListener    // 单击事件</div><div class=\"line\">View.OnCreateContextMenuListener    // 创建上下文菜单事件</div><div class=\"line\">View.OnFocusChangeListener    // 焦点改变事件</div><div class=\"line\">View.OnKeyListener    // 按钮事件</div><div class=\"line\">View.OnLongClickListener    // 长点击事件</div><div class=\"line\">View.OnTouchListener    // 触摸屏事件</div></pre></td></tr></table></figure>\n<ul>\n<li>基于回调的事件处理</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">   boolean onKeyDown(int keyCode, KeyEvent event)    // 按下</div><div class=\"line\">boolean onKeyLongPress(int keyCode, KeyEvent event)    // 长按</div><div class=\"line\">boolean onKeyUp(int keyCode, KeyEvent event)    // 松开</div><div class=\"line\">boolean onKeyShortcut(int keyCode, KeyEvent event)        // 键盘快捷键触发时</div><div class=\"line\">boolean onTouchEvent(MotionEvent event)        // 触摸屏事件</div><div class=\"line\"></div><div class=\"line\">基于监听的事件处理更有优势：可维护性高、保证监听的事件监听器会被优先触发。</div><div class=\"line\">基于回调的事件处理更适合于那些比较固定的View。</div><div class=\"line\"></div><div class=\"line\">    *事件传递*</div><div class=\"line\"></div><div class=\"line\">所有基于回调的事件处理的回调方法返回true，表明已处理完成，不会继续传递；返回false，表明未处理完成，该事件继续传递下去。</div><div class=\"line\"></div><div class=\"line\">当某个键被按下时候，Android最先触发的是该按键上绑定的事件监听器，然后触发该组件提供的事件回调方法，最后传递到该组件所在的Activity。</div><div class=\"line\"></div><div class=\"line\">---</div><div class=\"line\"></div><div class=\"line\">一种是委托式一种是回调式。第一种就是将事件的处理委托给监听器处理，你可以定义一个View.OnTouchListener接口的子类作为监听器，其中有onTouch()方法。而第二种是重写View类自己本身的onTouchEvent方法，也就是控件自己处理事件。onTouch方法接收一个MotionEvent参数和一个View参数，而onTouchEvent方法仅接收MotionEvent参数。这是因为监听器可以监听多个View控件的事件。无论是通过onTouchEvent还是onTouch方法 它们的返回值都是boolean类型。true的含义是如果当前处理程序在处理完毕该事件后不希望传播给其他控件，则返回true。如果View对象不但对此事件不感兴趣，而且对与此触摸序列相关的任何未来事件都不感兴趣，那么返回false。比如如果Button的onTouchEvent方法想要处理用户的一次点击 则会有2个事件产生ACTION_DOWN和ACTION_UP，按道理这两个事件都会调用onTouchEvent方法，如果方法返回false则在按下时你可以做一些操作，但是手指抬起时你将不能再接收到MotionEvent对象了，所以你也就无从处理抬起事件了。</div><div class=\"line\"></div><div class=\"line\">---</div></pre></td></tr></table></figure>\n","excerpt":"<ul>\n<li>基础知识</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">(1) 所有Touch事件都被封装成了MotionEvent对象，包括Touch的位置、时间、历史记录以及第几个手指(多指触摸)等。</div><div class=\"line\">(2) 事件类型分为ACTION_DOWN, ACTION_UP, ACTION_MOVE, ACTION_POINTER_DOWN, ACTION_POINTER_UP, ACTION_CANCEL，每个事件都是以ACTION_DOWN开始ACTION_UP结束。</div><div class=\"line\">(3) 对事件的处理包括三类，分别为传递——dispatchTouchEvent()函数、拦截——onInterceptTouchEvent()函数、消费——onTouchEvent()函数和OnTouchListener</div></pre></td></tr></table></figure>\n<ul>\n<li>传递流程</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"> (1) 事件从Activity.dispatchTouchEvent()开始传递，只要没有被停止或拦截，从最上层的View(ViewGroup)开始一直往下(子View)传递。子View可以通过onTouchEvent()对事件进行处理。</div><div class=\"line\">(2) 事件由父View(ViewGroup)传递给子View，ViewGroup可以通过onInterceptTouchEvent()对事件做拦截，停止其往下传递。</div><div class=\"line\">(3) 如果事件从上往下传递过程中一直没有被停止，且最底层子View没有消费事件，事件会反向往上传递，这时父View(ViewGroup)可以进行消费，如果还是没有被消费的话，最后会到Activity的onTouchEvent()函数。</div><div class=\"line\">(4) 如果View没有对ACTION_DOWN进行消费，之后的其他事件不会传递过来。</div><div class=\"line\">(5) OnTouchListener优先于onTouchEvent()对事件进行消费。</div><div class=\"line\">上面的消费即表示相应函数返回值为true。</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">(01) View中的dispatchTouchEvent()会将事件传递给&quot;自己的onTouch()&quot;, &quot;自己的onTouchEvent()&quot;进行处理。而且onTouch()的优先级比onTouchEvent()的优先级要高。 </div><div class=\"line\">(02) onTouch()与onTouchEvent()都是View中用户处理触摸事件的API。onTouch是OnTouchListener接口中的函数，OnTouchListener接口需要用户自己实现。onTouchEvent()是View自带的接口，Android系统提供了默认的实现；当然，用户可以重载该API。</div><div class=\"line\">(03) onTouch()与onTouchEvent()有两个不同之处：(01), onTouch()是View提供给用户，让用户自己处理触摸事件的接口。而onTouchEvent()是Android系统自己实现的接口。(02)，onTouch()的优先级比onTouchEvent()的优先级更高。dispatchTouchEvent()中分发事件的时候，会先将事件分配给onTouch()进行处理，然后才分配给onTouchEvent()进行处理。 如果onTouch()对触摸事件进行了处理，并且返回true；那么，该触摸事件就不会分配在分配给onTouchEvent()进行处理了。只有当onTouch()没有处理，或者处理了但返回false时，才会分配给onTouchEvent()进行处理。</div></pre></td></tr></table></figure>","more":"<ul>\n<li>view的事件传递机制 如何用伪代码来表示？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">     * 对于一个root viewgroup来说，如果接受了一个点击事件，那么首先会调用他的dispatchTouchEvent方法。</div><div class=\"line\">     * 如果这个viewgroup的onInterceptTouchEvent 返回true，那就代表要拦截这个事件。接下来这个事件就</div><div class=\"line\">     * 给viewgroup自己处理了，从而viewgroup的onTouchEvent方法就会被调用。如果如果这个viewgroup的onInterceptTouchEvent</div><div class=\"line\">     * 返回false就代表我不拦截这个事件，然后就把这个事件传递给自己的子元素，然后子元素的dispatchTouchEvent</div><div class=\"line\">     * 就会被调用，就是这样一个循环直到 事件被处理。</div><div class=\"line\">     *</div><div class=\"line\">     */</div><div class=\"line\">public　boolean dispatchTouchEvent(MotionEvent ev)</div><div class=\"line\">&#123;</div><div class=\"line\">    boolean consume=false;</div><div class=\"line\">    if (onInterceptTouchEvent(ev)) &#123;</div><div class=\"line\">        consume=onTouchEvent(ev);</div><div class=\"line\">    &#125;else</div><div class=\"line\">    &#123;</div><div class=\"line\">        consume=child.dispatchTouchEvent(ev);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return consume;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>.view的onTouchEvent，OnClickListerner和OnTouchListener的onTouch方法 三者优先级如何？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">onTouchListener优先级最高，如果onTouch方法返回 false ，那onTouchEvent就被调用了，返回true 就不会被调用。至于onClick 优先级最低。</div></pre></td></tr></table></figure>\n<ul>\n<li>点击事件的传递顺序如何？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">Activity-Window-View。从上到下依次传递，当然了如果你最低的那个view onTouchEvent返回false 那就说明他不想处理 那就再往上抛，都不处理的话</div><div class=\"line\">最终就还是让Activity自己处理了。举个例子，pm下发一个任务给leader，leader自己不做 给架构师a，小a也不做 给程序员b，b如果做了那就结束了这个任务。</div><div class=\"line\"></div><div class=\"line\">b如果发现自己搞不定，那就找a做，a要是也搞不定 就会不断向上发起请求，最终可能还是pm做。</div><div class=\"line\"></div><div class=\"line\">//activity的dispatchTouchEvent 方法 一开始就是交给window去处理的</div><div class=\"line\">//win的superDispatchTouchEvent 返回true 那就直接结束了 这个函数了。返回false就意味</div><div class=\"line\">//这事件没人处理，最终还是给activity的onTouchEvent 自己处理 这里的getwindow 其实就是phonewindow</div><div class=\"line\"> public boolean dispatchTouchEvent(MotionEvent ev) &#123;</div><div class=\"line\">        if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</div><div class=\"line\">            onUserInteraction();</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (getWindow().superDispatchTouchEvent(ev)) &#123;</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return onTouchEvent(ev);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//来看phonewindow的这个函数 直接把事件传递给了mDecor</div><div class=\"line\"></div><div class=\"line\"> @Override</div><div class=\"line\">    public boolean superDispatchTouchEvent(MotionEvent event) &#123;</div><div class=\"line\">        return mDecor.superDispatchTouchEvent(event);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">//devorview就是 我们的rootview了 就是那个framelayout 我们的setContentView里面传递的那个layout</div><div class=\"line\">//就是这个decorview的 子view了</div><div class=\"line\">     @Override</div><div class=\"line\">    public final View getDecorView() &#123;</div><div class=\"line\">        if (mDecor == null) &#123;</div><div class=\"line\">            installDecor();</div><div class=\"line\">        &#125;</div><div class=\"line\">        return mDecor;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>事件分为几个步骤？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">down事件开头，up事件结尾，中间可能会有数目不定的move事件。</div></pre></td></tr></table></figure>\n<ul>\n<li>ViewGroup如何对点击事件分发？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">viewgroup就是在actionMasked == MotionEvent.ACTION_DOWN 和 mFirstTouchTarget != null 这两种情况来判断是否会进入拦截事件的流程</div><div class=\"line\"></div><div class=\"line\">看代码可以知道 如果是ACTION_DOWN事件  那就肯定进入 是否要拦截事件的流程</div><div class=\"line\"></div><div class=\"line\">如果不是ACTION_DOWN事件 那就要看mFirstTouchTarget != null 这个条件是否成立</div><div class=\"line\"></div><div class=\"line\">这个地方有点绕但是也好理解，其实就是 对于一个事件序列来说 down是事件的开头 所以肯定进入了这个事件是否拦截的流程 也就是if 括号内。</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">mFirstTouchTarget其实是一个单链表结构他指向的是 成功处理事件的子元素。</div><div class=\"line\"></div><div class=\"line\">也就是说 如果有子元素成功处理了 事件，那这个值就不为NULL。反过来说</div><div class=\"line\"></div><div class=\"line\">只要viewgroup拦截了事件，mFirstTouchTarget就不为NULL，所以括号内就不会执行，也就侧面说明了一个结论：</div><div class=\"line\"></div><div class=\"line\">某个view 一旦决定拦截事件，那么这个事件所属的事件序列 都只能由他来执行。并且onInterceptTouchEvent 这个方法不会被调用了</div><div class=\"line\"></div><div class=\"line\">            final boolean intercepted;</div><div class=\"line\">            if (actionMasked == MotionEvent.ACTION_DOWN</div><div class=\"line\">                    || mFirstTouchTarget != null) &#123;</div><div class=\"line\">                final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;</div><div class=\"line\">                if (!disallowIntercept) &#123;</div><div class=\"line\">                    intercepted = onInterceptTouchEvent(ev);</div><div class=\"line\">                    ev.setAction(action); // restore action in case it was changed</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    intercepted = false;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // There are no touch targets and this action is not an initial down</div><div class=\"line\">                // so this view group continues to intercept touches.</div><div class=\"line\">                intercepted = true;</div><div class=\"line\">            &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>.如果某个view 处理事件的时候 没有消耗down事件 会有什么结果？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">假如一个view，在down事件来的时候 他的onTouchEvent返回false， 那么这个down事件 所属的事件序列 就是他后续的move 和up 都不会给他处理了，全部都给他的父view处理。</div></pre></td></tr></table></figure>\n<ul>\n<li>如果view 不消耗move或者up事件 会有什么结果？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">那这个事件所属的事件序列就消失了，父view也不会处理的，最终都给activity 去处理了。</div></pre></td></tr></table></figure>\n<ul>\n<li>.ViewGroup 默认拦截事件吗？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">默认不拦截任何事件，onInterceptTouchEvent返回的是false。</div></pre></td></tr></table></figure>\n<ul>\n<li>.requestDisallowInterceptTouchEvent 可以在子元素中干扰父元素的事件分发吗？如果可以，是全部都可以干扰吗？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">肯定可以，但是down事件干扰不了。</div></pre></td></tr></table></figure>\n<ul>\n<li>dispatchTouchEvent每次都会被调用吗？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">是的，onInterceptTouchEvent则不会。</div></pre></td></tr></table></figure>\n<ul>\n<li>滑动冲突问题如何解决 思路是什么？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div></pre></td><td class=\"code\"><pre><div class=\"line\">要解决滑动冲突 其实最主要的就是有一个核心思想。你到底想在一个事件序列中，让哪个view 来响应你的滑动？比如 从上到下滑，是哪个view来处理这个事件，从左到右呢？</div><div class=\"line\"></div><div class=\"line\">用业务需求 来想明白以后 剩下的 其实就很好做了。核心的方法 就是2个 外部拦截也就是父亲拦截，另外就是内部拦截，也就是子view拦截法。 学会这2种 基本上所有的滑动冲突</div><div class=\"line\"></div><div class=\"line\">都是这2种的变种，而且核心代码思想都一样。</div><div class=\"line\"></div><div class=\"line\">外部拦截法：思路就是重写父容器的onInterceptTouchEvent即可。子元素一般不需要管。可以很容易理解，因为这和android自身的事件处理机制 逻辑是一模一样的</div><div class=\"line\"></div><div class=\"line\">@Override</div><div class=\"line\">    public boolean onInterceptTouchEvent(MotionEvent ev) &#123;</div><div class=\"line\"></div><div class=\"line\">        boolean intercepted = false;</div><div class=\"line\">        int x = (int) ev.getX();</div><div class=\"line\">        int y = (int) ev.getY();</div><div class=\"line\"></div><div class=\"line\">        switch (ev.getAction()) &#123;</div><div class=\"line\">            //down事件肯定不能拦截 拦截了后面的就收不到了</div><div class=\"line\">            case MotionEvent.ACTION_DOWN:</div><div class=\"line\">                intercepted = false;</div><div class=\"line\">                break;</div><div class=\"line\">            case MotionEvent.ACTION_MOVE:</div><div class=\"line\">                if (你的业务需求) &#123;</div><div class=\"line\">                    //如果确定拦截了 就去自己的onTouchEvent里 处理拦截之后的操作和效果 即可了</div><div class=\"line\">                    intercepted = true;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    intercepted = false;</div><div class=\"line\">                &#125;</div><div class=\"line\">                break;</div><div class=\"line\">            case MotionEvent.ACTION_UP:</div><div class=\"line\">                //up事件 我们一般都是返回false的 一般父容器都不会拦截他。 因为up是事件的最后一步。这里返回true也没啥意义</div><div class=\"line\">                //唯一的意义就是因为 父元素 up被拦截。导致子元素 收不到up事件，那子元素 就肯定没有onClick事件触发了，这里的</div><div class=\"line\">                //小细节 要想明白</div><div class=\"line\">                intercepted = false;</div><div class=\"line\">                break;</div><div class=\"line\">            default:</div><div class=\"line\">                break;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return intercepted;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">内部拦截法：内部拦截法稍微复杂一点，就是事件到来的时候，父容器不管，让子元素自己来决定是否处理。如果消耗了 就最好，没消耗 自然就转给父容器处理了。</div><div class=\"line\"></div><div class=\"line\">子元素代码：</div><div class=\"line\"></div><div class=\"line\">@Override</div><div class=\"line\">    public boolean dispatchTouchEvent(MotionEvent event) &#123;</div><div class=\"line\">        int x = (int) event.getX();</div><div class=\"line\">        int y = (int) event.getY();</div><div class=\"line\">        switch (event.getAction()) &#123;</div><div class=\"line\">            case MotionEvent.ACTION_DOWN:</div><div class=\"line\">                getParent().requestDisallowInterceptTouchEvent(true);</div><div class=\"line\">                break;</div><div class=\"line\">            case MotionEvent.ACTION_MOVE:</div><div class=\"line\">                if (如果父容器需要这个点击事件) &#123;</div><div class=\"line\">                    getParent().requestDisallowInterceptTouchEvent(false);</div><div class=\"line\">                &#125;//否则的话 就交给自己本身view的onTouchEvent自动处理了</div><div class=\"line\">                break;</div><div class=\"line\">            case MotionEvent.ACTION_UP:</div><div class=\"line\">                break;</div><div class=\"line\">            default:</div><div class=\"line\">                break;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return super.dispatchTouchEvent(event);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">父亲容器代码也要修改一下，其实就是保证父亲别拦截down：</div><div class=\"line\"></div><div class=\"line\">@Override</div><div class=\"line\">    public boolean onInterceptTouchEvent(MotionEvent ev) &#123;</div><div class=\"line\"></div><div class=\"line\">        if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</div><div class=\"line\">            return false;</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>事件来源</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">InputEvent有2个子类：KeyEvent和MotionEvent，其中KeyEvent表示键盘事件，而MotionEvent表示点击事件</div></pre></td></tr></table></figure>\n<ul>\n<li>基于监听的事件监听器</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">View.OnClickListener    // 单击事件</div><div class=\"line\">View.OnCreateContextMenuListener    // 创建上下文菜单事件</div><div class=\"line\">View.OnFocusChangeListener    // 焦点改变事件</div><div class=\"line\">View.OnKeyListener    // 按钮事件</div><div class=\"line\">View.OnLongClickListener    // 长点击事件</div><div class=\"line\">View.OnTouchListener    // 触摸屏事件</div></pre></td></tr></table></figure>\n<ul>\n<li>基于回调的事件处理</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">   boolean onKeyDown(int keyCode, KeyEvent event)    // 按下</div><div class=\"line\">boolean onKeyLongPress(int keyCode, KeyEvent event)    // 长按</div><div class=\"line\">boolean onKeyUp(int keyCode, KeyEvent event)    // 松开</div><div class=\"line\">boolean onKeyShortcut(int keyCode, KeyEvent event)        // 键盘快捷键触发时</div><div class=\"line\">boolean onTouchEvent(MotionEvent event)        // 触摸屏事件</div><div class=\"line\"></div><div class=\"line\">基于监听的事件处理更有优势：可维护性高、保证监听的事件监听器会被优先触发。</div><div class=\"line\">基于回调的事件处理更适合于那些比较固定的View。</div><div class=\"line\"></div><div class=\"line\">    *事件传递*</div><div class=\"line\"></div><div class=\"line\">所有基于回调的事件处理的回调方法返回true，表明已处理完成，不会继续传递；返回false，表明未处理完成，该事件继续传递下去。</div><div class=\"line\"></div><div class=\"line\">当某个键被按下时候，Android最先触发的是该按键上绑定的事件监听器，然后触发该组件提供的事件回调方法，最后传递到该组件所在的Activity。</div><div class=\"line\"></div><div class=\"line\">---</div><div class=\"line\"></div><div class=\"line\">一种是委托式一种是回调式。第一种就是将事件的处理委托给监听器处理，你可以定义一个View.OnTouchListener接口的子类作为监听器，其中有onTouch()方法。而第二种是重写View类自己本身的onTouchEvent方法，也就是控件自己处理事件。onTouch方法接收一个MotionEvent参数和一个View参数，而onTouchEvent方法仅接收MotionEvent参数。这是因为监听器可以监听多个View控件的事件。无论是通过onTouchEvent还是onTouch方法 它们的返回值都是boolean类型。true的含义是如果当前处理程序在处理完毕该事件后不希望传播给其他控件，则返回true。如果View对象不但对此事件不感兴趣，而且对与此触摸序列相关的任何未来事件都不感兴趣，那么返回false。比如如果Button的onTouchEvent方法想要处理用户的一次点击 则会有2个事件产生ACTION_DOWN和ACTION_UP，按道理这两个事件都会调用onTouchEvent方法，如果方法返回false则在按下时你可以做一些操作，但是手指抬起时你将不能再接收到MotionEvent对象了，所以你也就无从处理抬起事件了。</div><div class=\"line\"></div><div class=\"line\">---</div></pre></td></tr></table></figure>"},{"title":"自定义View的疑问","date":"2016-05-30T12:02:50.000Z","toc":true,"_content":"- invalidate()方法 ：\n\n`   说明：请求重绘View树，即draw()过程，假如视图发生大小没有变化就不会调用layout()过程，并且只绘制那些“需要重绘的”\n视图，即谁(View的话，只绘制该View ；ViewGroup，则绘制整个ViewGroup)请求invalidate()方法，就绘制该视图。\n \n   一般引起invalidate()操作的函数如下：\n   1、直接调用invalidate()方法，请求重新draw()，但只会绘制调用者本身。\n   \n   2、setSelection()方法 ：请求重新draw()，但只会绘制调用者本身。\n   \n   3、setVisibility()方法 ： 当View可视状态在INVISIBLE转换VISIBLE时，会间接调用invalidate()方法 继而绘制该View。\n  \n   4 、setEnabled()方法 ： 请求重新draw()，但不会重新绘制任何视图包括该调用者本身。`\n\n<!-- more-->\n\n- requestLayout()方法 \n\n\n \n`：会导致调用measure()过程 和 layout()过程 。\n \n说明：只是对View树重新布局layout过程包括measure()和layout()过程，不会调用draw()过程，但不会重新绘制\n\n任何视图包括该调用者本身。\n \n 一般引起invalidate()操作的函数如下：\n 1、setVisibility()方法：\n 当View的可视状态在INVISIBLE/ VISIBLE 转换为GONE状态时，会间接调用requestLayout() 和invalidate方法。\n 同时，由于整个个View树大小发生了变化，会请求measure()过程以及draw()过程，同样地，只绘制需要“重新绘制”的视图。`\n    \n \n-  requestFocus()函数说明：\n```\n          说明：请求View树的draw()过程，但只绘制“需要重绘”的视图。\n```\n- View的坐标参数 主要有哪些？分别有什么注意的要点？\n\n```\n Left，Right，top,Bottom 注意这4个值其实就是 view 和 他的父控件的 相对坐标值。 并非是距离屏幕左上角的绝对值，这点要注意。\n　\n　此外，X和Y 其实也是相对于父控件的坐标值。 TranslationX,TranslationY 这2个值 默认都为0，是相对于父控件的左上角的偏移量。\n　\n　换算关系：\n　\n　x=left+tranX,y=top+tranY.\n　 \n  很多人不理解，为什么事这样，其实就是View 如果有移动的话，比如平移这种，你们就要注意了，top和left 这种值 是不会变化的。\n   \n   无论你把view怎么拖动，但是 x,y,tranX,tranY 的值是随着拖动平移 而变化的。想明白这点 就行了。\n   \n```\n- onTouchEvent和GestureDetector 在什么时候用哪个比较好\n\n```\n只有滑动需求的时候 就用前者，如果有双击等这种行为的时候 就用后者。\n\n```\n- .Scroller 用来解决什么问题？\n\n```\nview的scrollTo和scrollBy 滑动效果太差了，是瞬间完成。而scroller可以配合view的computeScroll 来完成 渐变的滑动效果。体验更好。\n\n```\n- ScrollTo和ScrollBy 有什么需要注意的？\n\n```\n前者是绝对滑动，后者是相对滑动。滑动的是view的内容 而不是view本身。这很重要。比如textview 调用这2个方法  滑动的就是显示出来的字的内容。\n\n一般而言 我们用scrollBy会比较多一些。传值的话 其实 记住几个法则就可以了。 右-左 x为正 否则x为负  上-下 y为负，否则y为正。\n\n可以稍微看一下 这2个的源码：\npublic void scrollTo(int x, int y) {\n        if (mScrollX != x || mScrollY != y) {\n            int oldX = mScrollX;\n            int oldY = mScrollY;\n            mScrollX = x;\n            mScrollY = y;\n            invalidateParentCaches();\n            onScrollChanged(mScrollX, mScrollY, oldX, oldY);\n            if (!awakenScrollBars()) {\n                postInvalidateOnAnimation();\n            }\n        }\n    }\n\n public void scrollBy(int x, int y) {\n        scrollTo(mScrollX + x, mScrollY + y);\n    }\n\n看到里面有2个变量 mScrollX 和mScrollY 这2个东西没，这2个单位的 值是像素，前者代表 view的左边缘和view内容左边缘的距离。 后者代表 view上边缘和view内容上边缘的距离。\n\n```\n- 让view滑动总共有几种方式，分别要注意什么？都适用于那些场景？\n\n```\n总共有三种：\n\na：scrollto，scrollby。这种是最简单的，但是只能滑动view的内容 不可以滑动view本身。\n\nb：动画。动画可以滑动view内容，但是注意非属性动画 就如我们问题5说的内容 会影响到交互，使用的时候要多注意。不过多数复杂的滑动效果都是属性动画来完成的，属于大杀器级别、\n\nc：改变布局参数。这种最好理解了，无非是动态的通过java代码来修改 margin等view的参数罢了。不过用的比较少。我本人不怎么用这种方法。\n\n```\n- .Scroller是干嘛的？原理是什么？\n\n```\n```\n\n- getWidth()与getMeasuredWidth()`有什么区别呢？ \n\n```\n一般情况下这两个的值是相同的，`getMeasureWidth()`方法在`measure()`过程结束后就可以获取到了，而`getWidth()`方法要在`layout()`过程结束后才能获取到。\n而且`getMeasureWidth()`的值是通过`setMeasuredDimension()`设置的，但是`getWidth()`的值是通过视图右边的坐标减去左边的坐标计算出来的。如果我们在`layout`的时候将宽高\n不传`getMeasureWidth`的值，那么这时候`getWidth()`与`getMeasuredWidth`的值就不会再相同了，当然一般也不会这么干...\n\n```\n\n","source":"_posts/自定义View的疑问.md","raw":"---\ntitle: 自定义View的疑问\ndate: 2016-05-30 20:02:50\ntags: View\ncategories: View\ntoc: true \n---\n- invalidate()方法 ：\n\n`   说明：请求重绘View树，即draw()过程，假如视图发生大小没有变化就不会调用layout()过程，并且只绘制那些“需要重绘的”\n视图，即谁(View的话，只绘制该View ；ViewGroup，则绘制整个ViewGroup)请求invalidate()方法，就绘制该视图。\n \n   一般引起invalidate()操作的函数如下：\n   1、直接调用invalidate()方法，请求重新draw()，但只会绘制调用者本身。\n   \n   2、setSelection()方法 ：请求重新draw()，但只会绘制调用者本身。\n   \n   3、setVisibility()方法 ： 当View可视状态在INVISIBLE转换VISIBLE时，会间接调用invalidate()方法 继而绘制该View。\n  \n   4 、setEnabled()方法 ： 请求重新draw()，但不会重新绘制任何视图包括该调用者本身。`\n\n<!-- more-->\n\n- requestLayout()方法 \n\n\n \n`：会导致调用measure()过程 和 layout()过程 。\n \n说明：只是对View树重新布局layout过程包括measure()和layout()过程，不会调用draw()过程，但不会重新绘制\n\n任何视图包括该调用者本身。\n \n 一般引起invalidate()操作的函数如下：\n 1、setVisibility()方法：\n 当View的可视状态在INVISIBLE/ VISIBLE 转换为GONE状态时，会间接调用requestLayout() 和invalidate方法。\n 同时，由于整个个View树大小发生了变化，会请求measure()过程以及draw()过程，同样地，只绘制需要“重新绘制”的视图。`\n    \n \n-  requestFocus()函数说明：\n```\n          说明：请求View树的draw()过程，但只绘制“需要重绘”的视图。\n```\n- View的坐标参数 主要有哪些？分别有什么注意的要点？\n\n```\n Left，Right，top,Bottom 注意这4个值其实就是 view 和 他的父控件的 相对坐标值。 并非是距离屏幕左上角的绝对值，这点要注意。\n　\n　此外，X和Y 其实也是相对于父控件的坐标值。 TranslationX,TranslationY 这2个值 默认都为0，是相对于父控件的左上角的偏移量。\n　\n　换算关系：\n　\n　x=left+tranX,y=top+tranY.\n　 \n  很多人不理解，为什么事这样，其实就是View 如果有移动的话，比如平移这种，你们就要注意了，top和left 这种值 是不会变化的。\n   \n   无论你把view怎么拖动，但是 x,y,tranX,tranY 的值是随着拖动平移 而变化的。想明白这点 就行了。\n   \n```\n- onTouchEvent和GestureDetector 在什么时候用哪个比较好\n\n```\n只有滑动需求的时候 就用前者，如果有双击等这种行为的时候 就用后者。\n\n```\n- .Scroller 用来解决什么问题？\n\n```\nview的scrollTo和scrollBy 滑动效果太差了，是瞬间完成。而scroller可以配合view的computeScroll 来完成 渐变的滑动效果。体验更好。\n\n```\n- ScrollTo和ScrollBy 有什么需要注意的？\n\n```\n前者是绝对滑动，后者是相对滑动。滑动的是view的内容 而不是view本身。这很重要。比如textview 调用这2个方法  滑动的就是显示出来的字的内容。\n\n一般而言 我们用scrollBy会比较多一些。传值的话 其实 记住几个法则就可以了。 右-左 x为正 否则x为负  上-下 y为负，否则y为正。\n\n可以稍微看一下 这2个的源码：\npublic void scrollTo(int x, int y) {\n        if (mScrollX != x || mScrollY != y) {\n            int oldX = mScrollX;\n            int oldY = mScrollY;\n            mScrollX = x;\n            mScrollY = y;\n            invalidateParentCaches();\n            onScrollChanged(mScrollX, mScrollY, oldX, oldY);\n            if (!awakenScrollBars()) {\n                postInvalidateOnAnimation();\n            }\n        }\n    }\n\n public void scrollBy(int x, int y) {\n        scrollTo(mScrollX + x, mScrollY + y);\n    }\n\n看到里面有2个变量 mScrollX 和mScrollY 这2个东西没，这2个单位的 值是像素，前者代表 view的左边缘和view内容左边缘的距离。 后者代表 view上边缘和view内容上边缘的距离。\n\n```\n- 让view滑动总共有几种方式，分别要注意什么？都适用于那些场景？\n\n```\n总共有三种：\n\na：scrollto，scrollby。这种是最简单的，但是只能滑动view的内容 不可以滑动view本身。\n\nb：动画。动画可以滑动view内容，但是注意非属性动画 就如我们问题5说的内容 会影响到交互，使用的时候要多注意。不过多数复杂的滑动效果都是属性动画来完成的，属于大杀器级别、\n\nc：改变布局参数。这种最好理解了，无非是动态的通过java代码来修改 margin等view的参数罢了。不过用的比较少。我本人不怎么用这种方法。\n\n```\n- .Scroller是干嘛的？原理是什么？\n\n```\n```\n\n- getWidth()与getMeasuredWidth()`有什么区别呢？ \n\n```\n一般情况下这两个的值是相同的，`getMeasureWidth()`方法在`measure()`过程结束后就可以获取到了，而`getWidth()`方法要在`layout()`过程结束后才能获取到。\n而且`getMeasureWidth()`的值是通过`setMeasuredDimension()`设置的，但是`getWidth()`的值是通过视图右边的坐标减去左边的坐标计算出来的。如果我们在`layout`的时候将宽高\n不传`getMeasureWidth`的值，那么这时候`getWidth()`与`getMeasuredWidth`的值就不会再相同了，当然一般也不会这么干...\n\n```\n\n","slug":"自定义View的疑问","published":1,"updated":"2016-11-27T07:32:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjecoc8i2000gfuv1zxnwigrc","content":"<ul>\n<li>invalidate()方法 ：</li>\n</ul>\n<p>`   说明：请求重绘View树，即draw()过程，假如视图发生大小没有变化就不会调用layout()过程，并且只绘制那些“需要重绘的”<br>视图，即谁(View的话，只绘制该View ；ViewGroup，则绘制整个ViewGroup)请求invalidate()方法，就绘制该视图。</p>\n<p>   一般引起invalidate()操作的函数如下：<br>   1、直接调用invalidate()方法，请求重新draw()，但只会绘制调用者本身。</p>\n<p>   2、setSelection()方法 ：请求重新draw()，但只会绘制调用者本身。</p>\n<p>   3、setVisibility()方法 ： 当View可视状态在INVISIBLE转换VISIBLE时，会间接调用invalidate()方法 继而绘制该View。</p>\n<p>   4 、setEnabled()方法 ： 请求重新draw()，但不会重新绘制任何视图包括该调用者本身。`</p>\n<a id=\"more\"></a>\n<ul>\n<li>requestLayout()方法 </li>\n</ul>\n<p>`：会导致调用measure()过程 和 layout()过程 。</p>\n<p>说明：只是对View树重新布局layout过程包括measure()和layout()过程，不会调用draw()过程，但不会重新绘制</p>\n<p>任何视图包括该调用者本身。</p>\n<p> 一般引起invalidate()操作的函数如下：<br> 1、setVisibility()方法：<br> 当View的可视状态在INVISIBLE/ VISIBLE 转换为GONE状态时，会间接调用requestLayout() 和invalidate方法。<br> 同时，由于整个个View树大小发生了变化，会请求measure()过程以及draw()过程，同样地，只绘制需要“重新绘制”的视图。`</p>\n<ul>\n<li><p>requestFocus()函数说明：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">说明：请求View树的draw()过程，但只绘制“需要重绘”的视图。</div></pre></td></tr></table></figure>\n</li>\n<li><p>View的坐标参数 主要有哪些？分别有什么注意的要点？</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">Left，Right，top,Bottom 注意这4个值其实就是 view 和 他的父控件的 相对坐标值。 并非是距离屏幕左上角的绝对值，这点要注意。</div><div class=\"line\">　</div><div class=\"line\">　此外，X和Y 其实也是相对于父控件的坐标值。 TranslationX,TranslationY 这2个值 默认都为0，是相对于父控件的左上角的偏移量。</div><div class=\"line\">　</div><div class=\"line\">　换算关系：</div><div class=\"line\">　</div><div class=\"line\">　x=left+tranX,y=top+tranY.</div><div class=\"line\">　 </div><div class=\"line\"> 很多人不理解，为什么事这样，其实就是View 如果有移动的话，比如平移这种，你们就要注意了，top和left 这种值 是不会变化的。</div><div class=\"line\">  </div><div class=\"line\">  无论你把view怎么拖动，但是 x,y,tranX,tranY 的值是随着拖动平移 而变化的。想明白这点 就行了。</div></pre></td></tr></table></figure>\n<ul>\n<li>onTouchEvent和GestureDetector 在什么时候用哪个比较好</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">只有滑动需求的时候 就用前者，如果有双击等这种行为的时候 就用后者。</div></pre></td></tr></table></figure>\n<ul>\n<li>.Scroller 用来解决什么问题？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">view的scrollTo和scrollBy 滑动效果太差了，是瞬间完成。而scroller可以配合view的computeScroll 来完成 渐变的滑动效果。体验更好。</div></pre></td></tr></table></figure>\n<ul>\n<li>ScrollTo和ScrollBy 有什么需要注意的？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">前者是绝对滑动，后者是相对滑动。滑动的是view的内容 而不是view本身。这很重要。比如textview 调用这2个方法  滑动的就是显示出来的字的内容。</div><div class=\"line\"></div><div class=\"line\">一般而言 我们用scrollBy会比较多一些。传值的话 其实 记住几个法则就可以了。 右-左 x为正 否则x为负  上-下 y为负，否则y为正。</div><div class=\"line\"></div><div class=\"line\">可以稍微看一下 这2个的源码：</div><div class=\"line\">public void scrollTo(int x, int y) &#123;</div><div class=\"line\">        if (mScrollX != x || mScrollY != y) &#123;</div><div class=\"line\">            int oldX = mScrollX;</div><div class=\"line\">            int oldY = mScrollY;</div><div class=\"line\">            mScrollX = x;</div><div class=\"line\">            mScrollY = y;</div><div class=\"line\">            invalidateParentCaches();</div><div class=\"line\">            onScrollChanged(mScrollX, mScrollY, oldX, oldY);</div><div class=\"line\">            if (!awakenScrollBars()) &#123;</div><div class=\"line\">                postInvalidateOnAnimation();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"> public void scrollBy(int x, int y) &#123;</div><div class=\"line\">        scrollTo(mScrollX + x, mScrollY + y);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">看到里面有2个变量 mScrollX 和mScrollY 这2个东西没，这2个单位的 值是像素，前者代表 view的左边缘和view内容左边缘的距离。 后者代表 view上边缘和view内容上边缘的距离。</div></pre></td></tr></table></figure>\n<ul>\n<li>让view滑动总共有几种方式，分别要注意什么？都适用于那些场景？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">总共有三种：</div><div class=\"line\"></div><div class=\"line\">a：scrollto，scrollby。这种是最简单的，但是只能滑动view的内容 不可以滑动view本身。</div><div class=\"line\"></div><div class=\"line\">b：动画。动画可以滑动view内容，但是注意非属性动画 就如我们问题5说的内容 会影响到交互，使用的时候要多注意。不过多数复杂的滑动效果都是属性动画来完成的，属于大杀器级别、</div><div class=\"line\"></div><div class=\"line\">c：改变布局参数。这种最好理解了，无非是动态的通过java代码来修改 margin等view的参数罢了。不过用的比较少。我本人不怎么用这种方法。</div></pre></td></tr></table></figure>\n<ul>\n<li>.Scroller是干嘛的？原理是什么？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">```</div><div class=\"line\"></div><div class=\"line\">- getWidth()与getMeasuredWidth()`有什么区别呢？</div></pre></td></tr></table></figure>\n<p>一般情况下这两个的值是相同的，<code>getMeasureWidth()</code>方法在<code>measure()</code>过程结束后就可以获取到了，而<code>getWidth()</code>方法要在<code>layout()</code>过程结束后才能获取到。<br>而且<code>getMeasureWidth()</code>的值是通过<code>setMeasuredDimension()</code>设置的，但是<code>getWidth()</code>的值是通过视图右边的坐标减去左边的坐标计算出来的。如果我们在<code>layout</code>的时候将宽高<br>不传<code>getMeasureWidth</code>的值，那么这时候<code>getWidth()</code>与<code>getMeasuredWidth</code>的值就不会再相同了，当然一般也不会这么干…</p>\n<p>```</p>\n","excerpt":"<ul>\n<li>invalidate()方法 ：</li>\n</ul>\n<p>`   说明：请求重绘View树，即draw()过程，假如视图发生大小没有变化就不会调用layout()过程，并且只绘制那些“需要重绘的”<br>视图，即谁(View的话，只绘制该View ；ViewGroup，则绘制整个ViewGroup)请求invalidate()方法，就绘制该视图。</p>\n<p>   一般引起invalidate()操作的函数如下：<br>   1、直接调用invalidate()方法，请求重新draw()，但只会绘制调用者本身。</p>\n<p>   2、setSelection()方法 ：请求重新draw()，但只会绘制调用者本身。</p>\n<p>   3、setVisibility()方法 ： 当View可视状态在INVISIBLE转换VISIBLE时，会间接调用invalidate()方法 继而绘制该View。</p>\n<p>   4 、setEnabled()方法 ： 请求重新draw()，但不会重新绘制任何视图包括该调用者本身。`</p>","more":"<ul>\n<li>requestLayout()方法 </li>\n</ul>\n<p>`：会导致调用measure()过程 和 layout()过程 。</p>\n<p>说明：只是对View树重新布局layout过程包括measure()和layout()过程，不会调用draw()过程，但不会重新绘制</p>\n<p>任何视图包括该调用者本身。</p>\n<p> 一般引起invalidate()操作的函数如下：<br> 1、setVisibility()方法：<br> 当View的可视状态在INVISIBLE/ VISIBLE 转换为GONE状态时，会间接调用requestLayout() 和invalidate方法。<br> 同时，由于整个个View树大小发生了变化，会请求measure()过程以及draw()过程，同样地，只绘制需要“重新绘制”的视图。`</p>\n<ul>\n<li><p>requestFocus()函数说明：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">说明：请求View树的draw()过程，但只绘制“需要重绘”的视图。</div></pre></td></tr></table></figure>\n</li>\n<li><p>View的坐标参数 主要有哪些？分别有什么注意的要点？</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">Left，Right，top,Bottom 注意这4个值其实就是 view 和 他的父控件的 相对坐标值。 并非是距离屏幕左上角的绝对值，这点要注意。</div><div class=\"line\">　</div><div class=\"line\">　此外，X和Y 其实也是相对于父控件的坐标值。 TranslationX,TranslationY 这2个值 默认都为0，是相对于父控件的左上角的偏移量。</div><div class=\"line\">　</div><div class=\"line\">　换算关系：</div><div class=\"line\">　</div><div class=\"line\">　x=left+tranX,y=top+tranY.</div><div class=\"line\">　 </div><div class=\"line\"> 很多人不理解，为什么事这样，其实就是View 如果有移动的话，比如平移这种，你们就要注意了，top和left 这种值 是不会变化的。</div><div class=\"line\">  </div><div class=\"line\">  无论你把view怎么拖动，但是 x,y,tranX,tranY 的值是随着拖动平移 而变化的。想明白这点 就行了。</div></pre></td></tr></table></figure>\n<ul>\n<li>onTouchEvent和GestureDetector 在什么时候用哪个比较好</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">只有滑动需求的时候 就用前者，如果有双击等这种行为的时候 就用后者。</div></pre></td></tr></table></figure>\n<ul>\n<li>.Scroller 用来解决什么问题？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">view的scrollTo和scrollBy 滑动效果太差了，是瞬间完成。而scroller可以配合view的computeScroll 来完成 渐变的滑动效果。体验更好。</div></pre></td></tr></table></figure>\n<ul>\n<li>ScrollTo和ScrollBy 有什么需要注意的？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">前者是绝对滑动，后者是相对滑动。滑动的是view的内容 而不是view本身。这很重要。比如textview 调用这2个方法  滑动的就是显示出来的字的内容。</div><div class=\"line\"></div><div class=\"line\">一般而言 我们用scrollBy会比较多一些。传值的话 其实 记住几个法则就可以了。 右-左 x为正 否则x为负  上-下 y为负，否则y为正。</div><div class=\"line\"></div><div class=\"line\">可以稍微看一下 这2个的源码：</div><div class=\"line\">public void scrollTo(int x, int y) &#123;</div><div class=\"line\">        if (mScrollX != x || mScrollY != y) &#123;</div><div class=\"line\">            int oldX = mScrollX;</div><div class=\"line\">            int oldY = mScrollY;</div><div class=\"line\">            mScrollX = x;</div><div class=\"line\">            mScrollY = y;</div><div class=\"line\">            invalidateParentCaches();</div><div class=\"line\">            onScrollChanged(mScrollX, mScrollY, oldX, oldY);</div><div class=\"line\">            if (!awakenScrollBars()) &#123;</div><div class=\"line\">                postInvalidateOnAnimation();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"> public void scrollBy(int x, int y) &#123;</div><div class=\"line\">        scrollTo(mScrollX + x, mScrollY + y);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">看到里面有2个变量 mScrollX 和mScrollY 这2个东西没，这2个单位的 值是像素，前者代表 view的左边缘和view内容左边缘的距离。 后者代表 view上边缘和view内容上边缘的距离。</div></pre></td></tr></table></figure>\n<ul>\n<li>让view滑动总共有几种方式，分别要注意什么？都适用于那些场景？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">总共有三种：</div><div class=\"line\"></div><div class=\"line\">a：scrollto，scrollby。这种是最简单的，但是只能滑动view的内容 不可以滑动view本身。</div><div class=\"line\"></div><div class=\"line\">b：动画。动画可以滑动view内容，但是注意非属性动画 就如我们问题5说的内容 会影响到交互，使用的时候要多注意。不过多数复杂的滑动效果都是属性动画来完成的，属于大杀器级别、</div><div class=\"line\"></div><div class=\"line\">c：改变布局参数。这种最好理解了，无非是动态的通过java代码来修改 margin等view的参数罢了。不过用的比较少。我本人不怎么用这种方法。</div></pre></td></tr></table></figure>\n<ul>\n<li>.Scroller是干嘛的？原理是什么？</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">```</div><div class=\"line\"></div><div class=\"line\">- getWidth()与getMeasuredWidth()`有什么区别呢？</div></pre></td></tr></table></figure>\n<p>一般情况下这两个的值是相同的，<code>getMeasureWidth()</code>方法在<code>measure()</code>过程结束后就可以获取到了，而<code>getWidth()</code>方法要在<code>layout()</code>过程结束后才能获取到。<br>而且<code>getMeasureWidth()</code>的值是通过<code>setMeasuredDimension()</code>设置的，但是<code>getWidth()</code>的值是通过视图右边的坐标减去左边的坐标计算出来的。如果我们在<code>layout</code>的时候将宽高<br>不传<code>getMeasureWidth</code>的值，那么这时候<code>getWidth()</code>与<code>getMeasuredWidth</code>的值就不会再相同了，当然一般也不会这么干…</p>\n<p>```</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjecoc8h90000fuv1i474ntb9","category_id":"cjecoc8hk0003fuv14we9ud9i","_id":"cjecoc8hv000bfuv16n4y3pww"},{"post_id":"cjecoc8hq000afuv1ox3cp7o9","category_id":"cjecoc8hp0008fuv1dx8wjiup","_id":"cjecoc8i5000ifuv1rjfafah4"},{"post_id":"cjecoc8he0001fuv1b9l9hzj9","category_id":"cjecoc8hp0008fuv1dx8wjiup","_id":"cjecoc8i8000mfuv1f3sgc9mi"},{"post_id":"cjecoc8hz000cfuv1j5c8g9mz","category_id":"cjecoc8hp0008fuv1dx8wjiup","_id":"cjecoc8ia000ofuv1e1hdlab2"},{"post_id":"cjecoc8i2000gfuv1zxnwigrc","category_id":"cjecoc8hp0008fuv1dx8wjiup","_id":"cjecoc8if000sfuv1sp7u6igq"},{"post_id":"cjecoc8hl0004fuv17u9icdw9","category_id":"cjecoc8hk0003fuv14we9ud9i","_id":"cjecoc8if000tfuv1fdp6hyw7"},{"post_id":"cjecoc8hm0005fuv1c00jf4mq","category_id":"cjecoc8i6000jfuv1gdvik09l","_id":"cjecoc8ih000vfuv1yqoc0ux5"},{"post_id":"cjecoc8hn0007fuv13gp6calf","category_id":"cjecoc8if000rfuv1j4b06ajd","_id":"cjecoc8ih000yfuv19txz8hya"}],"PostTag":[{"post_id":"cjecoc8h90000fuv1i474ntb9","tag_id":"cjecoc8hh0002fuv1qst8gf5w","_id":"cjecoc8hp0009fuv176d8qjfu"},{"post_id":"cjecoc8hq000afuv1ox3cp7o9","tag_id":"cjecoc8hn0006fuv18h1kpkf5","_id":"cjecoc8i1000ffuv1qqhvewix"},{"post_id":"cjecoc8he0001fuv1b9l9hzj9","tag_id":"cjecoc8hn0006fuv18h1kpkf5","_id":"cjecoc8i5000hfuv1pl4eqtuz"},{"post_id":"cjecoc8hz000cfuv1j5c8g9mz","tag_id":"cjecoc8hn0006fuv18h1kpkf5","_id":"cjecoc8i7000lfuv1vwypi2qa"},{"post_id":"cjecoc8i2000gfuv1zxnwigrc","tag_id":"cjecoc8hn0006fuv18h1kpkf5","_id":"cjecoc8i9000nfuv1s45ryfz5"},{"post_id":"cjecoc8hl0004fuv17u9icdw9","tag_id":"cjecoc8i1000dfuv1vdh2o2et","_id":"cjecoc8if000qfuv1xlky5d0y"},{"post_id":"cjecoc8hm0005fuv1c00jf4mq","tag_id":"cjecoc8i1000dfuv1vdh2o2et","_id":"cjecoc8ih000wfuv1q5r686e3"},{"post_id":"cjecoc8hm0005fuv1c00jf4mq","tag_id":"cjecoc8ie000pfuv15756kdiy","_id":"cjecoc8ih000xfuv1llpz06di"},{"post_id":"cjecoc8hn0007fuv13gp6calf","tag_id":"cjecoc8if000ufuv1jgl7xgzi","_id":"cjecoc8ii000zfuv1x09e6bdg"}],"Tag":[{"name":"线程","_id":"cjecoc8hh0002fuv1qst8gf5w"},{"name":"View","_id":"cjecoc8hn0006fuv18h1kpkf5"},{"name":"Bitmap","_id":"cjecoc8i1000dfuv1vdh2o2et"},{"name":"Drawable","_id":"cjecoc8ie000pfuv15756kdiy"},{"name":"Handler","_id":"cjecoc8if000ufuv1jgl7xgzi"}]}}